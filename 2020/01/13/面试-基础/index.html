<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="面试中最基础的计网、操作系统以及数据库。">
<meta property="og:type" content="article">
<meta property="og:title" content="面试-基础">
<meta property="og:url" content="http://yoursite.com/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="群芳髓">
<meta property="og:description" content="面试中最基础的计网、操作系统以及数据库。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%BD%911_1.png">
<meta property="og:image" content="http://yoursite.com/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png">
<meta property="og:image" content="http://yoursite.com/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png">
<meta property="og:image" content="http://yoursite.com/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/%E6%85%A2%E5%90%AF%E5%8A%A8.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/123.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/IP%E5%88%86%E7%B1%BB.png">
<meta property="og:image" content="http://yoursite.com/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/ARP.png">
<meta property="og:image" content="http://yoursite.com/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/%E7%AB%AF%E5%8F%A3.png">
<meta property="og:image" content="http://yoursite.com/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png">
<meta property="og:image" content="http://yoursite.com/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png">
<meta property="og:image" content="http://yoursite.com/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB.png">
<meta property="og:image" content="http://yoursite.com/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/%E7%B4%A2%E5%BC%951.png">
<meta property="og:image" content="http://yoursite.com/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93.webp">
<meta property="article:published_time" content="2020-01-13T07:48:01.000Z">
<meta property="article:modified_time" content="2020-01-21T14:26:13.582Z">
<meta property="article:author" content="chen">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%BD%911_1.png">

<link rel="canonical" href="http://yoursite.com/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>面试-基础 | 群芳髓</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">群芳髓</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="chen">
      <meta itemprop="description" content="冰冻三尺 非一日之寒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="群芳髓">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试-基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-13 15:48:01" itemprop="dateCreated datePublished" datetime="2020-01-13T15:48:01+08:00">2020-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-21 22:26:13" itemprop="dateModified" datetime="2020-01-21T22:26:13+08:00">2020-01-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>面试中最基础的计网、操作系统以及数据库。</p>
<a id="more"></a>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/计网1_1.png">
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    font-size: 100%;
    display: inline-block;
    color: #999;
    padding: 0px;">计算机网络体系分层结构</div>
</center>

<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。<br>所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/三次握手.png">
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 0px;">三次握手过程</div>
</center>

<p>1.TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了<code>LISTEN</code>（监听）状态；<br>2.TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位<code>SYN=1</code>，同时选择一个初始序列号<code>seq=x</code>，此时，TCP客户端进程进入了<code>SYN-SENT</code>（同步已发送状态）状态。<strong>TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</strong><br>3.TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 <code>ACK=1，SYN=1</code>，确认号是<code>ack=x+1</code>，同时也要为自己初始化一个序列号<code>seq=y</code>，此时，TCP服务器进程进入了<code>SYN-RCVD</code>（同步收到）状态。<strong>这个报文也不能携带数据，但是同样要消耗一个序号。</strong><br>4.TCP客户进程收到确认后，还要向服务器给出确认。确认报文的<code>ACK=1，ack=y+1</code>，自己的序列号<code>seq=x+1</code>，此时，TCP连接建立，客户端进入<code>ESTABLISHED</code>（已建立连接）状态。<strong>TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</strong><br>5.当服务器收到客户端的确认后也进入<code>ESTABLISHED</code>状态，此后双方就可以开始通信了。</p>
<h3 id="为什么TCP链接需要三次握手，两次不可以么"><a href="#为什么TCP链接需要三次握手，两次不可以么" class="headerlink" title="为什么TCP链接需要三次握手，两次不可以么"></a>为什么TCP链接需要三次握手，两次不可以么</h3><p>为了防止<strong>已失效的链接请求报文突然又传送到了服务端</strong>，因而产生错误。<br>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。<br>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/四次挥手.png">
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 0px;">四次挥手过程</div>
</center>

<p>1.客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，<code>FIN=1</code>，其序列号为<code>seq=u</code>（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入<code>FIN-WAIT-1</code>（终止等待1）状态。 <strong>TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</strong><br>2.服务器收到连接释放报文，发出确认报文，<code>ACK=1</code>，<code>ack=u+1</code>，并且带上自己的序列号<code>seq=v</code>，此时，服务端就进入了<code>CLOSE-WAIT</code>（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个<code>CLOSE-WAIT</code>状态持续的时间。<br>3.客户端收到服务器的确认请求后，此时，客户端就进入<code>FIN-WAIT-2</code>（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。<br>4.服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，<code>FIN=1</code>，<code>ack=u+1</code>，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为<code>seq=w</code>，此时，服务器就进入了<code>LAST-ACK</code>（最后确认）状态，等待客户端的确认。<br>5.客户端收到服务器的连接释放报文后，必须发出确认，<code>ACK=1</code>，<code>ack=w+1</code>，而自己的序列号是<code>seq=u+1</code>，此时，客户端就进入了<code>TIME-WAIT</code>（时间等待）状态。<strong>注意此时TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入<code>CLOSED</code>状态。</strong><br>6.服务器只要收到了客户端发出的确认，立即进入<code>CLOSED</code>状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>
<h3 id="为什么客户端最后还要等待2-MSL"><a href="#为什么客户端最后还要等待2-MSL" class="headerlink" title="为什么客户端最后还要等待2*MSL"></a>为什么客户端最后还要等待2*MSL</h3><p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。<br>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。<br>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>
<h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办</h3><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h2 id="Get与POST的区别"><a href="#Get与POST的区别" class="headerlink" title="Get与POST的区别"></a>Get与POST的区别</h2><p>1.从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；<br>2.从REST服务角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变；<br>3.从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的<code>header</code>中，以<code>?</code>分割URL和传输数据，参数之间以<code>&amp;</code>相连。特别地，如果数据是<code>英文字母/数字</code>，原样发送；否则，会将其编码为 <code>application/x-www-form-urlencoded MIME</code> 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用<code>BASE64</code>加密，得出如：<code>%E4%BD%A0%E5%A5%BD</code>，其中<code>％XX</code>中的<code>XX</code>为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的<code>body</code>中。<br>4.就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。<br>5.从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。</p>
<h2 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><p>计算机网络中的带宽、交换结点中的缓存和处理机等，都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏。这种情况就叫做拥塞。<br>拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。<strong>拥塞控制是一个全局性的过程，和流量控制不同，流量控制指点对点通信量的控制。</strong><br>发送方维持一个叫做<strong>拥塞窗口cwnd</strong>（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。<br>1.<strong>慢启动</strong>：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;一次传输轮次之后拥塞窗口就加倍。这就是乘法增长。<br> 为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：<br>当cwnd &lt; ssthresh时，使用慢启动算法。<br>当cwnd &gt; ssthresh时，改用拥塞避免算法。<br>当cwnd = ssthresh时，慢启动与拥塞避免算法任意。<br>2.<strong>拥塞避免</strong>：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。<br>无论是在慢启动阶段还是在拥塞避免阶段，只要发送方判断网络<strong>出现拥塞</strong>（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢启动门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如下图：</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/慢启动.jpg">
</center>

<p>这里只是为了讨论方便而将拥塞窗口大小的单位改为数据报的个数，实际上应当是字节。<br>3.<strong>快速重传</strong>：快速重传要求接收方在收到一个<strong>失序的报文段</strong>后就立即发出 重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快速重传算法规定，发送方只要一连收到<strong>三个重复确认</strong>就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。<br>4.<strong>快速恢复</strong>:当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢启动算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/快速恢复.jpg">
</center>

<h2 id="从输入网址到获得页面的过程"><a href="#从输入网址到获得页面的过程" class="headerlink" title="从输入网址到获得页面的过程"></a>从输入网址到获得页面的过程</h2><center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/123.jpg">
</center>

<h2 id="IP地址分为哪几类"><a href="#IP地址分为哪几类" class="headerlink" title="IP地址分为哪几类"></a>IP地址分为哪几类</h2><center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/IP分类.png">
</center>

<h3 id="保留地址"><a href="#保留地址" class="headerlink" title="保留地址"></a>保留地址</h3><p>A类：10.0.0.0 - 10.255.255.255<br>B类：172.16.0.0 - 172.31.255.255<br>C类：192.168.0.0 - 192.168.255.255</p>
<h2 id="ARP协议的工作过程"><a href="#ARP协议的工作过程" class="headerlink" title="ARP协议的工作过程"></a>ARP协议的工作过程</h2><center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/ARP.png">
</center>

<h2 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h2><p>1×× : 请求处理中，请求已被接受，正在处理<br>2×× : 请求成功，请求被成功处理 <code>200 OK</code><br>3×× : 重定向，要完成请求必须进行进一步处理<br><code>301 : 永久性转移</code> <code>302 ：暂时性转移</code> <code>304 ：已缓存</code><br>4×× : 客户端错误，请求不合法<br><code>400：Bad Request,请求有语法问题</code> <code>403：拒绝请求</code> <code>404：客户端所访问的页面不存在</code><br>5×× : 服务器端错误，服务器不能处理合法请求<br><code>500 ：服务器内部错误</code> <code>503 ： 服务不可用，稍等</code></p>
<h2 id="简单说一下你了解的端口及对应的服务"><a href="#简单说一下你了解的端口及对应的服务" class="headerlink" title="简单说一下你了解的端口及对应的服务"></a>简单说一下你了解的端口及对应的服务</h2><center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/端口.png">
</center>

<h2 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h2><p>TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议，它们之间的区别包括：<br>TCP是面向连接的，UDP是无连接的；<br>TCP是可靠的，UDP是不可靠的；<br>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；<br>TCP是面向字节流的，UDP是面向报文的；<br>TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；<br>TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；</p>
<h2 id="HTTPS和HTTP的区别"><a href="#HTTPS和HTTP的区别" class="headerlink" title="HTTPS和HTTP的区别"></a>HTTPS和HTTP的区别</h2><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。<br>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。<br>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
<h2 id="Session、Cookie-与-Application"><a href="#Session、Cookie-与-Application" class="headerlink" title="Session、Cookie 与 Application"></a>Session、Cookie 与 Application</h2><p>Cookie和Session都是客户端与服务器之间保持状态的解决方案，具体来说，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，而客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器，服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>同样地，会话状态也可以保存在服务器端。客户端请求服务器，如果服务器记录该用户状态，就获取Session来保存状态，这时，如果服务器已经为此客户端创建过session，服务器就按照sessionid把这个session检索出来使用；如果客户端请求不包含sessionid，则为此客户端创建一个session并且生成一个与此session相关联的sessionid，并将这个sessionid在本次响应中返回给客户端保存。保存这个sessionid的方式可以采用<strong>cookie机制</strong>，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器；若浏览器禁用Cookie的话，可以通过<strong>URL重写机制</strong>将sessionid传回服务器。</p>
<h3 id="Session-与-Cookie-的对比"><a href="#Session-与-Cookie-的对比" class="headerlink" title="Session 与 Cookie 的对比"></a>Session 与 Cookie 的对比</h3><p>1.实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；<br>2.大小限制：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；<br>3.安全性：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；<br>4.服务器资源消耗：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。</p>
<h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>Application（Java Web中的ServletContext）：与一个Web应用程序相对应，为应用程序提供了一个全局的状态，所有客户都可以使用该状态。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">TCP的三次握手与四次挥手</a><br><a href="https://blog.csdn.net/justloveyou_/article/details/78303617" target="_blank" rel="noopener">计算机网络面试问题集锦</a><br><a href="https://zhuanlan.zhihu.com/p/24001696" target="_blank" rel="noopener">计算机网络</a></p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="并发与并行区别"><a href="#并发与并行区别" class="headerlink" title="并发与并行区别"></a>并发与并行区别</h2><p>并发（concurrency）：把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行。(同一时间段)<br>并行（parallelism）：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行。(同一时刻)</p>
<h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h3><p>是指允许多个作业（程序）同时进入计算机系统的内存并启动交替计算的方法。也就是说，内存中多个相互独立的程序均处于开始和结束之间。<br>从宏观上看是并行的，多道程序都处于运行过程中，但尚未运行结束；<br>从微观角度上看是串行的，各道程序轮流的占用CPU交替的执行。<br>引入多道程序设计技术可以提高CPU的利用率，充分发挥计算机硬部件的并行性。</p>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。进程是一种数据结构。<br>第二，进程是一个 “执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程。<br><strong>进程最基本的特征是并发和共享特征</strong></p>
<h4 id="进程类型"><a href="#进程类型" class="headerlink" title="进程类型"></a>进程类型</h4><p>系统进程：操作系统用来管理资源的进程，当系统进程处于运行态时，CPU处于管态，系统之间的关系由操作系统负责。<br>用户进程：操作系统可以独立执行的的用户程序段，当用户进程处于运行态时，CPU处于目态，用户进程之间的关系由用户负责。</p>
<h4 id="进程的三个组成部分"><a href="#进程的三个组成部分" class="headerlink" title="进程的三个组成部分"></a>进程的三个组成部分</h4><p>1.程序<br>2.数据<br>3.进程控制块（PCB）：为了管理和控制进程，系统在创建每个进程时，都为其开辟一个专用的存储区，用以记录它在系统中的动态特性。系统根据存储区的信息对进程实施控制管理。进程任务完成后，系统收回该存储区，进程随之消亡，这一存储区就是进程控制块<br>PCB随着进程的创建而建立，撤销而消亡。系统根据PCB感知一个进程的存在，<strong>PCB是进程存在的唯一物理标识</strong>（这一点可以类比作业控制块JCB）</p>
<h4 id="进程的三个状态"><a href="#进程的三个状态" class="headerlink" title="进程的三个状态"></a>进程的三个状态</h4><center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/进程状态.png">
</center>

<p>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源；<br>运行状态：占用处理机资源运行，<strong>处于此状态的进程数小于等于CPU数</strong>；<br>阻塞状态： 进程等待某种条件，在条件满足之前无法执行；</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><blockquote>
<p>如果说操作系统中引入进程的目的是为了使多个程序并发执行，以便改善资源利用率和提高系统效率，那么，在进程之后再引入线程概念则是为了减少程序并发执行时所付出的时空开销，使得并发粒度更细、并发性更好。解决问题的基本思路是：把进程的两项功能“独立分配资源”和“被调度分配执行”分离开来，前一项任务仍然由进程完成，作为系统资源分配和保护的独立单位，无须频繁切换；后一项任务交给称作线程的实体来完成，线程作为系统调度和分配的基本单位，会被频繁的调度和切换。在这种思想的指导下产生了多线程的概念，及多线程(结构)进程。</p>
</blockquote>
<h4 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h4><p>线程，有时被称为轻量进程(Lightweight Process，LWP），是程序执行流的最小单元。是被系统独立调度和分派的基本单位。<br>一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。</p>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p>在 Java虚拟机 中，线程从最初的创建到最终的消亡，要经历若干个状态：创建(new)、就绪(runnable)、运行(running)、阻塞(blocked)和死亡(dead)。在给定的时间点上，一个线程只能处于一种状态。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/线程状态.png">
</center>

<h3 id="进程与程序区别"><a href="#进程与程序区别" class="headerlink" title="进程与程序区别"></a>进程与程序区别</h3><p>1.进程是一个动态的概念<br>进程是程序的一次执行过程，是动态概念<br>程序是一组有序的指令和数据集和，是静态概念<br>2.进程有自己的生命周期<br>当操作系统要完成某个任务时，它会创建一个进程。当进程完成任务之后，系统就会撤销这个进程，收回它所占用的资源。从创建到撤销的时间段就是进程的生命周期。而程序可以作为一种软件资料永久保存。<br>3.进程之间存在并发性<br>进程是一个动态的概念，是一个可以独立运行的单位。在一个系统中，同时会存在多个进程。他们轮流占用CPU和各种资源。<br>4.进程与程序之间无一一对应关系<br>不同的进程可以包含同一程序，同一程序在执行中也可以产生多个进程。<br>不同的进程可以执行同一个程序。<br><strong>区分进程的条件：所执行的程序和数据集合。</strong><br>两个进程即使执行在相同的程序上，只要他们运行在不同的数据集合上，他们也是两个进程。<br>5.进程间存在着相互制约<br>进程是系统中资源分配和运行调度的单位，在对资源的共享和竞争中，必然相互制约，影响各自向前推进的速度。<br>6.程序是记录在介质上指令的有序集合，而进程则由程序、数据和进程控制块(Process Control Block, PCB)3部分组成<br>7.进程可以创建子进程，程序不能创建子程序<br>一个用户进程在运行过程中可以创建一个或多个子进程为其服务。当一个进程创建另一个进程时，生成进程称为父进程，被生成进程称为子进程，父进程还可以创建多个子进程，从而形成树状族系关系。</p>
<h3 id="线程与进程联系"><a href="#线程与进程联系" class="headerlink" title="线程与进程联系"></a>线程与进程联系</h3><p>从一定意义上讲，进程就是一个应用程序在处理机上的一次执行过程，它是一个动态的概念，而线程是进程中的一部分，进程包含多个线程在运行。 程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程。 通常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源。在引入线程的操作系统中，<strong>通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位</strong>。由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统内多个程序间并发执行的程度。</p>
<h3 id="线程与进程区别"><a href="#线程与进程区别" class="headerlink" title="线程与进程区别"></a>线程与进程区别</h3><blockquote>
<p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，<strong>一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮</strong>，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>
</blockquote>
<p>一个程序至少有一个进程, 一个进程至少有一个线程。<br>线程的划分尺度小于进程，使得多线程程序的并发性高。<br>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。<br>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p>
<h2 id="进程间的通信的几种方式"><a href="#进程间的通信的几种方式" class="headerlink" title="进程间的通信的几种方式"></a>进程间的通信的几种方式</h2><h3 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道(pipe)"></a>管道(pipe)</h3><p>匿名管道(pipe)：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。<br>流管道(s_pipe): 去除了第一种限制,可以双向传输。<br>命名管道(name_pipe):克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</p>
<h3 id="信号量-semophore"><a href="#信号量-semophore" class="headerlink" title="信号量(semophore)"></a>信号量(semophore)</h3><p>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
<h3 id="消息队列-message-queue"><a href="#消息队列-message-queue" class="headerlink" title="消息队列(message queue)"></a>消息队列(message queue)</h3><p>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<h3 id="信号（signal）"><a href="#信号（signal）" class="headerlink" title="信号（signal）"></a>信号（signal）</h3><p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。主要作为进程间以及同一进程不同线程之间的同步手段。</p>
<h3 id="共享内存-shared-memory"><a href="#共享内存-shared-memory" class="headerlink" title="共享内存(shared memory)"></a>共享内存(shared memory)</h3><p>可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。</p>
<h3 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h3><p>这是一种更为一般的进程间通信机制，，与其他通信机制不同的是，它可用于不同机器间的进程通信。</p>
<h2 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h2><p>线程的最大特点是资源的共享性，但资源共享中的同步问题是多线程编程的难点。Linux下提供了多种方式来处理线程同步，最常用的是互斥锁、条件变量、信号量和读写锁。</p>
<h3 id="互斥锁（mutex）"><a href="#互斥锁（mutex）" class="headerlink" title="互斥锁（mutex）"></a>互斥锁（mutex）</h3><p>锁机制是同一时刻只允许一个线程执行一个关键部分的代码，通过锁机制实现线程间的同步。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</p>
<h3 id="条件变量（cond）"><a href="#条件变量（cond）" class="headerlink" title="条件变量（cond）"></a>条件变量（cond）</h3><p>条件变量是用来等待而不是用来上锁的，是利用线程间共享全局变量进行同步的一种机制。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。条件变量分为两部分: 条件和变量。条件本身是由互斥量保护的。线程在改变条件状态前先要锁住互斥量。条件变量使我们可以睡眠等待某种条件出现。</p>
<h3 id="信号量-Semphare"><a href="#信号量-Semphare" class="headerlink" title="信号量(Semphare)"></a>信号量(Semphare)</h3><p>它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。信号量函数的名字都以<code>sem_</code>打头。</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁与互斥量的功能类似，对临界区的共享资源进行保护。互斥量一次只让一个线程进入临界区，读写锁比它有更高的并行性。读写锁适合于对数据结构的读次数比写次数多得多的情况。因为, 读模式锁定时可以共享, 以写模式锁住时意味着独占, 所以读写锁又叫共享-独占锁。<br>读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者：<br>如果读写锁当前没有读者，也没有写者，那么写者可以立刻获得读写锁，否则它必须自旋在那里，直到没有任何写者或读者。如果读写锁没有写者，那么读者可以立即获得该读写锁，否则读者必须自旋在那里，直到写者释放该读写锁。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁是一个互斥设备，它只有两个值：“锁定”和“解锁”。如果锁可用，则“锁定”被设置，而代码继续进入临界区；相反，如果锁被其他人获得，则代码进入忙循环（而不是休眠，这也是自旋锁和一般锁的区别）并重复检查这个锁，直到该锁可用为止，这就是自旋的过程。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁定义"><a href="#死锁定义" class="headerlink" title="死锁定义"></a>死锁定义</h3><p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去</p>
<h3 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h3><p>（1）互斥：一个资源每次只能被一个进程使用。<br>（2）请求和保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>（3）不可抢占:进程已获得的资源，在末使用完之前，不能强行剥夺。<br>（4）循环等待:若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<h3 id="产生死锁原因"><a href="#产生死锁原因" class="headerlink" title="产生死锁原因"></a>产生死锁原因</h3><p>（1）因为系统资源不足。<br>（2）进程运行推进的顺序不合适。<br>（3）资源分配不当等。</p>
<h3 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h3><p>解决死锁的基本方法主要有预防死锁、避免死锁、检测死锁、解除死锁 、鸵鸟策略 等</p>
<h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p>死锁预防的基本思想是：只要确保死锁发生的四个必要条件中至少有一个不成立，就能预防死锁的发生。</p>
<h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p>死锁解除的常用两种方法为进程终止和资源抢占。所谓进程终止是指简单地终止一个或多个进程以打破循环等待，包括两种方式：终止所有死锁进程和一次只终止一个进程直到取消死锁循环为止；所谓资源抢占是指从一个或多个死锁进程那里抢占一个或多个资源。其中最具有代表性的避免死锁算法是银行家算法。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。</p>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>段是按照程序的自然分界划分的长度可以动态改变的区域。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中（写c程序时会用到），并且每个程序可以有多个相同类型的段。将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。</p>
<h3 id="分页与分段区别"><a href="#分页与分段区别" class="headerlink" title="分页与分段区别"></a>分页与分段区别</h3><p><strong>目的不同</strong>：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；<br><strong>大小不同</strong>：页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；而段的长度却不固定，由其所完成的功能决定；<br><strong>地址空间不同</strong>： 分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间则是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。<br><strong>信息共享</strong>：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；<br><strong>内存碎片</strong>：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。</p>
<h3 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h3><p>分页系统能有效地提高内存的利用率，而分段系统能反映程序的逻辑结构，便于段的共享与保护，将分页与分段两种存储方式结合起来，就形成了段页式存储管理方式。<br>在段页式存储管理系统中，作业的地址空间首先被分成若干个逻辑分段，每段都有自己的段号，然后再将每段分成若干个大小相等的页。对于主存空间也分成大小相等的页，主存的分配以页为单位。<br>为实现段页式存储管理，系统应为每个进程设置一个段表，包括每段的段号，该段的页表始址和页表长度。每个段有自己的页表，记录段中的每一页的页号和存放在主存中的物理块号。段页式系统中，作业的地址结构包含三部分的内容：段号，页号，页内位移量。</p>
<h2 id="操作系统中进程调度策略"><a href="#操作系统中进程调度策略" class="headerlink" title="操作系统中进程调度策略"></a>操作系统中进程调度策略</h2><h3 id="FCFS-先来先服务"><a href="#FCFS-先来先服务" class="headerlink" title="FCFS(先来先服务)"></a>FCFS(先来先服务)</h3><p>队列实现，非抢占的，先请求CPU的进程先分配到CPU</p>
<h3 id="SJF-最短作业优先调度算法"><a href="#SJF-最短作业优先调度算法" class="headerlink" title="SJF(最短作业优先调度算法)"></a>SJF(最短作业优先调度算法)</h3><p>对预计执行时间短的进程优先分派处理机。通常后来的短进程不抢先正在执行的进程，对长进程非常不利。</p>
<h3 id="高响应比优先法-HRRN"><a href="#高响应比优先法-HRRN" class="headerlink" title="高响应比优先法(HRRN)"></a>高响应比优先法(HRRN)</h3><p>CFS方式只考虑每个作业的等待时间而未考虑执行时间的长短，而SJF方式只考虑执行时间而未考虑等待时间的长短。HRRN调度策略同时考虑每个作业的等待时间长短和估计需要的执行时间长短，从中选出响应比最高的作业投入执行。这种算法是介于FCFS和SJF之间的一种折中算法。</p>
<h3 id="高优先级调度算法"><a href="#高优先级调度算法" class="headerlink" title="高优先级调度算法"></a>高优先级调度算法</h3><p>可以是抢占的，也可以是非抢占的。优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：老化</p>
<h3 id="时间片轮转算法（RR，Round-Robin）"><a href="#时间片轮转算法（RR，Round-Robin）" class="headerlink" title="时间片轮转算法（RR，Round-Robin）"></a>时间片轮转算法（RR，Round-Robin）</h3><p>可抢占的，队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。</p>
<h3 id="多级队列调度算法"><a href="#多级队列调度算法" class="headerlink" title="多级队列调度算法"></a>多级队列调度算法</h3><p>将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。</p>
<h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><p>与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。</p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>虚拟内存允许执行进程不必完全在内存中。<br>每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。<br>这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上。<br>注意，请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。</p>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="最佳置换算法（OPT）"><a href="#最佳置换算法（OPT）" class="headerlink" title="最佳置换算法（OPT）"></a>最佳置换算法（OPT）</h4><p>这是一种理想情况下的页面置换算法，但实际上是不可能实现的。保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。</p>
<h4 id="先进先出置换算法（FIFO）"><a href="#先进先出置换算法（FIFO）" class="headerlink" title="先进先出置换算法（FIFO）"></a>先进先出置换算法（FIFO）</h4><p>最简单的页面置换算法，总是选择在主存中停留时间最长（即最老）的一页置换，即先进入内存的页，先退出内存。</p>
<h4 id="最近最久未使用算法（LRU，Least-recently-use）"><a href="#最近最久未使用算法（LRU，Least-recently-use）" class="headerlink" title="最近最久未使用算法（LRU，Least recently use）"></a>最近最久未使用算法（LRU，Least recently use）</h4><p>当需要置换一页时，选择在最近一段时间里最久没有使用过的页面予以置换。</p>
<h4 id="最近最少使用置换算法（LFU，Least-frequently-use）"><a href="#最近最少使用置换算法（LFU，Least-frequently-use）" class="headerlink" title="最近最少使用置换算法（LFU，Least frequently use）"></a>最近最少使用置换算法（LFU，Least frequently use）</h4><p>基于“如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小”的思路。</p>
<h3 id="颠簸"><a href="#颠簸" class="headerlink" title="颠簸"></a>颠簸</h3><p>颠簸本质上是指频繁的页调度行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此，会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）。</p>
<h2 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者-消费者模型"></a>生产者-消费者模型</h2><p>生产者-消费者模式是一个十分经典的多线程并发协作的模式，所谓生产者-消费者问题，实际上主要是包含了两类线程，一种是生产者线程用于生产数据，另一种是消费者线程用于消费数据，为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库，生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为；而消费者只需要从共享数据区中去获取数据，就不再需要关心生产者的行为。但是，这个共享数据区域中应该具备这样的线程间并发协作的功能：<br>1.如果共享数据区已满的话，阻塞生产者继续生产数据放置入内；<br>2.如果共享数据区为空的话，阻塞消费者继续消费数据；</p>
<h2 id="并发编程问题"><a href="#并发编程问题" class="headerlink" title="并发编程问题"></a>并发编程问题</h2><p>多线程并发执行的时候会遇到各种各样的挑战：</p>
<h3 id="上下文切换问题"><a href="#上下文切换问题" class="headerlink" title="上下文切换问题"></a>上下文切换问题</h3><p>CPU通过给每个线程分配CPU时间片来实现多线程任务之间的并发执行。CPU通过时间片分配算法来循环执行任务，当CPU为当前线程分配的时间片消耗完（时间片一般是几十ms），CPU会切出去执行另外的一个线程（<strong>切换会有消耗时间</strong>），但是在CPU切换出去之前，会保存上一个任务的状态，以便下次切换回这个线程的时候能够紧接着保存的状态继续向下执行任务。我们称线程任务从保存到再次被执行的过程为一次上下文切换。</p>
<blockquote>
<p>为什么数据量小的时候并发执行的效率会慢呢：<br>1.线程创建会有开销<br>2.上下文切换也会有开销</p>
</blockquote>
<h3 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h3><h3 id="资源限制问题"><a href="#资源限制问题" class="headerlink" title="资源限制问题"></a>资源限制问题</h3><p>资源限制是指在进行并发编程的时候，程序的执行速度受限于计算机的硬件资源和软件资源，比如服务器的带宽只有2Mb/s，某个资源的下载速度是1Mb/s，开启10个线程下载，速度不会变成10Mb/s。<br> <strong>硬件资源限制：</strong><br>1.带宽的上传/下载速度<br>2.硬盘的读写速度<br>3.CPU的处理速度<br><strong>软件资源限制：</strong><br>1.数据库连接数<br>2.socket连接数（就是多少个用户连接你这台服务器）</p>
<h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。</p>
<blockquote>
<p>乐观锁一般会使用版本号机制或CAS算法实现。</p>
</blockquote>
<h4 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h4><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<blockquote>
<p>举一个简单的例子：<br>1.假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为<code>$100</code>。<br>2.操作员A此时将其读出（version=1），并从其帐户余额中扣除<code>$50</code>（<code>$100-$50</code>）。<br>3.在操作员 A 操作的过程中，操作员B 也读入此用户信息（version=1），并从其帐户余额中扣除<code>$2</code>0（<code>$100-$20</code>）。<br>4.操作员 A 完成了修改工作，将数据版本号加一（version=2），连同帐户扣除后余额（<code>balance=$50</code>），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。<br>5.操作员 B 完成了操作，也将版本号加一（version=2）试图向数据库提交数据（<code>balance=$80</code>），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足<strong>提交版本必须大于记录当前版本才能执行更新</strong>的乐观锁策略，因此，操作员 B 的提交被驳回。</p>
</blockquote>
<p>这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</p>
<h4 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h4><p>即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数:<br><code>需要读写的内存值 V</code> <code>进行比较的值 A</code> <code>拟写入的新值 B</code><br>当且仅当V的值等于A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作。</p>
<h5 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h5><p><strong>ABA 问题</strong>：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。<br><strong>循环时间长开销大</strong>:自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。<br><strong>只能保证一个共享变量的原子操作</strong>：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>
<h3 id="两种锁使用场景"><a href="#两种锁使用场景" class="headerlink" title="两种锁使用场景"></a>两种锁使用场景</h3><p>两种锁各有优缺点，乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p>
<h2 id="参考文档-1"><a href="#参考文档-1" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://blog.csdn.net/justloveyou_/article/details/78304294" target="_blank" rel="noopener">操作系统面试问题集锦</a><br><a href="https://zhuanlan.zhihu.com/p/60248566" target="_blank" rel="noopener">进程、线程</a><br><a href="https://www.cnblogs.com/wkfvawl/p/11512407.html" target="_blank" rel="noopener">进程的状态与转换</a><br><a href="https://blog.csdn.net/bupt_tinyfisher/article/details/8939689" target="_blank" rel="noopener">分段和分页内存管理</a><br><a href="https://juejin.im/post/5b4977ae5188251b146b2fc8" target="_blank" rel="noopener">乐观锁与悲观锁</a></p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="事务四大特性-ACID"><a href="#事务四大特性-ACID" class="headerlink" title="事务四大特性(ACID)"></a>事务四大特性(ACID)</h2><blockquote>
<p>事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。<br>个人理解，事务就是对一个事件的操作。</p>
</blockquote>
<p><strong>原子性</strong>（Atomicity）:要么全部执行，要么全部不执行。 如果事务崩溃，状态回到事务之前（事务回滚），就像这个事务从来没有执行过一样。。<br><strong>一致性</strong>（Consistency）:在事务开始之前和事务结束以后，数据的数据的一致性约束没有被破坏。几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致。<br><strong>隔离性</strong>（Isolation）:数据库允许多个并发事务同时对数据进行读写和修改的能力。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。<br><strong>持久性</strong>（Durability）:事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
<h2 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h2><p>数据库针对事务的四种特性，为我们提供的四种隔离级别，由低到高依次为Read uncommitted(未提交读)、Read committed(提交读)、Repeatable read(可重复读)、Serializable(可串行化)，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/数据库隔离.png">
</center>

<p><strong>脏读</strong>：(读取未提交数据)A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。<br><strong>不可重复读</strong>：(前后多次读取，数据内容不一致)事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间 。而在事务A第一次读取数据后，事务B执行更改操作，此时事务A第二次读取，发现其和之前的数据不一样了，也就是数据不重复了，系统不可以读取到重复的数据，称为不可重复读。<br><strong>幻读</strong>:(前后多次读取，数据总量不一致)事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据，称为幻读。</p>
<h2 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h2><p>第一范式：要求有主键(不能出现重复记录)，并且要求每一个字段原子性不可再分。<strong>1NF是所有关系型数据库的最基本要求</strong><br>第二范式：在1NF的基础之上,要求所有非主键字段完全依赖主键，不能产生部分依赖<br>第三范式：在2NF的基础之上,所有非主键字段和主键字段之间不能产生传递依赖<br>| 级别  | 概念              |<br>|——-|————————-|<br>| 1NF | 属性不可分           |<br>| 2NF | 非主键属性完全依赖于主键属性 |<br>| 3NF | 非主键属性无传递依赖      |</p>
<blockquote>
<p>为了保证数据库的ACID特性，我们必须尽量按照其要求的范式进行设计，关系型数据库中的表都是存储一个格式化的数据结构。每个元组字段的组成都是一样，即使不是每个元组都需要所有的字段，但数据库会为每个元组分配所有的字段，这样的结构可以便于标语表之间进行链接等操作，但从另一个角度来说它也是关系型数据库性能瓶颈的一个因素。</p>
</blockquote>
<h2 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h2><p>索引是对数据库表中一个或多个列的值进行排序的数据结构，以协助<strong>快速查询、更新数据库表中数据</strong>。索引的实现通常使用B树及其变种B+树。<br>为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/索引1.png">
</center>

<p>上图显示了一种索引方式。左边是数据库中的数据表，有col1和col2两个字段，一共有15条记录；右边是以col2列为索引列的B_TREE索引，每个节点包含索引的键值和对应数据表地址的指针，这样就可以都过B_TREE在 $O(log n)$ 的时间复杂度内获取相应的数据，这样明显地加快了检索的速度。</p>
<h3 id="索引的底层实现原理和优化"><a href="#索引的底层实现原理和优化" class="headerlink" title="索引的底层实现原理和优化"></a>索引的底层实现原理和优化</h3><p>在数据结构中，我们最为常见的搜索结构就是二叉搜索树和AVL树(高度平衡的二叉搜索树，为了提高二叉搜索树的效率，减少树的平均搜索长度)了。然而，无论二叉搜索树还是AVL树，当数据量比较大时，都会由于树的深度过大而造成I/O读写过于频繁，进而导致查询效率低下，因此对于索引而言，多叉树结构成为不二选择。特别地，B树的各种操作能使B树保持较低的高度，从而保证高效的查找效率。</p>
<p>由于B树的高检索效率，B树主要应用在文件系统和数据库中，对于存储在硬盘上的大型数据库文件，可以极大程度减少访问硬盘次数，大幅度提高数据检索效率。<br>可以对B+树进行两种查找运算：一种是从最小关键字起顺序查找，另一种是从根节点开始，进行随机查找。</p>
<h3 id="为什么说B-树比B树更适合实际应用中操作系统的文件索引和数据库索引"><a href="#为什么说B-树比B树更适合实际应用中操作系统的文件索引和数据库索引" class="headerlink" title="为什么说B+树比B树更适合实际应用中操作系统的文件索引和数据库索引"></a>为什么说B+树比B树更适合实际应用中操作系统的文件索引和数据库索引</h3><p><font color="#dd0000">B+tree的磁盘读写代价更低</font>:B+tree的内部结点并没有指向关键字具体信息的指针，因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了；</p>
<p><font color="#dd0000">B+tree的查询效率更加稳定</font>：由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，所以，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；</p>
<p><font color="#dd0000">数据库索引采用B+树而不是B树的主要原因</font>：B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低。</p>
<h3 id="文件索引和数据库索引为什么使用B-树"><a href="#文件索引和数据库索引为什么使用B-树" class="headerlink" title="文件索引和数据库索引为什么使用B+树"></a>文件索引和数据库索引为什么使用B+树</h3><p>文件与数据库都是需要较大的存储，也就是说，它们都不可能全部存储在内存中，故需要存储到磁盘上。而所谓索引，则为了数据的快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，因此B+树相比B树更为合适。数据库系统巧妙利用了局部性原理与磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，而红黑树这种结构，高度明显要深的多，并且由于逻辑上很近的节点(父子)物理上可能很远，无法利用局部性。最重要的是，B+树还有一个最大的好处：方便扫库。B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持，这是数据库选用B+树的最主要原因。</p>
<h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><p>1.<font color="#dd0000">大大加快数据的检索速度</font>,这也是创建索引的最主要的原因；<br>2.加速表和表之间的连接；<br>3.在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间；<br>4.通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；</p>
<h3 id="索引的缺点"><a href="#索引的缺点" class="headerlink" title="索引的缺点"></a>索引的缺点</h3><p>1.时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；<br>2.空间方面：索引需要占物理空间。</p>
<h3 id="创建索引时需要注意什么"><a href="#创建索引时需要注意什么" class="headerlink" title="创建索引时需要注意什么"></a>创建索引时需要注意什么</h3><p><font color="#dd0000">非空字段</font>：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</p>
<p><font color="#dd0000">取值离散大的字段</font>：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</p>
<p><font color="#dd0000">索引字段越小越好</font>：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</p>
<h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p>普通索引和唯一性索引：索引列的值的唯一性</p>
<p>单个索引和复合索引：索引列所包含的列数</p>
<p>聚集索引与非聚集索引：聚集索引按照数据的物理存储进行划分的。对于一堆记录来说，使用聚集索引就是对这堆记录进行堆划分，即主要描述的是物理上的存储。正是因为这种划分方法，导致聚集索引必须是唯一的。聚集索引可以帮助把很大的范围，迅速减小范围。但是查找该记录，就要从这个小范围中Scan了；而非聚集索引是把一个很大的范围，转换成一个小的地图，然后你需要在这个小地图中找你要寻找的信息的位置，最后通过这个位置，再去找你所需要的记录。</p>
<blockquote>
<p>主键是一种特殊的唯一性索引，其可以是聚集索引，也可以是非聚集索引。</p>
</blockquote>
<h2 id="主键、自增主键、主键索引与唯一索引"><a href="#主键、自增主键、主键索引与唯一索引" class="headerlink" title="主键、自增主键、主键索引与唯一索引"></a>主键、自增主键、主键索引与唯一索引</h2><p>主键：指字段<strong>唯一、不为空值</strong>的列；</p>
<p>主键索引：指的就是主键，主键是索引的一种，是唯一索引的特殊类型。创建主键的时候，数据库默认会为主键创建一个唯一索引；</p>
<p>自增主键：字段类型为数字、自增、并且是主键；</p>
<p>唯一索引：索引列的值必须唯一，但允许有空值。<font color="#dd0000">主键是唯一索引，这样说没错；但反过来说，唯一索引也是主键就错误了，因为唯一索引允许空值，主键不允许有空值，所以不能说唯一索引也是主键。</font></p>
<h2 id="主键和索引的区别"><a href="#主键和索引的区别" class="headerlink" title="主键和索引的区别"></a>主键和索引的区别</h2><p>1:主键是为了标识数据库记录唯一性,不允许记录重复,且键值不能为空,主键也是一个特殊索引。<br>2:数据表中只允许有一个主键,但是可以有多个索引。<br>3.使用主键会数据库会自动创建主索引,也可以在非主键上创建索引,方便查询效率。<br>4:索引可以提高查询速度,它就相当于字典的目录,可以通过它很快查询到想要的结果,而不需要进行全表扫描。<br>5:主键索引外索引的值可以为空。<br>6:主键也可以由多个字段组成,组成复合主键,同时主键肯定也是唯一索引。<br>7:唯一索引则表示该索引值唯一,可以由一个或几个字段组成,一个表可以有多个唯一索引。</p>
<h2 id="关系型数据库和非关系型数据库"><a href="#关系型数据库和非关系型数据库" class="headerlink" title="关系型数据库和非关系型数据库"></a>关系型数据库和非关系型数据库</h2><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><p>关系型数据库，是指采用了关系模型来组织数据的数据库。简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>1、容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；<br>2、使用方便：通用的SQL语言使得操作关系型数据库非常方便；<br>3、易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；<br>4、支持SQL，可用于复杂的查询。<br>5、支持事务</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>1、为了维护一致性所付出的巨大代价就是其读写性能比较差；<br>2、固定的表结构；<br>3、不支持高并发读写需求；<br>4、不支持海量数据的高效率读写</p>
<blockquote>
<p>对网站来说，关系型数据库的很多特性不再需要了<br>必须强调的是，数据的持久存储，尤其是海量数据的持久存储，还是需要关系数据库这员老将。</p>
</blockquote>
<h3 id="非关系数据库"><a href="#非关系数据库" class="headerlink" title="非关系数据库"></a>非关系数据库</h3><p>使用键值对存储数据；分布式。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>1、无需经过sql层的解析，读写性能很高<br>2、基于键值对，数据没有耦合性，容易扩展<br>3、存储数据的格式：nosql的存储格式是key,value形式</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>1、不提供sql支持</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><h5 id="列式数据库"><a href="#列式数据库" class="headerlink" title="列式数据库"></a>列式数据库</h5><p>传统关系型数据库是按照行来存储数据库，称为“行式数据库”。列式数据库是按照列来存储数据，主要适合于批量数据处理和即时查询。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/列式数据库.webp">
</center>

<blockquote>
<p>常见的列式数据库有HBase、BigTable</p>
</blockquote>
<p>特性：高效的储存空间利用率、查询效率高、适合做聚合操作、适合大量的数据而不是小数据</p>
<h5 id="K-V数据库"><a href="#K-V数据库" class="headerlink" title="K-V数据库"></a>K-V数据库</h5><p>指的是使用键值(key-value)存储的数据库，其数据按照键值对的形式进行组织、索引和存储。<br>KV 存储非常适合不涉及过多数据关系业务关系的数据，同时能有效减少读写磁盘的次数，比 SQL 数据库存储拥有更好的读写性能，能够解决关系型数据库无法存储数据结构的问题。</p>
<blockquote>
<p>常见 K-V数据库:Redis、Cassandra、LevelDB</p>
</blockquote>
<p>特性：</p>
<ul>
<li>性能极高：Redis能支持超过10W的TPS</li>
<li>丰富的数据类型： Redis支持包括String，Hash，List，Set，Sorted Set，Bitmap和hyperloglog</li>
<li>丰富的特性：Redis还支持 publish/subscribe, 通知, key 过期等等特性</li>
</ul>
<h5 id="文档数据库"><a href="#文档数据库" class="headerlink" title="文档数据库"></a>文档数据库</h5><p>文档数据库（也称为文档型数据库）是旨在将半结构化数据存储为文档的一种数据库。文档数据库通常以 JSON 或 XML 格式存储数据。<br>由于文档数据库的no-schema特性，可以存储和读取任意数据。</p>
<blockquote>
<p>常见文档数据库:MongoDB、CouchDB</p>
</blockquote>
<h2 id="基本的增删查改SQL语句"><a href="#基本的增删查改SQL语句" class="headerlink" title="基本的增删查改SQL语句"></a>基本的增删查改SQL语句</h2><h3 id="插入数据insert"><a href="#插入数据insert" class="headerlink" title="插入数据insert"></a>插入数据insert</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">向表中制定字段添加数据：</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表 (字段名<span class="number">1</span>，字段名<span class="number">2.</span>.....) <span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2.</span>.....);</span><br><span class="line">向表中所有字段添加数据：</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表  <span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2.</span>.....)；</span><br></pre></td></tr></table></figure>
<h3 id="修改数据-update"><a href="#修改数据-update" class="headerlink" title="修改数据 update"></a>修改数据 update</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修改数据：</span><br><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段名<span class="number">1</span>=值<span class="number">1</span>，字段名<span class="number">2</span>=值<span class="number">2</span>；</span><br><span class="line">带条件的修改数据：</span><br><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段名<span class="number">1</span>=值<span class="number">1</span>，字段名<span class="number">2</span>=值<span class="number">2</span> <span class="keyword">where</span> 条件；</span><br></pre></td></tr></table></figure>
<h3 id="删除数据delete"><a href="#删除数据delete" class="headerlink" title="删除数据delete"></a>删除数据delete</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">带条件的删除语句：</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件]；</span><br></pre></td></tr></table></figure>
<blockquote>
<p>delete from 表名；和truncate table 表名；的区别:<br>从删除方式来说delete是一条一条的删除记录，不会去清空auto_increment记录数。而truncate则是直接将表删除重新建一个表，auto-increment将会被清空没有记录。<br>从事物方面来说delete删除的数据在一个事物内还能够找回，而truncate删除的数据是找不回来的。</p>
</blockquote>
<h3 id="查询数据-select"><a href="#查询数据-select" class="headerlink" title="查询数据 select"></a>查询数据 select</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查询语句的基本语法：</span><br><span class="line"><span class="keyword">select</span> [<span class="keyword">distinct</span>] * 或者 字段名<span class="number">1</span>，字段名<span class="number">2</span> <span class="keyword">from</span> 表 [<span class="keyword">where</span> 条件];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>distinct这个关键字在你使用的时候需要注意一下，当你查询的字段值只有一个的时候它会去掉这一个字段中 所有相同的数据如果你要是查询的是多个字段那么它会根据你的这两个字段来进行查询除非是这两个字段中的数据同时与其他的数据相同才会去除重复的。</p>
</blockquote>
<h2 id="参考文档-2"><a href="#参考文档-2" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://blog.csdn.net/qq_22222499/article/details/79060495" target="_blank" rel="noopener">数据库常见面试题</a><br><a href="https://cloud.tencent.com/developer/article/1450773" target="_blank" rel="noopener">脏读、不可重复读、幻读和MVCC</a><br><a href="https://blog.csdn.net/justloveyou_/article/details/78308460" target="_blank" rel="noopener">数据库</a><br><a href="https://blog.csdn.net/kennyrose/article/details/7532032" target="_blank" rel="noopener">数据库索引</a><br><a href="https://juejin.im/post/5b6d62ddf265da0f491bd200" target="_blank" rel="noopener">NoSQL 还是 SQL</a><br><a href="https://blog.csdn.net/oChangWen/article/details/53423301" target="_blank" rel="noopener">关系型数据库</a><br><a href="https://juejin.im/post/5b3dd6efe51d451991548579" target="_blank" rel="noopener">数据库增删查改</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/10/Golang%E5%9F%BA%E7%A1%80/" rel="prev" title="Golang基础">
      <i class="fa fa-chevron-left"></i> Golang基础
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/" rel="next" title="树-原理篇">
      树-原理篇 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#计算机网络"><span class="nav-number">1.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#三次握手"><span class="nav-number">1.1.</span> <span class="nav-text">三次握手</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么TCP链接需要三次握手，两次不可以么"><span class="nav-number">1.1.1.</span> <span class="nav-text">为什么TCP链接需要三次握手，两次不可以么</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四次挥手"><span class="nav-number">1.2.</span> <span class="nav-text">四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么客户端最后还要等待2-MSL"><span class="nav-number">1.2.1.</span> <span class="nav-text">为什么客户端最后还要等待2*MSL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如果已经建立了连接，但是客户端突然出现故障了怎么办"><span class="nav-number">1.2.2.</span> <span class="nav-text">如果已经建立了连接，但是客户端突然出现故障了怎么办</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Get与POST的区别"><span class="nav-number">1.3.</span> <span class="nav-text">Get与POST的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP的拥塞控制"><span class="nav-number">1.4.</span> <span class="nav-text">TCP的拥塞控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从输入网址到获得页面的过程"><span class="nav-number">1.5.</span> <span class="nav-text">从输入网址到获得页面的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IP地址分为哪几类"><span class="nav-number">1.6.</span> <span class="nav-text">IP地址分为哪几类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#保留地址"><span class="nav-number">1.6.1.</span> <span class="nav-text">保留地址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARP协议的工作过程"><span class="nav-number">1.7.</span> <span class="nav-text">ARP协议的工作过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见状态码"><span class="nav-number">1.8.</span> <span class="nav-text">常见状态码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单说一下你了解的端口及对应的服务"><span class="nav-number">1.9.</span> <span class="nav-text">简单说一下你了解的端口及对应的服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP与UDP区别"><span class="nav-number">1.10.</span> <span class="nav-text">TCP与UDP区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTPS和HTTP的区别"><span class="nav-number">1.11.</span> <span class="nav-text">HTTPS和HTTP的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Session、Cookie-与-Application"><span class="nav-number">1.12.</span> <span class="nav-text">Session、Cookie 与 Application</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Cookie"><span class="nav-number">1.12.1.</span> <span class="nav-text">Cookie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Session"><span class="nav-number">1.12.2.</span> <span class="nav-text">Session</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Session-与-Cookie-的对比"><span class="nav-number">1.12.3.</span> <span class="nav-text">Session 与 Cookie 的对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Application"><span class="nav-number">1.12.4.</span> <span class="nav-text">Application</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文档"><span class="nav-number">1.13.</span> <span class="nav-text">参考文档</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#操作系统"><span class="nav-number">2.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#并发与并行区别"><span class="nav-number">2.1.</span> <span class="nav-text">并发与并行区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多道程序设计"><span class="nav-number">2.1.1.</span> <span class="nav-text">多道程序设计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程和线程"><span class="nav-number">2.2.</span> <span class="nav-text">进程和线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程"><span class="nav-number">2.2.1.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程类型"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">进程类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的三个组成部分"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">进程的三个组成部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的三个状态"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">进程的三个状态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程"><span class="nav-number">2.2.2.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程概念"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">线程概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程状态"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">线程状态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程与程序区别"><span class="nav-number">2.2.3.</span> <span class="nav-text">进程与程序区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程与进程联系"><span class="nav-number">2.2.4.</span> <span class="nav-text">线程与进程联系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程与进程区别"><span class="nav-number">2.2.5.</span> <span class="nav-text">线程与进程区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程间的通信的几种方式"><span class="nav-number">2.3.</span> <span class="nav-text">进程间的通信的几种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#管道-pipe"><span class="nav-number">2.3.1.</span> <span class="nav-text">管道(pipe)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量-semophore"><span class="nav-number">2.3.2.</span> <span class="nav-text">信号量(semophore)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息队列-message-queue"><span class="nav-number">2.3.3.</span> <span class="nav-text">消息队列(message queue)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号（signal）"><span class="nav-number">2.3.4.</span> <span class="nav-text">信号（signal）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享内存-shared-memory"><span class="nav-number">2.3.5.</span> <span class="nav-text">共享内存(shared memory)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#套接字-socket"><span class="nav-number">2.3.6.</span> <span class="nav-text">套接字(socket)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程同步机制"><span class="nav-number">2.4.</span> <span class="nav-text">线程同步机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#互斥锁（mutex）"><span class="nav-number">2.4.1.</span> <span class="nav-text">互斥锁（mutex）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件变量（cond）"><span class="nav-number">2.4.2.</span> <span class="nav-text">条件变量（cond）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量-Semphare"><span class="nav-number">2.4.3.</span> <span class="nav-text">信号量(Semphare)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读写锁"><span class="nav-number">2.4.4.</span> <span class="nav-text">读写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自旋锁"><span class="nav-number">2.4.5.</span> <span class="nav-text">自旋锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁"><span class="nav-number">2.5.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁定义"><span class="nav-number">2.5.1.</span> <span class="nav-text">死锁定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#产生死锁的四个必要条件"><span class="nav-number">2.5.2.</span> <span class="nav-text">产生死锁的四个必要条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#产生死锁原因"><span class="nav-number">2.5.3.</span> <span class="nav-text">产生死锁原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解除死锁"><span class="nav-number">2.5.4.</span> <span class="nav-text">解除死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁预防"><span class="nav-number">2.5.4.1.</span> <span class="nav-text">死锁预防</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁避免"><span class="nav-number">2.5.4.2.</span> <span class="nav-text">死锁避免</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存管理"><span class="nav-number">2.6.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分页"><span class="nav-number">2.6.1.</span> <span class="nav-text">分页</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分段"><span class="nav-number">2.6.2.</span> <span class="nav-text">分段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分页与分段区别"><span class="nav-number">2.6.3.</span> <span class="nav-text">分页与分段区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#段页式存储管理"><span class="nav-number">2.6.4.</span> <span class="nav-text">段页式存储管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统中进程调度策略"><span class="nav-number">2.7.</span> <span class="nav-text">操作系统中进程调度策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FCFS-先来先服务"><span class="nav-number">2.7.1.</span> <span class="nav-text">FCFS(先来先服务)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SJF-最短作业优先调度算法"><span class="nav-number">2.7.2.</span> <span class="nav-text">SJF(最短作业优先调度算法)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高响应比优先法-HRRN"><span class="nav-number">2.7.3.</span> <span class="nav-text">高响应比优先法(HRRN)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高优先级调度算法"><span class="nav-number">2.7.4.</span> <span class="nav-text">高优先级调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时间片轮转算法（RR，Round-Robin）"><span class="nav-number">2.7.5.</span> <span class="nav-text">时间片轮转算法（RR，Round-Robin）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多级队列调度算法"><span class="nav-number">2.7.6.</span> <span class="nav-text">多级队列调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多级反馈队列调度算法"><span class="nav-number">2.7.7.</span> <span class="nav-text">多级反馈队列调度算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚拟内存"><span class="nav-number">2.8.</span> <span class="nav-text">虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本思想"><span class="nav-number">2.8.1.</span> <span class="nav-text">基本思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#页面置换算法"><span class="nav-number">2.8.2.</span> <span class="nav-text">页面置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最佳置换算法（OPT）"><span class="nav-number">2.8.2.1.</span> <span class="nav-text">最佳置换算法（OPT）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#先进先出置换算法（FIFO）"><span class="nav-number">2.8.2.2.</span> <span class="nav-text">先进先出置换算法（FIFO）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最近最久未使用算法（LRU，Least-recently-use）"><span class="nav-number">2.8.2.3.</span> <span class="nav-text">最近最久未使用算法（LRU，Least recently use）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最近最少使用置换算法（LFU，Least-frequently-use）"><span class="nav-number">2.8.2.4.</span> <span class="nav-text">最近最少使用置换算法（LFU，Least frequently use）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#颠簸"><span class="nav-number">2.8.3.</span> <span class="nav-text">颠簸</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生产者-消费者模型"><span class="nav-number">2.9.</span> <span class="nav-text">生产者-消费者模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发编程问题"><span class="nav-number">2.10.</span> <span class="nav-text">并发编程问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#上下文切换问题"><span class="nav-number">2.10.1.</span> <span class="nav-text">上下文切换问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁问题"><span class="nav-number">2.10.2.</span> <span class="nav-text">死锁问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#资源限制问题"><span class="nav-number">2.10.3.</span> <span class="nav-text">资源限制问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#乐观锁和悲观锁"><span class="nav-number">2.11.</span> <span class="nav-text">乐观锁和悲观锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#乐观锁"><span class="nav-number">2.11.1.</span> <span class="nav-text">乐观锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#版本号机制"><span class="nav-number">2.11.1.1.</span> <span class="nav-text">版本号机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS算法"><span class="nav-number">2.11.1.2.</span> <span class="nav-text">CAS算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CAS缺点"><span class="nav-number">2.11.1.2.1.</span> <span class="nav-text">CAS缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#悲观锁"><span class="nav-number">2.11.2.</span> <span class="nav-text">悲观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两种锁使用场景"><span class="nav-number">2.11.3.</span> <span class="nav-text">两种锁使用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文档-1"><span class="nav-number">2.12.</span> <span class="nav-text">参考文档</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据库"><span class="nav-number">3.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#事务四大特性-ACID"><span class="nav-number">3.1.</span> <span class="nav-text">事务四大特性(ACID)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库隔离级别"><span class="nav-number">3.2.</span> <span class="nav-text">数据库隔离级别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库三范式"><span class="nav-number">3.3.</span> <span class="nav-text">数据库三范式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库索引"><span class="nav-number">3.4.</span> <span class="nav-text">数据库索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#索引的底层实现原理和优化"><span class="nav-number">3.4.1.</span> <span class="nav-text">索引的底层实现原理和优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么说B-树比B树更适合实际应用中操作系统的文件索引和数据库索引"><span class="nav-number">3.4.2.</span> <span class="nav-text">为什么说B+树比B树更适合实际应用中操作系统的文件索引和数据库索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件索引和数据库索引为什么使用B-树"><span class="nav-number">3.4.3.</span> <span class="nav-text">文件索引和数据库索引为什么使用B+树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引的优点"><span class="nav-number">3.4.4.</span> <span class="nav-text">索引的优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引的缺点"><span class="nav-number">3.4.5.</span> <span class="nav-text">索引的缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建索引时需要注意什么"><span class="nav-number">3.4.6.</span> <span class="nav-text">创建索引时需要注意什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引的分类"><span class="nav-number">3.4.7.</span> <span class="nav-text">索引的分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主键、自增主键、主键索引与唯一索引"><span class="nav-number">3.5.</span> <span class="nav-text">主键、自增主键、主键索引与唯一索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主键和索引的区别"><span class="nav-number">3.6.</span> <span class="nav-text">主键和索引的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关系型数据库和非关系型数据库"><span class="nav-number">3.7.</span> <span class="nav-text">关系型数据库和非关系型数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关系型数据库"><span class="nav-number">3.7.1.</span> <span class="nav-text">关系型数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优点"><span class="nav-number">3.7.1.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点"><span class="nav-number">3.7.1.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非关系数据库"><span class="nav-number">3.7.2.</span> <span class="nav-text">非关系数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优点-1"><span class="nav-number">3.7.2.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点-1"><span class="nav-number">3.7.2.2.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分类"><span class="nav-number">3.7.2.3.</span> <span class="nav-text">分类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#列式数据库"><span class="nav-number">3.7.2.3.1.</span> <span class="nav-text">列式数据库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#K-V数据库"><span class="nav-number">3.7.2.3.2.</span> <span class="nav-text">K-V数据库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#文档数据库"><span class="nav-number">3.7.2.3.3.</span> <span class="nav-text">文档数据库</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本的增删查改SQL语句"><span class="nav-number">3.8.</span> <span class="nav-text">基本的增删查改SQL语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#插入数据insert"><span class="nav-number">3.8.1.</span> <span class="nav-text">插入数据insert</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修改数据-update"><span class="nav-number">3.8.2.</span> <span class="nav-text">修改数据 update</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除数据delete"><span class="nav-number">3.8.3.</span> <span class="nav-text">删除数据delete</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查询数据-select"><span class="nav-number">3.8.4.</span> <span class="nav-text">查询数据 select</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文档-2"><span class="nav-number">3.9.</span> <span class="nav-text">参考文档</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="chen"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">chen</p>
  <div class="site-description" itemprop="description">冰冻三尺 非一日之寒</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/747948341@qq.com" title="E-Mail → 747948341@qq.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chen</span>
</div>



        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
