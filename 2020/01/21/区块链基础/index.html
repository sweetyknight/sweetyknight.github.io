<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="基础的区块链知识，如共识算法等。">
<meta property="og:type" content="article">
<meta property="og:title" content="区块链基础">
<meta property="og:url" content="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="群芳髓">
<meta property="og:description" content="基础的区块链知识，如共识算法等。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%E6%BC%94%E8%BF%9B.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/paxos%E8%83%8C%E6%99%AF.png">
<meta property="og:image" content="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/paxos%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5.png">
<meta property="og:image" content="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/%E4%B8%80%E4%B8%AAAcceptor.png">
<meta property="og:image" content="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/%E5%A4%9A%E4%B8%AAAcceptor.png">
<meta property="og:image" content="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/1.png">
<meta property="og:image" content="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/2.png">
<meta property="og:image" content="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/3.png">
<meta property="og:image" content="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/paxos%E7%AE%97%E6%B3%95%E6%BC%94%E7%A4%BA.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Learner%E5%AD%A6%E4%B9%A0%E8%A2%AB%E9%80%89%E5%AE%9A%E7%9A%84value.png">
<meta property="og:image" content="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81Paxos%E7%AE%97%E6%B3%95%E7%9A%84%E6%B4%BB%E6%80%A7.png">
<meta property="og:image" content="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Raft1.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Raft%E7%AE%97%E6%B3%95%E8%A7%92%E8%89%B2%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Raft2.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Leader%E9%80%89%E4%B8%BE%E8%BF%87%E7%A8%8B.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Raft%E6%97%A5%E5%BF%97%E5%90%8C%E6%AD%A5%E8%BF%87%E7%A8%8B.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Raft%E6%97%A5%E5%BF%97.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Leader%E5%92%8CFollowers%E4%B8%8A%E6%97%A5%E5%BF%97%E4%B8%8D%E4%B8%80%E8%87%B4.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/%E5%B7%B2%E6%8F%90%E4%BA%A4%E7%9A%84%E6%97%A5%E5%BF%97%E8%A2%AB%E8%A6%86%E7%9B%96.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/%E6%88%90%E5%91%98%E5%8F%98%E6%9B%B4%E7%9A%84%E6%9F%90%E4%B8%80%E6%97%B6%E5%88%BBCold%E5%92%8CCnew%E4%B8%AD%E5%90%8C%E6%97%B6%E5%AD%98%E5%9C%A8%E4%B8%A4%E4%B8%AA%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E5%A4%9A%E6%95%B0%E6%B4%BE.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Raft%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%88%90%E5%91%98%E5%8F%98%E6%9B%B4.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Raft%E4%B8%8EMulti-Paxos%E4%B8%AD%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%A6%82%E5%BF%B5.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Raft%E4%B8%8EMulti-Paxos%E7%9A%84%E4%B8%8D%E5%90%8C.jpg">
<meta property="article:published_time" content="2020-01-21T14:22:20.000Z">
<meta property="article:modified_time" content="2020-01-24T13:13:29.443Z">
<meta property="article:author" content="chen">
<meta property="article:tag" content="区块链 面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95.jpg">

<link rel="canonical" href="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>区块链基础 | 群芳髓</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">群芳髓</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="chen">
      <meta itemprop="description" content="冰冻三尺 非一日之寒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="群芳髓">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          区块链基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-21 22:22:20" itemprop="dateCreated datePublished" datetime="2020-01-21T22:22:20+08:00">2020-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-24 21:13:29" itemprop="dateModified" datetime="2020-01-24T21:13:29+08:00">2020-01-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/" itemprop="url" rel="index">
                    <span itemprop="name">区块链</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>基础的区块链知识，如共识算法等。</p>
<a id="more"></a>
<p>区块链本质上是一个去中心化的系统。<br>分布式记帐技术（也就是区块链技术）沿袭了复式簿记法的精神，每一笔交易必定有输入(Inputs)与输出(Outputs)，输入是“钱从哪里来”，输出则是“钱流向哪里”。<br>在分布式帐本的世界里，每一笔交易要被验证，记录到区块中，最重要的核心过程就是达成网络中各节点(node)的“共识”。</p>
<h1 id="什么是共识机制"><a href="#什么是共识机制" class="headerlink" title="什么是共识机制"></a>什么是共识机制</h1><p>区块链可以看作一本记录所有交易的分布式公开帐簿，区块链网络中的每个参与者都把它看作一本所有权的权威记录。</p>
<blockquote>
<p>公开账本历史数据不可篡改，那么公开账本每个新区块由谁来负责写入？</p>
</blockquote>
<p>因此需要一种机制来保证区块链中的每一区块只能由一个节点来负责写入，如何选出写入账本数据的节点，这就是共识机制。让平等的参与者按照某种秩序达成一致意见。<br>打个比方，现在有一个中心数据库，所有客户端都能来查询，每个客户端权限都是一样，但如果要对数据库进行增删改，不好意思，每次只允许一个客户端来操作，通俗讲，就是让数据库串行修改数据库。通过一个算法机制来抉择出操作的客户端。这个机制就是共识机制，<strong>所谓的共识就是在人人平等的社会里需要大家共同形成一个共识，产生一个操作者、临时决策者，代表大家来进行中心化的操作，大家按照这个共识来维持去中心化的网络世界。</strong></p>
<h1 id="主流共识算法"><a href="#主流共识算法" class="headerlink" title="主流共识算法"></a>主流共识算法</h1><center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/共识算法.jpg">
</center>

<h2 id="共识算法概述"><a href="#共识算法概述" class="headerlink" title="共识算法概述"></a>共识算法概述</h2><p>共识算法是区块链网络的重要元素，因为它维持着分布式系统的完整性和安全性。<br>区块链中的共识算法说到底还是分布式系统中最重要的一致性问题：</p>
<blockquote>
<p>在分布式网络中如何保证数据一致性。</p>
</blockquote>
<p>说到一致性问题，就不得不提大名鼎鼎的拜占庭将军问题。</p>
<blockquote>
<p>Leslie Lamport 证明，当叛变者不超过1/3时，存在有效的算法，不论叛变者如何折腾，忠诚的将军们总能达成一致的结果。如果叛变者过多，则无法保证一定能达到一致性。</p>
</blockquote>
<p>对于拜占庭将军问题分两种情况：<br><strong>非拜占庭错误</strong>:针对非拜占庭错误的情况，一般包括 Paxos、Raft 及其变种。<br>分布式数据库设计一般都是基于paxos或raft算法。<br><strong>能容忍拜占庭错误</strong>:对于要能容忍拜占庭错误的情况，一般包括 PBFT(实用拜占庭容错算法)系列、PoW 系列算法等。<br>从概率角度，PBFT 系列算法是确定的，一旦达成共识就不可逆转；而 PoW 系列算法则是不确定的，随着时间推移，被推翻的概率越来越小。</p>
<h2 id="实用拜占庭容错PBFT"><a href="#实用拜占庭容错PBFT" class="headerlink" title="实用拜占庭容错PBFT"></a>实用拜占庭容错PBFT</h2><p>PBFT算法要求至少要4个参与者,核心理论是 $n&gt;=3f+1$<br>n是系统中的总节点数，f是允许出现故障的节点数。换句话说，如果这个系统允许出现f个故障，那么这个系统必须包括n个节点，才能解决故障。</p>
<p>PBFT 模型下，有一个节点会被当做主节点，而其他节点都是备份节点。系统内的所有节点都会相互通信，最终目标是大家能以少数服从多数的原则达成数据的共识。如果主节点出现明显的撒谎迹象，其他的节点也可以联合起来更换主节点。</p>
<p>每一个共识过程分下面这几步：</p>
<ol>
<li>取一个副本作为主节点，其他的副本作为备份；</li>
<li>用户端向主节点发送使用服务操作的请求；</li>
<li>主节点通过广播将请求发送给其他副本；</li>
<li>所有副本执行请求并将结果发回用户端；</li>
<li>用户端需要等待F+1个不同副本节点发回相同的结果，作为整个操作的最终结果。</li>
</ol>
<p>从第五步也可以看出，只要客户端能保证多数人认可了一个相同的结果，这个结果就是最终的共识了。</p>
<h2 id="工作量证明PoW"><a href="#工作量证明PoW" class="headerlink" title="工作量证明PoW"></a>工作量证明PoW</h2><p>在工作量证明中，一个成员要想成为领导者并选择下一个要添加到区块链的区块，他们必须要找到解决一个特定数学问题的方法。<br>工作量证明最常用的技术原理是散列函数。由于输入散列函数h()的任意值n，会对应到一个h(n)结果，而n只要变动一个比特，就会引起雪崩效应，所以几乎无法从h(n)反推回n，因此借由指定查找h(n)的特征，让用户进行大量的穷举运算，就可以达成工作量证明。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1.架构简明扼要、有效可靠。<br>2.由于要获得多数节点承认，那攻击者必须投入超过总体一半的运算量（51%攻击），才能保证篡改结果。这使得攻击成功的成本变得非常高昂，难以实现。<br>3.某种程度上是公平的，你投入越多的算力，你获得打包权的几率也等比增加。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>1.非常浪费能源。投入在一种加密货币上的能源，可能会超过一个小型国家的总使用量。<br>3.由于加密货币在世界上已成为一种投资标的，所以有技术者或富有者，可以开发出由ASIC组成的特制计算机，垄断算力。这与加密货币的去中心化思想背道而驰。</p>
<p>也因此，后期开发的加密货币有针对抗ASIC的算法设计，例如以太坊采用的Ethash（Dagger-Hashimoto）算法。<br>后期开发的加密货币陆续使用了POS机制（例如以太坊）或DPOS机制（例如比特股﹑EOS）。</p>
<blockquote>
<p>工作量证明让矿工们需使用大量的能量，从而促进了矿池的产生。<strong>这让区块链变得更加中心化，而不是去中心化</strong>。</p>
</blockquote>
<h2 id="权益证明PoS"><a href="#权益证明PoS" class="headerlink" title="权益证明PoS"></a>权益证明PoS</h2><p>PoS 是试图解决在 PoW 中大量资源被浪费的缺点。恶意参与者将存在保证金被罚没的风险，即损失经济利益。<br>股权证明去掉了工作量证明对于能源和计算能力的要求，并用股权替代。股权就是在一段时间内成员愿意锁定的货币数量。作为回报，他们有和他们的股权成比例的机会成为下一个领导者，并选择下一个区块。现在有一些币种只用股权证明如Nxt和Blackcoin。</p>
<p>权益证明通过选举的形式，其中任意节点被随机选择来验证下一个区块。<br>在这里有一些小的术语区别，权益证明中没有矿工，但是有验证者(validator)。并不让人们”挖(mine)”新区块 而是”铸造(mint)” 或”制造(forge)”新区块。</p>
<p>验证者并不是被完全随机选择的，要成为验证者，<strong>节点需要在网络中存入一定数量的货币作为权益</strong>，可以将这理解为保证金。<br>权益的份额大小决定了被选为验证者的几率，从而得以创建下一个区块，这是线性相关的。假设Bob在网络中存入100美元 Alice存入1000美元，那么Alice比Bob有高于10倍的几率选为验证者。</p>
<p>因为这偏袒有钱的一方，似乎不太公平，但事实上这比起工作量证明更公平。</p>
<p>如果一个节点被选出来验证下一个区块，他将检查当中所有的交易是否有效。如果一切没问题，节点则通过该区块，区块将加到区块链中。作为奖励，该节点可获得当中每个交易费。<br>如果验证者通过了欺诈性交易，他们将失去一部分权益。只要权益高于验证者所获得的交易费，我们就可以信任他们能够很好的完成工作。否则，他们失去的钱比能获得的还多。</p>
<h2 id="授权股权证明机制DPOS"><a href="#授权股权证明机制DPOS" class="headerlink" title="授权股权证明机制DPOS"></a>授权股权证明机制DPOS</h2><p>(Delegated Proof of Stake),PoS 的改进算法，DPOS与POS原理相似。与POS的主要区别在于节点选举若干代理，由代理人验证和记账。<br>相较于PoW每10分钟产生一个区块，DPoS每3秒钟即可产生一个区块。</p>
<h1 id="Raft和Paxos"><a href="#Raft和Paxos" class="headerlink" title="Raft和Paxos"></a>Raft和Paxos</h1><p>算法演进:</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/算法演进.jpg">
</center>


<h2 id="paxos算法"><a href="#paxos算法" class="headerlink" title="paxos算法"></a>paxos算法</h2><blockquote>
<p>Paxos算法是基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一。</p>
</blockquote>
<p>Paxos算法运行在允许宕机故障的异步系统中，不要求可靠的消息传递，可容忍消息丢失、延迟、乱序以及重复。它利用大多数 (Majority) 机制保证了2F+1的容错能力，即2F+1个节点的系统最多允许F个节点同时出现故障</p>
<h3 id="问题产生的背景"><a href="#问题产生的背景" class="headerlink" title="问题产生的背景"></a>问题产生的背景</h3><p>在常见的分布式系统中，总会发生诸如<strong>机器宕机</strong>或<strong>网络异常</strong>（包括消息的延迟、丢失、重复、乱序，还有网络分区）等情况。Paxos算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对某个数据的值达成一致，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。</p>
<blockquote>
<p>注：这里某个数据的值并不只是狭义上的某个数，它可以是一条日志，也可以是一条命令（command）。。。根据应用场景不同，某个数据的值有不同的含义。</p>
</blockquote>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/paxos背景.png">
</center>

<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>一个或多个提议进程 (Proposer) 可以发起提案 (Proposal)，最终要达成一致的value就在提案里。系统中的多数派同时认可该提案，即达成了一致。最多只针对一个确定的提案达成一致。</p>
<p>Paxos将系统中的角色分为提议者 (Proposer)，决策者 (Acceptor)，和最终决策学习者 (Learner):</p>
<ul>
<li>Proposer: 提出提案 (Proposal)。Proposal信息包括提案编号 (Proposal ID) 和提议的值 (Value)。</li>
<li>Acceptor：参与决策，回应Proposers的提案。收到Proposal后可以接受提案，若Proposal获得多数Acceptors的接受，则称该Proposal被批准。</li>
<li>Learner：不参与决策，从Proposers/Acceptors学习最新达成一致的提案（Value）。</li>
</ul>
<p>在具体的实现中，<strong>一个进程可能同时充当多种角色</strong>。比如一个进程可能既是Proposer又是Acceptor又是Learner。</p>
<p>注：</p>
<ul>
<li><strong>暂且</strong>认为 <strong>『提案=value』</strong>，即提案只包含value。在我们接下来的推导过程中会发现如果提案只包含value，会有问题，于是我们再对提案重新设计。</li>
<li><strong>暂且</strong> 认为 <strong>『Proposer可以直接提出提案』</strong>。在我们接下来的推导过程中会发现如果Proposer直接提出提案会有问题，需要增加一个学习提案的过程。</li>
</ul>
<p>回到刚刚说的『对某个数据的值达成一致』，指的是Proposer、Acceptor、Learner都认为同一个value被选定（chosen）。那么，Proposer、Acceptor、Learner分别在什么情况下才能认为某个value被选定呢？</p>
<ul>
<li>Proposer：只要Proposer发的提案被Acceptor接受（刚开始先认为只需要一个Acceptor接受即可，在推导过程中会发现需要半数以上的Acceptor同意才行），Proposer就认为该提案里的value被选定了。</li>
<li>Acceptor：只要Acceptor接受了某个提案，Acceptor就任务该提案里的value被选定了。</li>
<li>Learner：Acceptor告诉Learner哪个value被选定，Learner就认为那个value被选定。<center>
  <img style="border-radius: 0.3125em;
  box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/paxos相关概念.png">
</center>

</li>
</ul>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>假设有一组可以<strong>提出（propose）value</strong>（value在提案Proposal里）的<strong>进程集合</strong>。一个一致性算法需要保证提出的这么多value中， <strong>只有一个</strong> value被选定（chosen）。如果没有value被提出，就不应该有value被选定。如果一个value被选定，那么所有进程都应该能学习（learn）到这个被选定的value。对于一致性算法， <strong>安全性（safaty）</strong> 要求如下：</p>
<ul>
<li>只有被提出的value才能被选定。</li>
<li>只有一个value被选定，并且如果某个进程认为某个value被选定了，那么这个value必须是真的被选定的那个。</li>
</ul>
<p>我们不去精确地定义其 <strong>活性（liveness）</strong> 要求。我们的目标是保证 <strong>最终有一个提出的value被选定</strong> 。当一个value被选定后，进程最终也能学习到这个value。</p>
<blockquote>
<p>Paxos的目标：保证最终有一个value会被选定，当value被选定后，进程最终也能获取到被选定的value。</p>
</blockquote>
<p>假设不同角色之间可以通过发送消息来进行通信，那么：</p>
<ul>
<li>每个角色以任意的速度执行，可能因出错而停止，也可能会重启。一个value被选定后，所有的角色可能失败然后重启，除非那些失败后重启的角色能记录某些信息，否则等他们重启后无法确定被选定的值。</li>
<li>消息在传递过程中可能出现任意时长的延迟，可能会重复，也可能丢失。但是消息不会被损坏，即消息内容不会被篡改（拜占庭将军问题）。</li>
</ul>
<h3 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h3><h4 id="最简单的方案——只有一个Acceptor"><a href="#最简单的方案——只有一个Acceptor" class="headerlink" title="最简单的方案——只有一个Acceptor"></a>最简单的方案——只有一个Acceptor</h4><p>假设只有一个Acceptor（可以有多个Proposer），只要Acceptor接受它收到的第一个提案，则该提案被选定，该提案里的value就是被选定的value。这样就保证只有一个value会被选定。<br>但是，如果这个唯一的Acceptor宕机了，那么整个系统就无法工作了！</p>
<p>因此，必须要有多个Acceptor！</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/一个Acceptor.png">
</center>

<h4 id="多个Acceptor"><a href="#多个Acceptor" class="headerlink" title="多个Acceptor"></a>多个Acceptor</h4><p>多个Acceptor的情况如下图。那么，如何保证在多个Proposer和多个Acceptor的情况下选定一个value呢？</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/多个Acceptor.png">
</center>

<p>下面开始寻找解决方案。</p>
<p>如果我们希望即使只有一个Proposer提出了一个value，该value也最终被选定。<br>那么，就得到下面的约束：</p>
<blockquote>
<p>P1：一个Acceptor必须接受它收到的第一个提案。</p>
</blockquote>
<p>但是，这又会引出另一个问题：如果每个Proposer分别提出不同的value，发给不同的Acceptor。根据P1，Acceptor分别接受自己收到的value，就导致不同的value被选定。出现了不一致。如下图：</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/1.png">
</center>

<p>刚刚是因为『一个提案只要被一个Acceptor接受，则该提案的value就被选定了』才导致了出现上面不一致的问题。因此，我们需要加一个规定：</p>
<blockquote>
<p>规定：一个提案被选定需要被半数以上的Acceptor接受</p>
</blockquote>
<p>这个规定又暗示了：『一个Acceptor必须能够接受不止一个提案！』不然可能导致最终没有value被选定。比如上图的情况。v1、v2、v3都没有被选定，因为它们都只被一个Acceptor的接受。</p>
<p>最开始讲的『<strong>提案=value</strong>』已经不能满足需求了，于是重新设计提案，给每个提案加上一个提案编号，表示提案被提出的顺序。令『<strong>提案=提案编号+value</strong>』。</p>
<p>虽然允许多个提案被选定，但必须保证所有被选定的提案都具有相同的value值。否则又会出现不一致。<br>于是有了下面的约束：</p>
<blockquote>
<p>P2：如果某个value为v的提案被选定了，那么每个编号更高的被选定提案的value必须也是v。</p>
</blockquote>
<p>一个提案只有被Acceptor接受才可能被选定，因此我们可以把P2约束改写成对Acceptor接受的提案的约束P2a。</p>
<blockquote>
<p>P2a：如果某个value为v的提案被选定了，那么每个编号更高的被Acceptor接受的提案的value必须也是v。</p>
</blockquote>
<p>只要满足了P2a，就能满足P2。</p>
<p>但是，考虑如下的情况：假设总的有5个Acceptor。Proposer2提出[M1,V1]的提案，Acceptor2~5（半数以上）均接受了该提案，于是对于Acceptor2~5和Proposer2来讲，它们都认为V1被选定。Acceptor1刚刚从宕机状态恢复过来（之前Acceptor1没有收到过任何提案），此时Proposer1向Acceptor1发送了[M2,V2]的提案（V2≠V1且M2&gt;M1），对于Acceptor1来讲，这是它收到的第一个提案。根据P1（一个Acceptor必须接受它收到的第一个提案。）,Acceptor1必须接受该提案！同时Acceptor1认为V2被选定。这就出现了两个问题：</p>
<ol>
<li>Acceptor1认为V2被选定，Acceptor2~5和Proposer2认为V1被选定。出现了不一致。</li>
<li>V1被选定了，但是编号更高的被Acceptor1接受的提案[M2,V2]的value为V2，且V2≠V1。这就跟P2a（如果某个value为v的提案被选定了，那么每个编号更高的被Acceptor接受的提案的value必须也是v）矛盾了。</li>
</ol>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/2.png">
</center>

<p>所以我们要对P2a约束进行强化！<br>P2a是对Acceptor接受的提案约束，但其实提案是Proposer提出来的，所有我们可以对Proposer提出的提案进行约束。得到P2b：</p>
<blockquote>
<p>P2b：如果某个value为v的提案被选定了，那么之后任何Proposer提出的编号更高的提案的value必须也是v。</p>
</blockquote>
<p>由P2b可以推出P2a进而推出P2。</p>
<p>那么，如何确保在某个value为v的提案被选定后，Proposer提出的编号更高的提案的value都是v呢？<br>只要满足P2c即可：</p>
<blockquote>
<p>P2c：对于任意的N和V，如果提案[N, V]被提出，那么存在一个半数以上的Acceptor组成的集合S，满足以下两个条件中的任意一个：</p>
</blockquote>
<ul>
<li>S中每个Acceptor都没有接受过编号小于N的提案。</li>
<li>S中Acceptor接受过的最大编号的提案的value为V。</li>
</ul>
<h4 id="Acceptor生成提案"><a href="#Acceptor生成提案" class="headerlink" title="Acceptor生成提案"></a>Acceptor生成提案</h4><p>为了满足P2b，这里有个比较重要的思想：Proposer生成提案之前，应该先去『<strong>学习</strong>』已经被选定或者可能被选定的value，然后以该value作为自己提出的提案的value。如果没有value被选定，Proposer才可以自己决定value的值。这样才能达成一致。这个学习的阶段是通过一个『<strong>Prepare请求</strong>』实现的。</p>
<p>于是我们得到了如下的<strong>提案生成算法</strong>：</p>
<ol>
<li>Proposer选择一个<strong>新的提案编号N</strong>，然后向<strong>某个Acceptor集合</strong>（半数以上）发送请求，我们将该请求称为<strong>编号为N</strong>的<strong>Prepare请求</strong>。  要求该集合中的每个Acceptor做出如下响应（response）。<br>(a) 向Proposer承诺保证<strong>不再接受</strong>任何编号<strong>小于N的提案</strong>。<br>(b) 如果Acceptor已经接受过提案，那么就向Proposer响应<strong>已经接受过</strong>的编号小于N的<strong>最大编号的提案</strong>。</li>
<li>如果Proposer收到了<strong>半数以上</strong>的Acceptor的响应，那么它就可以生成编号为N，Value为V的 <strong>提案[N,V]</strong>。这里的V是所有的响应中<strong>编号最大的提案的Value</strong>。如果所有的响应中都没有提案，那 么此时V就可以由Proposer自己选择。<br>生成提案后，Proposer将该提案发送给<strong>半数以上</strong>的Acceptor集合，并期望这些Acceptor能接受该提案。我们称该请求为<strong>Accept请求</strong>。（注意：此时接受Accept请求的Acceptor集合不一定是之前响应Prepare请求的Acceptor集合）</li>
</ol>
<h4 id="Acceptor接受提案"><a href="#Acceptor接受提案" class="headerlink" title="Acceptor接受提案"></a>Acceptor接受提案</h4><p>Acceptor可以<strong>忽略任何请求</strong>（包括Prepare请求和Accept请求）而不用担心破坏算法的安全性。因此，我们这里要讨论的是什么时候Acceptor可以响应一个请求。</p>
<p>我们对Acceptor接受提案给出如下约束：</p>
<blockquote>
<p>P1a：一个Acceptor只要尚未响应过任何编号大于N的Prepare请求，那么他就可以接受这个编号为N的提案。</p>
</blockquote>
<p>如果Acceptor收到一个编号为N的Prepare请求，在此之前它已经响应过编号大于N的Prepare请求。根据P1a，该Acceptor不可能接受编号为N的提案。因此，该Acceptor可以忽略编号为N的Prepare请求。当然，也可以回复一个error，让Proposer尽早知道自己的提案不会被接受。</p>
<p>因此，一个Acceptor只需记住：</p>
<ol>
<li>已接受的编号最大的提案</li>
<li>已响应的请求的最大编号。</li>
</ol>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/3.png">
</center>

<h3 id="Paxos算法描述"><a href="#Paxos算法描述" class="headerlink" title="Paxos算法描述"></a>Paxos算法描述</h3><p>经过上面的推导，我们总结下Paxos算法的流程。<br>Paxos算法分为<strong>两个阶段</strong>。具体如下：</p>
<ul>
<li><p>阶段一：<br>(a) Proposer选择一个提<strong>案编号N</strong>，然后向<strong>半数以上</strong>的Acceptor发送编号为N的<strong>Prepare请求</strong>。<br>(b) 如果一个Acceptor收到一个编号为N的Prepare请求，且N大于该Acceptor已经响应过的所有Prepare请求的编号，那么它就会将它已经 <strong>接受过的编号最大的提案（如果有的话）</strong> 作为响应反馈给Proposer，同时该Acceptor承诺<strong>不再接受</strong>任何编号小于N的提案。</p>
</li>
<li><p>阶段二：<br>(a) 如果Proposer收到<strong>半数以上</strong>Acceptor对其发出的编号为N的Prepare请求的 <strong>响应</strong> ，那么它就会发送一个针对 <strong>[N,V]提案</strong> 的 <strong>Accept请求</strong> 给半数以上的Acceptor。注意：V就是收到的响应中编号最大的提案的value，如果响应中不包含任何提案，那么V就由Proposer <strong>自己决定</strong>。<br>(b) 如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor <strong>没有</strong> 对编号大于N的Prepare请求做出过响应，它就<strong>接受该提案</strong>。</p>
</li>
</ul>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/paxos算法演示.jpg">
</center>

<h3 id="Learner学习被选定的value"><a href="#Learner学习被选定的value" class="headerlink" title="Learner学习被选定的value"></a>Learner学习被选定的value</h3><p>Learner学习（获取）被选定的value有如下三种方案：</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Learner学习被选定的value.png">
</center>

<h3 id="如何保证Paxos算法的活性"><a href="#如何保证Paxos算法的活性" class="headerlink" title="如何保证Paxos算法的活性"></a>如何保证Paxos算法的活性</h3><center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/如何保证Paxos算法的活性.png">
</center>

<p>通过 <strong>选取主Proposer</strong> ，就可以保证Paxos算法的活性。至此，我们得到一个<strong>既能保证安全性，又能保证活性</strong>的分布式一致性算法——Paxos算法。</p>
<h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><blockquote>
<p>这个网站的动画做得很好 <a href="http://thesecretlivesofdata.com/raft/#home" target="_blank" rel="noopener">Raft</a></p>
</blockquote>
<h3 id="Raft算法概述"><a href="#Raft算法概述" class="headerlink" title="Raft算法概述"></a>Raft算法概述</h3><p>Raft实现了和Paxos相同的功能，它将一致性分解为多个子问题：Leader选举（Leader election）、日志同步（Log replication）、安全性（Safety）、日志压缩（Log compaction）、成员变更（Membership change）等。</p>
<p>Raft将系统中的角色分为领导者（Leader）、跟从者（Follower）和候选人（Candidate）：</p>
<ul>
<li>Leader：接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志。</li>
<li>Follower：接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志。</li>
<li>Candidate：Leader选举过程中的临时角色。</li>
</ul>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Raft1.jpg">
</center>

<p>Raft要求系统在任意时刻最多只有一个Leader，在网络分裂的情况下可能存在多个leader。正常工作期间只有Leader和Followers。</p>
<p>Raft算法角色状态转换如下：</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Raft算法角色状态转换.jpg">
</center>

<p>Follower只响应其他服务器的请求。如果Follower超时没有收到Leader的消息，它会成为一个Candidate并且开始一次Leader选举。收到大多数服务器投票的Candidate会成为新的Leader。Leader在宕机之前会一直保持Leader的状态。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Raft2.jpg">
</center>

<p>Raft算法将时间分为一个个的任期（term），每一个term的开始都是Leader选举。在成功选举Leader之后，Leader会在整个term内管理整个集群。如果Leader选举失败，该term就会因为没有Leader而结束。</p>
<h3 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h3><p>Raft 使用心跳（heartbeat）触发Leader选举。当服务器启动时，初始化为Follower。Leader向所有Followers周期性发送heartbeat。如果Follower在选举超时时间内没有收到Leader的heartbeat，就会等待一段随机的时间后发起一次Leader选举。</p>
<p>Follower将其当前term加一然后转换为Candidate。它首先给自己投票并且给集群中的其他服务器发送 RequestVote RPC （RPC细节参见八、Raft算法总结）。结果有以下三种情况：</p>
<ul>
<li>赢得了多数的选票，成功选举为Leader；</li>
<li>收到了Leader的消息，表示有其它服务器已经抢先当选了Leader；</li>
<li>没有服务器赢得多数的选票，Leader选举失败，等待选举时间超时后发起下一次选举。</li>
</ul>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Leader选举过程.jpg">
</center>

<p>选举出Leader后，Leader通过定期向所有Followers发送心跳信息维持其统治。若Follower一段时间未收到Leader的心跳则认为Leader可能已经挂了，再次发起Leader选举过程。<br>Raft保证选举出的Leader上一定具有最新的已提交的日志，这一点将在安全性中说明。</p>
<h3 id="日志同步"><a href="#日志同步" class="headerlink" title="日志同步"></a>日志同步</h3><p>Leader选出后，就开始接收客户端的请求。Leader把请求作为日志条目（Log entries）加入到它的日志中，然后并行的向其他服务器发起 AppendEntries RPC （RPC细节参见八、Raft算法总结）复制日志条目。当这条日志被复制到大多数服务器上，Leader将这条日志应用到它的状态机并向客户端返回执行结果。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Raft日志同步过程.jpg">
</center>

<p>某些Followers可能没有成功的复制日志，Leader会无限的重试 AppendEntries RPC直到所有的Followers最终存储了所有的日志条目。</p>
<p>日志由有序编号（log index）的日志条目组成。每个日志条目包含它被创建时的任期号（term），和用于状态机执行的命令。如果一个日志条目被复制到大多数服务器上，就被认为可以提交（commit）了。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Raft日志.jpg">
</center>

<p>Raft日志同步保证如下两点：</p>
<ul>
<li>如果不同日志中的两个条目有着相同的索引和任期号，则它们所存储的命令是相同的。</li>
<li>如果不同日志中的两个条目有着相同的索引和任期号，则它们之前的所有条目都是完全一样的。</li>
</ul>
<p>一般情况下，Leader和Followers的日志保持一致，因此 AppendEntries 一致性检查通常不会失败。然而，Leader崩溃可能会导致日志不一致：旧的Leader可能没有完全复制完日志中的所有条目。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Leader和Followers上日志不一致.jpg">
</center>

<p>上图阐述了一些Followers可能和新的Leader日志不同的情况。一个Follower可能会丢失掉Leader上的一些条目，也有可能包含一些Leader没有的条目，也有可能两者都会发生。丢失的或者多出来的条目可能会持续多个任期。</p>
<p>Leader通过强制Followers复制它的日志来处理日志的不一致，Followers上的不一致的日志会被Leader的日志覆盖。</p>
<p>Leader为了使Followers的日志同自己的一致，Leader需要找到Followers同它的日志一致的地方，然后覆盖Followers在该位置之后的条目。</p>
<p>Leader会从后往前试，每次AppendEntries失败后尝试前一个日志条目，直到成功找到每个Follower的日志一致位点，然后向后逐条覆盖Followers在该位置之后的条目。</p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>Raft增加了如下两条限制以保证安全性：</p>
<ul>
<li>拥有最新的已提交的log entry的Follower才有资格成为Leader。</li>
<li>Leader只能推进commit index来提交当前term的已经复制到大多数服务器上的日志，旧term日志的提交要等到提交当前term的日志来间接提交（log index 小于 commit index的日志被间接提交）。</li>
</ul>
<p>之所以要这样，是因为可能会出现已提交的日志又被覆盖的情况：</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/已提交的日志被覆盖.jpg">
</center>

<p>在阶段a，term为2，S1是Leader，且S1写入日志（term, index）为(2, 2)，并且日志被同步写入了S2；</p>
<p>在阶段b，S1离线，触发一次新的选举，此时S5被选为新的Leader，此时系统term为3，且写入了日志（term, index）为（3， 2）;</p>
<p>S5尚未将日志推送到Followers就离线了，进而触发了一次新的选举，而之前离线的S1经过重新上线后被选中变成Leader，此时系统term为4，此时S1会将自己的日志同步到Followers，按照上图就是将日志（2， 2）同步到了S3，而此时由于该日志已经被同步到了多数节点（S1, S2, S3），因此，此时日志（2，2）可以被提交了。；</p>
<p>在阶段d，S1又下线了，触发一次选主，而S5有可能被选为新的Leader（这是因为S5可以满足作为主的一切条件：1. term = 5 &gt; 4，2. 最新的日志为（3，2），比大多数节点（如S2/S3/S4的日志都新），然后S5会将自己的日志更新到Followers，于是S2、S3中已经被提交的日志（2，2）被截断了。</p>
<p>增加上述限制后，即使日志（2，2）已经被大多数节点（S1、S2、S3）确认了，但是它不能被提交，因为它是来自之前term（2）的日志，直到S1在当前term（4）产生的日志（4， 4）被大多数Followers确认，S1方可提交日志（4，4）这条日志，当然，根据Raft定义，（4，4）之前的所有日志也会被提交。此时即使S1再下线，重新选主时S5不可能成为Leader，因为它没有包含大多数节点已经拥有的日志（4，4）。</p>
<h3 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h3><p>在实际的系统中，不能让日志无限增长，否则系统重启时需要花很长的时间进行回放，从而影响可用性。Raft采用对整个系统进行snapshot来解决，snapshot之前的日志都可以丢弃。</p>
<p>每个副本独立的对自己的系统状态进行snapshot，并且只能对已经提交的日志记录进行snapshot。<br>当Leader要发给某个日志落后太多的Follower的log entry被丢弃，Leader会将snapshot发给Follower。或者当新加进一台机器时，也会发送snapshot给它。发送snapshot使用InstalledSnapshot RPC（RPC细节参见八、Raft算法总结）。</p>
<p>做snapshot既不要做的太频繁，否则消耗磁盘带宽， 也不要做的太不频繁，否则一旦节点重启需要回放大量日志，影响可用性。推荐当日志达到某个固定的大小做一次snapshot。</p>
<p>做一次snapshot可能耗时过长，会影响正常日志同步。可以通过使用copy-on-write技术避免snapshot过程影响正常日志同步。</p>
<h3 id="成员变更"><a href="#成员变更" class="headerlink" title="成员变更"></a>成员变更</h3><p>成员变更是在集群运行过程中副本发生变化，如增加/减少副本数、节点替换等。</p>
<p>成员变更也是一个分布式一致性问题，既所有服务器对新成员达成一致。但是成员变更又有其特殊性，因为在成员变更的一致性达成的过程中，参与投票的进程会发生变化。</p>
<p>如果将成员变更当成一般的一致性问题，直接向Leader发送成员变更请求，Leader复制成员变更日志，达成多数派之后提交，各服务器提交成员变更日志后从旧成员配置（Cold）切换到新成员配置（Cnew）。</p>
<p>因为各个服务器提交成员变更日志的时刻可能不同，造成各个服务器从旧成员配置（Cold）切换到新成员配置（Cnew）的时刻不同。</p>
<p>成员变更不能影响服务的可用性，但是成员变更过程的某一时刻，可能出现在Cold和Cnew中同时存在两个不相交的多数派，进而可能选出两个Leader，形成不同的决议，破坏安全性。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/成员变更的某一时刻Cold和Cnew中同时存在两个不相交的多数派.jpg">
</center>

<p>由于成员变更的这一特殊性，成员变更不能当成一般的一致性问题去解决。</p>
<p>为了解决这一问题，Raft提出了两阶段的成员变更方法。集群先从旧成员配置Cold切换到一个过渡成员配置，称为共同一致（joint consensus），共同一致是旧成员配置Cold和新成员配置Cnew的组合Cold U Cnew，一旦共同一致Cold U Cnew被提交，系统再切换到新成员配置Cnew。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Raft两阶段成员变更.jpg">
</center>

<p>Raft两阶段成员变更过程如下：</p>
<ol>
<li>Leader收到成员变更请求从Cold切成Cnew；</li>
<li>Leader在本地生成一个新的log entry，其内容是Cold∪Cnew，代表当前时刻新旧成员配置共存，写入本地日志，同时将该log entry复制至Cold∪Cnew中的所有副本。在此之后新的日志同步需要保证得到Cold和Cnew两个多数派的确认；</li>
<li>Follower收到Cold∪Cnew的log entry后更新本地日志，并且此时就以该配置作为自己的成员配置；</li>
<li>如果Cold和Cnew中的两个多数派确认了Cold U Cnew这条日志，Leader就提交这条log entry；</li>
<li>接下来Leader生成一条新的log entry，其内容是新成员配置Cnew，同样将该log entry写入本地日志，同时复制到Follower上；</li>
<li>Follower收到新成员配置Cnew后，将其写入日志，并且从此刻起，就以该配置作为自己的成员配置，并且如果发现自己不在Cnew这个成员配置中会自动退出；</li>
<li>Leader收到Cnew的多数派确认后，表示成员变更成功，后续的日志只要得到Cnew多数派确认即可。Leader给客户端回复成员变更执行成功。</li>
</ol>
<p>两阶段成员变更比较通用且容易理解，但是实现比较复杂，同时两阶段的变更协议也会在一定程度上影响变更过程中的服务可用性，因此我们期望增强成员变更的限制，以简化操作流程。</p>
<p>两阶段成员变更，之所以分为两个阶段，是因为对Cold与Cnew的关系没有做任何假设，为了避免Cold和Cnew各自形成不相交的多数派选出两个Leader，才引入了两阶段方案。</p>
<p>如果增强成员变更的限制，假设Cold与Cnew任意的多数派交集不为空，这两个成员配置就无法各自形成多数派，那么成员变更方案就可能简化为一阶段。</p>
<p>那么如何限制Cold与Cnew，使之任意的多数派交集不为空呢？方法就是每次成员变更只允许增加或删除一个成员。</p>
<p>可从数学上严格证明，<strong>只要每次只允许增加或删除一个成员，Cold与Cnew不可能形成两个不相交的多数派</strong>。</p>
<p>一阶段成员变更：</p>
<ul>
<li>成员变更限制每次只能增加或删除一个成员（如果要变更多个成员，连续变更多次）。</li>
<li>成员变更由Leader发起，Cnew得到多数派确认后，返回客户端成员变更成功。</li>
<li>一次成员变更成功前不允许开始下一次成员变更，因此新任Leader在开始提供服务前要将自己本地保存的最新成员配置重新投票形成多数派确认。</li>
<li>Leader只要开始同步新成员配置，即可开始使用新的成员配置进行日志同步。</li>
</ul>
<h2 id="Raft与Multi-Paxos的异同"><a href="#Raft与Multi-Paxos的异同" class="headerlink" title="Raft与Multi-Paxos的异同"></a>Raft与Multi-Paxos的异同</h2><p>Raft与Multi-Paxos都是基于领导者的一致性算法，乍一看有很多地方相同，下面总结一下Raft与Multi-Paxos的异同。</p>
<p>Raft与Multi-Paxos中相似的概念：</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Raft与Multi-Paxos中相似的概念.jpg">
</center>

<p>Raft与Multi-Paxos的不同：</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Raft与Multi-Paxos的不同.jpg">
</center>

<h1 id="公有链、联盟链、私有链"><a href="#公有链、联盟链、私有链" class="headerlink" title="公有链、联盟链、私有链"></a>公有链、联盟链、私有链</h1><p>按照部署模式可分为公共链、联盟链、私有链三种，对应的是去中心化分布式系统、部分去中心化分布式系统和弱中心分布式系统。</p>
<h2 id="公有链——对任何人开放，任何人都能参与"><a href="#公有链——对任何人开放，任何人都能参与" class="headerlink" title="公有链——对任何人开放，任何人都能参与"></a>公有链——对任何人开放，任何人都能参与</h2><p>公有链通常也称为非许可链（Permissionless Blockchain），任何人都可以参与区块链数据维护和读取，容易部署应用程序，完全去中心化不受任何机构控制。</p>
<p>公有链是真正意义上的完全去中心化的区块链，它通过密码学保证交易不可篡改，同时也利用密码学验证以及经济上的激励，在互为陌生的网络环境中建立共识，从而形成去中心化的信用机制。在公有链中的共识机制一般是工作量证明（PoW）和权益证明（PoS） 。</p>
<h2 id="联盟链——仅对联盟成员开放"><a href="#联盟链——仅对联盟成员开放" class="headerlink" title="联盟链——仅对联盟成员开放"></a>联盟链——仅对联盟成员开放</h2><p>联盟链是一种需要注册许可的区块链，这种区块链也称为许可链（Permissioned Blockchain）。联盟链仅限于联盟成员参与，联盟规模可以大到国与国之间，也可以是不同的机构企业之间。</p>
<p>区块链上的读写权限、参与记账权限按联盟规则来制定。整个网络由成员机构共同维护，网络接入一般通过成员机构的网关节点接入，共识过程由预先选好的节点控制。因此联盟链一般不采用工作量证明的挖矿机制，而是多采用权益证明（PoS）或PBFT（Practical Byzantine Fault Tolerant）、RAFT等共识算法。<br>和公有链最高每秒完成交易相比，联盟链交易速度更快且交易成本大幅降低。</p>
<h2 id="私有链——仅行业内部透明，不对外开放"><a href="#私有链——仅行业内部透明，不对外开放" class="headerlink" title="私有链——仅行业内部透明，不对外开放"></a>私有链——仅行业内部透明，不对外开放</h2><p>私有链，仅限于企业、国家机构或者单独个体使用，不完全能够解决信任问题，但是可以改善可审计性。常用于企业内部的数据库管理、审计等，政府的预算和执行，或者政府的行业统计数据等。他们彼此之间需要透明，但没必要对外公众透明。</p>
<p>私有链的价值主要是提供安全、可追溯、不可篡改、自动执行的运算平台，可以同时防范来自内部和外部对数据的安全攻击，这个在传统的系统是很难做到的。</p>
<h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><blockquote>
<p>这篇文章写的很好：<a href="http://www.gjermundbjaanes.com/understanding-ethereum-smart-contracts/" target="_blank" rel="noopener">Understanding Ethereum Smart Contracts</a></p>
</blockquote>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://zhuanlan.zhihu.com/p/34474913" target="_blank" rel="noopener">共识算法</a><br><a href="https://blog.csdn.net/ggq89/article/details/80188930" target="_blank" rel="noopener">股份授权证明(DPOS)概述</a><br><a href="https://zhuanlan.zhihu.com/p/32052223" target="_blank" rel="noopener">Raft算法详解</a><br><a href="https://www.cnblogs.com/linbingdong/p/6253479.html" target="_blank" rel="noopener">分布式系列文章——Paxos算法原理与推导</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE-%E9%9D%A2%E8%AF%95/" rel="tag"># 区块链 面试</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/21/Golang%E4%B8%AD%E9%98%B6/" rel="prev" title="Golang中阶">
      <i class="fa fa-chevron-left"></i> Golang中阶
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/22/hexo%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="next" title="hexo小技巧">
      hexo小技巧 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是共识机制"><span class="nav-number">1.</span> <span class="nav-text">什么是共识机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#主流共识算法"><span class="nav-number">2.</span> <span class="nav-text">主流共识算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#共识算法概述"><span class="nav-number">2.1.</span> <span class="nav-text">共识算法概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实用拜占庭容错PBFT"><span class="nav-number">2.2.</span> <span class="nav-text">实用拜占庭容错PBFT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工作量证明PoW"><span class="nav-number">2.3.</span> <span class="nav-text">工作量证明PoW</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#优点"><span class="nav-number">2.3.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点"><span class="nav-number">2.3.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#权益证明PoS"><span class="nav-number">2.4.</span> <span class="nav-text">权益证明PoS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#授权股权证明机制DPOS"><span class="nav-number">2.5.</span> <span class="nav-text">授权股权证明机制DPOS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Raft和Paxos"><span class="nav-number">3.</span> <span class="nav-text">Raft和Paxos</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#paxos算法"><span class="nav-number">3.1.</span> <span class="nav-text">paxos算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#问题产生的背景"><span class="nav-number">3.1.1.</span> <span class="nav-text">问题产生的背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相关概念"><span class="nav-number">3.1.2.</span> <span class="nav-text">相关概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题描述"><span class="nav-number">3.1.3.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#推导过程"><span class="nav-number">3.1.4.</span> <span class="nav-text">推导过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最简单的方案——只有一个Acceptor"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">最简单的方案——只有一个Acceptor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多个Acceptor"><span class="nav-number">3.1.4.2.</span> <span class="nav-text">多个Acceptor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Acceptor生成提案"><span class="nav-number">3.1.4.3.</span> <span class="nav-text">Acceptor生成提案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Acceptor接受提案"><span class="nav-number">3.1.4.4.</span> <span class="nav-text">Acceptor接受提案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Paxos算法描述"><span class="nav-number">3.1.5.</span> <span class="nav-text">Paxos算法描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Learner学习被选定的value"><span class="nav-number">3.1.6.</span> <span class="nav-text">Learner学习被选定的value</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何保证Paxos算法的活性"><span class="nav-number">3.1.7.</span> <span class="nav-text">如何保证Paxos算法的活性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Raft"><span class="nav-number">3.2.</span> <span class="nav-text">Raft</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Raft算法概述"><span class="nav-number">3.2.1.</span> <span class="nav-text">Raft算法概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leader选举"><span class="nav-number">3.2.2.</span> <span class="nav-text">Leader选举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#日志同步"><span class="nav-number">3.2.3.</span> <span class="nav-text">日志同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全性"><span class="nav-number">3.2.4.</span> <span class="nav-text">安全性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#日志压缩"><span class="nav-number">3.2.5.</span> <span class="nav-text">日志压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#成员变更"><span class="nav-number">3.2.6.</span> <span class="nav-text">成员变更</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Raft与Multi-Paxos的异同"><span class="nav-number">3.3.</span> <span class="nav-text">Raft与Multi-Paxos的异同</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#公有链、联盟链、私有链"><span class="nav-number">4.</span> <span class="nav-text">公有链、联盟链、私有链</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#公有链——对任何人开放，任何人都能参与"><span class="nav-number">4.1.</span> <span class="nav-text">公有链——对任何人开放，任何人都能参与</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#联盟链——仅对联盟成员开放"><span class="nav-number">4.2.</span> <span class="nav-text">联盟链——仅对联盟成员开放</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#私有链——仅行业内部透明，不对外开放"><span class="nav-number">4.3.</span> <span class="nav-text">私有链——仅行业内部透明，不对外开放</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#智能合约"><span class="nav-number">5.</span> <span class="nav-text">智能合约</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考文档"><span class="nav-number">6.</span> <span class="nav-text">参考文档</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="chen"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">chen</p>
  <div class="site-description" itemprop="description">冰冻三尺 非一日之寒</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/747948341@qq.com" title="E-Mail → 747948341@qq.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chen</span>
</div>



        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
