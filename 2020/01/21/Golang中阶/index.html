<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="基础篇学完，现在是中阶篇。">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang中阶">
<meta property="og:url" content="http://yoursite.com/2020/01/21/Golang%E4%B8%AD%E9%98%B6/index.html">
<meta property="og:site_name" content="群芳髓">
<meta property="og:description" content="基础篇学完，现在是中阶篇。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/01/21/Golang%E4%B8%AD%E9%98%B6/goroutine%E7%9A%84%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/21/Golang%E4%B8%AD%E9%98%B6/%E8%B0%83%E5%BA%A6%E5%AE%9E%E7%8E%B0.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/21/Golang%E4%B8%AD%E9%98%B6/%E9%98%BB%E5%A1%9E.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/21/Golang%E4%B8%AD%E9%98%B6/%E5%88%86%E9%85%8D%E4%B8%8D%E5%9D%87.jpg">
<meta property="og:image" content="http://yoursite.com/2020/01/21/Golang%E4%B8%AD%E9%98%B6/init.png">
<meta property="article:published_time" content="2020-01-21T14:05:43.000Z">
<meta property="article:modified_time" content="2020-01-28T15:19:47.346Z">
<meta property="article:author" content="chen">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/01/21/Golang%E4%B8%AD%E9%98%B6/goroutine%E7%9A%84%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B.jpg">

<link rel="canonical" href="http://yoursite.com/2020/01/21/Golang%E4%B8%AD%E9%98%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Golang中阶 | 群芳髓</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">群芳髓</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">觑眼底星辰轮转如旧</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/21/Golang%E4%B8%AD%E9%98%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="chen">
      <meta itemprop="description" content="大人，时代变了">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="群芳髓">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Golang中阶
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-21 22:05:43" itemprop="dateCreated datePublished" datetime="2020-01-21T22:05:43+08:00">2020-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-28 23:19:47" itemprop="dateModified" datetime="2020-01-28T23:19:47+08:00">2020-01-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index">
                    <span itemprop="name">go</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>基础篇学完，现在是中阶篇。</p>
<a id="more"></a>
<blockquote>
<p>参考文档：<br><a href="https://zhuanlan.zhihu.com/p/92634505" target="_blank" rel="noopener">闭包（closure）到底包了什么</a><br><a href="https://blog.csdn.net/netdxy/article/details/72054431" target="_blank" rel="noopener">Golang 闭包的理解</a><br><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/" target="_blank" rel="noopener">深入解析Go</a><br><a href="http://www.topgoer.com/" target="_blank" rel="noopener">Go语言</a><br><a href="https://www.cnblogs.com/wdliu/p/9272220.html" target="_blank" rel="noopener">golang核武器goroutine调度原理、channel详解</a></p>
</blockquote>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="闭包-closure"><a href="#闭包-closure" class="headerlink" title="闭包(closure)"></a>闭包(closure)</h2><p>Go里有函数类型的变量，这样，虽然不能在一个函数里直接声明另一个函数，但是可以在一个函数中声明一个匿名函数类型的变量，此时的匿名函数称为闭包（closure）。<br>闭包是以引用方式捕获外部变量，它不关心这些捕获的变量和常量是否超出了作用域，只要闭包还在使用它，那这些变量就还会存在。</p>
<p>先看一个demo：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">         i++</span><br><span class="line">         <span class="keyword">return</span> i</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数f返回了一个函数，返回的这个函数就是一个闭包。这个函数中本身是没有定义变量i的，而是引用了它所在的环境（函数f）中的变量i。<br>再看一下效果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c1 := f(<span class="number">0</span>)</span><br><span class="line">c2 := f(<span class="number">0</span>)</span><br><span class="line">c1() <span class="comment">// 打印 1</span></span><br><span class="line">c2() <span class="comment">// 打印 1</span></span><br></pre></td></tr></table></figure></p>
<p>c1 跟 c2 引用的是不同的环境，在调用 i++ 时修改的不是同一个 i，因此两次的输出都是 1。函数 f 每进入一次，就形成了一个新的环境，对应的闭包中，函数都是同一个函数，环境却是引用不同的环境。</p>
<h3 id="闭包详解"><a href="#闭包详解" class="headerlink" title="闭包详解"></a>闭包详解</h3><p><strong>闭包是函数和它所引用的环境组合而成的实体</strong>(即：闭包=函数+引用环境)。</p>
<h4 id="闭包结构体"><a href="#闭包结构体" class="headerlink" title="闭包结构体"></a>闭包结构体</h4><p>回到闭包的实现来，前面说过，闭包是函数和它所引用的环境。那么是不是可以表示为一个结构体呢：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Closure <span class="keyword">struct</span> &#123;</span><br><span class="line">    F <span class="function"><span class="keyword">func</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line">    i *<span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>事实上，Go在底层确实就是这样表示一个闭包的。</p>
<h4 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h4><p>函数b调用了a的变量，并且函数b作为了a的返回值，又将a()赋值给了变量c，此时的c就是一个闭包<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    b := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := a()</span><br><span class="line">    c() <span class="comment">//1</span></span><br><span class="line">    c() <span class="comment">//2</span></span><br><span class="line">    c() <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">    a() <span class="comment">//不会输出i，不打印任何值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExFunc</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sum := n</span><br><span class="line">    a := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 把匿名函数作为值赋给变量a (Go 不允许函数嵌套, 然而你可以利用匿名函数实现函数嵌套)</span></span><br><span class="line">        fmt.Println(sum + <span class="number">1</span>) <span class="comment">// 调用本函数外的变量</span></span><br><span class="line">    &#125; <span class="comment">// 这里没有()匿名函数不会马上执行</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">    <span class="comment">//  或者直接 return 匿名函数</span></span><br><span class="line">    <span class="comment">//  return func() &#123; //直接在返回处的匿名函数</span></span><br><span class="line">    <span class="comment">//    fmt.Println(sum + 1)</span></span><br><span class="line">    <span class="comment">//  &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myFunc := ExFunc(<span class="number">10</span>)</span><br><span class="line">    myFunc() <span class="comment">// 这里输出11</span></span><br><span class="line"></span><br><span class="line">    myAnotherFunc := ExFunc(<span class="number">20</span>)</span><br><span class="line">    myAnotherFunc() <span class="comment">// 这里输出21</span></span><br><span class="line"></span><br><span class="line">    myFunc()  <span class="comment">// 这里输出11</span></span><br><span class="line">    myAnotherFunc()  <span class="comment">// 这里输出21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例3："><a href="#例3：" class="headerlink" title="例3："></a>例3：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExFunc</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        n++ <span class="comment">// 这里对外部变量加 1</span></span><br><span class="line">        fmt.Println(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myFunc := ExFunc(<span class="number">10</span>)</span><br><span class="line">    myFunc() <span class="comment">// 这里输出 11</span></span><br><span class="line"></span><br><span class="line">    myAnotherFunc := ExFunc(<span class="number">20</span>)</span><br><span class="line">    myAnotherFunc() <span class="comment">// 这里输出 21</span></span><br><span class="line"></span><br><span class="line">    myFunc() <span class="comment">// 这里输出 12</span></span><br><span class="line">    myAnotherFunc() <span class="comment">// 这里输出 22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此得出以下两点<br>1.内函数对外函数 的变量的修改，是对变量的引用<br>2.变量被引用后，它所在的函数结束，这变量也不会马上被烧毁</p>
<p>闭包函数出现的条件：<br>1.被嵌套的函数引用到非本函数的外部变量，而且这外部变量不是“全局变量”;<br>2.嵌套的函数被独立了出来(被父函数返回或赋值 变成了独立的个体)，而被引用的变量所在的父函数已结束.</p>
<h3 id="延迟引用"><a href="#延迟引用" class="headerlink" title="延迟引用"></a>延迟引用</h3><p>闭包复制的是原对象指针，这就很容易解释延迟引用现象。</p>
<h3 id="for-range-和-for-区别"><a href="#for-range-和-for-区别" class="headerlink" title="for range 和 for 区别"></a>for range 和 for 区别</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dummy [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dummy); i++ &#123;</span><br><span class="line">	f = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p><code>i</code> 自加到 3 才会跳出循环，所以循环结束后 <code>i</code> 最后的值为 3。<br>用 <code>for range</code> 来实现这个例子就不会这样:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dummy [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> dummy &#123;</span><br><span class="line">	f = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>这是因为 <code>for range</code> 和 <code>for</code> 底层实现上的不同。</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>Go 语言中同时有函数和方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。<br>所有给定类型的方法属于该类型的方法集。语法格式如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recevier <span class="keyword">type</span>)</span> <span class="title">methodName</span><span class="params">(参数列表)</span><span class="params">(返回值列表)</span></span>&#123;</span><br><span class="line">  <span class="comment">//参数和返回值可以省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h2><p>下面定义一个结构体类型和该类型的一个方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Email <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">Notify</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%v:%v\n"</span>,u.Name,u.Email)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//值类型调用方法</span></span><br><span class="line">	u1 := User&#123;<span class="string">"go"</span>,<span class="string">"go@go.com"</span>&#125;</span><br><span class="line">	u1.Notify()  <span class="comment">//go:go@go.com</span></span><br><span class="line">	<span class="comment">//指针类型调用方法</span></span><br><span class="line">	u2 := User&#123;<span class="string">"hello"</span>,<span class="string">"hello@world.com"</span>&#125;</span><br><span class="line">	u3 := &amp;u2</span><br><span class="line">	u3.Notify()  <span class="comment">//hello:hello@world.com</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解释： 首先我们定义了一个叫做 User 的结构体类型，然后定义了一个该类型的方法叫做 Notify，该方法的接受者是一个 User 类型的值。要调用 Notify 方法我们需要一个 User 类型的值或者指针。</p>
<p>在这个例子中当我们使用指针时，Go 调整和解引用指针使得调用可以被执行。注意，当接受者不是一个指针时，该方法操作对应接受者的值的副本(意思就是即使你使用了指针调用函数，但是函数的接受者是值类型，所以函数内部操作还是对副本的操作，而不是指针操作。</p>
<p>我们修改 Notify 方法，让它的接受者使用指针类型：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span> <span class="title">Notify</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%v : %v \n"</span>, u.Name, u.Email)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果同上面一样</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：当接受者是指针时，即使用值类型调用那么函数内部也是对指针的操作。</p>
</blockquote>
<h3 id="receiver-T-和-T-的差别"><a href="#receiver-T-和-T-的差别" class="headerlink" title="receiver T 和 *T 的差别"></a>receiver T 和 *T 的差别</h3><p>值接收者声明的方法，调用时会使用这个值的一个副本去执行，而指针接收者在调用者会共享调用方法时接收者所指向的值，即可以修改指向的值。<br>在使用时，值类型的接收者也可以使用指针类型的调用，如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span> <span class="title">notify</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Printf(<span class="string">"sending User Email to %s&lt;%s&gt;\n"</span>, u.name, u.email)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tom := &amp;user&#123;<span class="string">"tom"</span>, <span class="string">"tom@email.com"</span>&#125;</span><br><span class="line">    tom.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为在Go的代码背后，已经对改类型进行了转换：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*tom).notify()</span><br></pre></td></tr></table></figure></p>
<p>所以有如下的对照关系:<br>| 方法接收者     | 实际可用类型    |<br>|—————-|—————-|<br>| (t T)   | T and *T |<br>| (t *T) | *T       |</p>
<p>因此在如下的代码执行时，会报错，因为<code>interface</code>声明了<code>notify</code>方法，而方法接收者使用的是指针类型，因而只有<code>*user</code>实现了<code>notify</code>方法，<code>user</code>并没有实现，所以<code>sendNotification</code>的参数应该是<code>&amp;u</code>，而不是<code>u</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> notifier <span class="keyword">interface</span> &#123;</span><br><span class="line">    notify()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span></span><br><span class="line">    email <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">notify</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Printf(<span class="string">"Sending user email to %s"</span>, u.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u := user&#123;<span class="string">"Bill"</span>, <span class="string">"bill@email.com"</span>&#125;</span><br><span class="line"></span><br><span class="line">    sendNotification(u)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendNotification</span><span class="params">(n notifier)</span></span> &#123;</span><br><span class="line">    n.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="普通函数与方法的区别"><a href="#普通函数与方法的区别" class="headerlink" title="普通函数与方法的区别"></a>普通函数与方法的区别</h3><p>1.对于普通函数，接收者为值类型时，不能将指针类型的数据直接传递，反之亦然。<br>2.对于方法（如struct的方法），接收者为值类型时，可以直接用指针类型的变量调用方法，反过来同样也可以。</p>
<h2 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h2><p>Golang匿名字段 ：可以像字段成员那样访问匿名字段方法，编译器负责查找。<br>go支持只提供类型而不写字段名的方式，也就是匿名字段，也称为嵌入字段。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	id <span class="keyword">int</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">	User</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *User)</span> <span class="title">ToString</span><span class="params">()</span> <span class="title">string</span></span>&#123; <span class="comment">// receiver = &amp;(Manager.User)</span></span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"User: %p, %v"</span>,self,self)</span><br><span class="line">	<span class="comment">//Sprintf返回一个格式化的字符串，并不输出。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := Manager&#123;User&#123;<span class="number">1</span>,<span class="string">"Tom"</span>&#125;&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"Manager: %p\n"</span>,&amp;m)</span><br><span class="line">	fmt.Println(m)</span><br><span class="line">	fmt.Printf(<span class="string">"%p\n"</span>,&amp;m)</span><br><span class="line">	fmt.Println(m.ToString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Manager: <span class="number">0xc00005c440</span></span><br><span class="line">&#123;&#123;<span class="number">1</span> Tom&#125;&#125;</span><br><span class="line"><span class="number">0xc00005c440</span></span><br><span class="line">User: <span class="number">0xc00005c440</span>, &amp;&#123;<span class="number">1</span> Tom&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果方法接收者名字是self、me、this类似的词，IDE会提示Receiver has generic name信息，所以接收者名字最好不要是这三个。</p>
</blockquote>
<p>通过匿名字段，可获得和继承类似的复用能力。依据编译器查找次序，只需在外层定义同名方法，就可以实现 “override”。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	id   <span class="keyword">int</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">	User</span><br><span class="line">	title <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *User)</span> <span class="title">ToString</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"User: %p, %v"</span>, self, self)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *Manager)</span> <span class="title">ToString</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"Manager: %p, %v"</span>, self, self)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := Manager&#123;User&#123;<span class="number">1</span>, <span class="string">"Tom"</span>&#125;, <span class="string">"Administrator"</span>&#125;</span><br><span class="line">	fmt.Println(m.ToString())</span><br><span class="line">	fmt.Println(m.User.ToString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Manager: <span class="number">0xc00005c330</span>, &amp;&#123;&#123;<span class="number">1</span> Tom&#125; Administrator&#125;</span><br><span class="line">User: <span class="number">0xc00005c330</span>, &amp;&#123;<span class="number">1</span> Tom&#125;</span><br></pre></td></tr></table></figure></p>
<p>指针类型匿名字段：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//人</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	sex  <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	*Person</span><br><span class="line">	id   <span class="keyword">int</span></span><br><span class="line">	addr <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := Student&#123;&amp;Person&#123;<span class="string">"5lmh"</span>, <span class="string">"man"</span>, <span class="number">18</span>&#125;, <span class="number">1</span>, <span class="string">"bj"</span>&#125;</span><br><span class="line">	fmt.Println(s1)  <span class="comment">//&#123;0xc000064330 1 bj&#125;</span></span><br><span class="line">	fmt.Println(s1.name)  <span class="comment">//5lmh</span></span><br><span class="line">	fmt.Println(s1.Person.name)  <span class="comment">//5lmh</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="方法集"><a href="#方法集" class="headerlink" title="方法集"></a>方法集</h2><p>在go语言中，每个类型都有与之关联的方法，把这个类型的所有方法称为类型的方法集，这会影响到接口实现规则。如下：</p>
<ul>
<li>类型 T 方法集包含全部 receiver T 方法。</li>
<li>类型 *T 方法集包含全部 receiver T + *T 方法。</li>
<li>如果类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。</li>
<li>如果类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T + *T 方法。</li>
<li>不管嵌入 T 或 *T，*S 方法集总是包含 T + *T 方法。</li>
</ul>
<p>Go 语言中内部类型方法集提升的规则：<br><strong>类型 T 方法集包含全部 receiver T 方法</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">"类型T方法集包括全部 receiver T 方法。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t1 := T&#123;<span class="number">1</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"t1 is %v\n"</span>,t1) <span class="comment">//t1 is &#123;1&#125;</span></span><br><span class="line">	t1.test()  <span class="comment">//类型T方法集包括全部 receiver T 方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>类型 *T 方法集包含全部 receiver T + *T 方法</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">testT</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">"类型*T方法集包括全部 receiver T 方法。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">testP</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">"类型*T方法集包括全部 receiver *T 方法。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t1 := T&#123;<span class="number">1</span>&#125;</span><br><span class="line">	t2 := &amp;t1</span><br><span class="line">	fmt.Printf(<span class="string">"t2 is : %v\n"</span>, t2)  <span class="comment">//t2 is : &amp;&#123;1&#125;</span></span><br><span class="line">	t2.testT()  <span class="comment">//类型*T方法集包括全部 receiver T 方法。</span></span><br><span class="line">	t2.testP()  <span class="comment">//类型*T方法集包括全部 receiver *T 方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>给定一个结构体类型 S 和一个命名为 T 的类型，方法提升像下面规定的这样被包含在结构体方法集中：<br><strong>如果类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。</strong></p>
<p>这条规则说的是当我们嵌入一个类型，嵌入类型的接受者为值类型的方法将被提升，可以被外部类型的值和指针调用。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">    T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">testT</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := S&#123;T&#123;<span class="number">1</span>&#125;&#125;</span><br><span class="line">    s2 := &amp;s1</span><br><span class="line">    fmt.Printf(<span class="string">"s1 is : %v\n"</span>, s1) <span class="comment">//s1 is : &#123;&#123;1&#125;&#125;</span></span><br><span class="line">    s1.testT()  <span class="comment">//如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。</span></span><br><span class="line">    fmt.Printf(<span class="string">"s2 is : %v\n"</span>, s2)  <span class="comment">//s2 is : &amp;&#123;&#123;1&#125;&#125;</span></span><br><span class="line">    s2.testT()  <span class="comment">//如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>如果类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T + *T 方法。</strong></p>
<p>这条规则说的是当我们嵌入一个类型的指针，嵌入类型的接受者为值类型或指针类型的方法将被提升，可以被外部类型的值或者指针调用。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">    T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">testT</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T 方法"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">testP</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 *T 方法"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := S&#123;T&#123;<span class="number">1</span>&#125;&#125;</span><br><span class="line">    s2 := &amp;s1</span><br><span class="line">    fmt.Printf(<span class="string">"s1 is : %v\n"</span>, s1)  <span class="comment">//s1 is : &#123;&#123;1&#125;&#125;</span></span><br><span class="line">    s1.testT()  <span class="comment">//如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T 方法</span></span><br><span class="line">    s1.testP()  <span class="comment">//如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 *T 方法</span></span><br><span class="line">    fmt.Printf(<span class="string">"s2 is : %v\n"</span>, s2)  <span class="comment">//s2 is : &amp;&#123;&#123;1&#125;&#125;</span></span><br><span class="line">    s2.testT()  <span class="comment">//如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T 方法</span></span><br><span class="line">    s2.testP()  <span class="comment">//如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 *T 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>Golang 表达式 ：根据调用者不同，方法分为两种表现形式:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance.method(args...) ---&gt; &lt;<span class="keyword">type</span>&gt;<span class="function">.<span class="keyword">func</span><span class="params">(instance, args...)</span></span></span><br></pre></td></tr></table></figure></p>
<p>前者称为 method value，后者 method expression。<br>两者都可像普通函数那样赋值和传参，区别在于 method value 绑定实例，而 method expression 则须显式传参。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	id <span class="keyword">int</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a * User)</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%p, %v\n"</span>,a,a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u := User&#123;<span class="number">1</span>,<span class="string">"Tom"</span>&#125;</span><br><span class="line">	u.Test()</span><br><span class="line"></span><br><span class="line">	mValue := u.Test</span><br><span class="line">	mValue() <span class="comment">// 隐式传递 receiver</span></span><br><span class="line"></span><br><span class="line">	mExpression := (*User).Test</span><br><span class="line">	mExpression(&amp;u) <span class="comment">// 显式传递 receiver</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xc00005c440</span>, &amp;&#123;<span class="number">1</span> Tom&#125;</span><br><span class="line"><span class="number">0xc00005c440</span>, &amp;&#123;<span class="number">1</span> Tom&#125;</span><br><span class="line"><span class="number">0xc00005c440</span>, &amp;&#123;<span class="number">1</span> Tom&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意，method value 会复制 receiver。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="keyword">int</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self User)</span> <span class="title">Test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(self)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u := User&#123;<span class="number">1</span>, <span class="string">"Tom"</span>&#125;</span><br><span class="line">    mValue := u.Test <span class="comment">// 立即复制 receiver，因为不是指针类型，不受后续修改影响。</span></span><br><span class="line">    u.id, u.name = <span class="number">2</span>, <span class="string">"Jack"</span></span><br><span class="line">    u.Test()  <span class="comment">//&#123;2 Jack&#125;</span></span><br><span class="line">    mValue()  <span class="comment">//&#123;1 Tom&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口(interface)"></a>接口(interface)</h1><p>接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。</p>
<h2 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h2><p>在Go语言中接口（interface）是一种类型，一种抽象的类型。</p>
<p>interface是一组method的集合，是duck-type programming的一种体现。接口做的事情就像是定义一个协议（规则），只要一台机器有洗衣服和甩干的功能，我就称它为洗衣机。不关心属性（数据），只关心行为（方法）。</p>
<p><strong>请牢记接口（interface）是一种类型</strong>。</p>
<h2 id="为什么要使用接口"><a href="#为什么要使用接口" class="headerlink" title="为什么要使用接口"></a>为什么要使用接口</h2><p>1.编写泛型编程<br>严格来说，在 Golang 中并不支持泛型编程(writing generic algorithm)。在 C++ 等高级语言中使用泛型编程非常的简单，所以泛型编程一直是 Golang 诟病最多的地方。但是使用 interface 我们可以实现泛型编程。</p>
<p>2.隐藏实施细节（隐藏具体实现）<br>隐藏具体实现，这个很好理解。某些我设计一个函数给你返回一个接口，那么你只能通过interface里面的方法来做一些操作，但是内部的具体实现是完全不知道的。<br>例如我们常用的上下文包，就是这样的，上下文最先由google提供，现在已经一部分了标准库，而且在上下文上下文的基础上增加了：cancelCtx，timerCtx，valueCtx。</p>
<p>3.提供拦截点</p>
<h2 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h2><p>接口命名习惯以 er 结尾。<br>每个接口由数个方法组成，接口的定义格式如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    方法名<span class="number">1</span>( 参数列表<span class="number">1</span> ) 返回值列表<span class="number">1</span></span><br><span class="line">    方法名<span class="number">2</span>( 参数列表<span class="number">2</span> ) 返回值列表<span class="number">2</span></span><br><span class="line">    …</span><br><span class="line"><span class="comment">//1.接口名：使用type将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer，有字符串功能的接口叫Stringer等。接口名最好要能突出该接口的类型含义。</span></span><br><span class="line"><span class="comment">//2.方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</span></span><br><span class="line"><span class="comment">//3.参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例如:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> writer <span class="keyword">interface</span>&#123;</span><br><span class="line">    Write([]<span class="keyword">byte</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个需要实现的方法列表。</p>
<h2 id="值接收者和指针接收者"><a href="#值接收者和指针接收者" class="headerlink" title="值接收者和指针接收者"></a>值接收者和指针接收者</h2><p>我们通过一个例子看一下使用值接收者实现接口和使用指针接收者实现接口的区别。</p>
<p>我们有一个Mover接口和一个dog结构体:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">    move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="值接收者实现接口"><a href="#值接收者实现接口" class="headerlink" title="值接收者实现接口"></a>值接收者实现接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"狗会动"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x Mover</span><br><span class="line">    <span class="keyword">var</span> wangcai = dog&#123;&#125; <span class="comment">// 旺财是dog类型</span></span><br><span class="line">    x = wangcai         <span class="comment">// x可以接收dog类型</span></span><br><span class="line">    <span class="keyword">var</span> fugui = &amp;dog&#123;&#125;  <span class="comment">// 富贵是*dog类型</span></span><br><span class="line">    x = fugui           <span class="comment">// x可以接收*dog类型</span></span><br><span class="line">    x.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中我们可以发现，使用值接收者实现接口之后，不管是dog结构体还是结构体指针<code>*dog</code>类型的变量都可以赋值给该接口变量。因为Go语言中有对指针类型变量求值的语法糖，dog指针fugui内部会自动求值<code>*fugui</code>。</p>
<h3 id="指针接收者实现接口"><a href="#指针接收者实现接口" class="headerlink" title="指针接收者实现接口"></a>指针接收者实现接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"狗会动"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x Mover</span><br><span class="line">    <span class="keyword">var</span> wangcai = dog&#123;&#125; <span class="comment">// 旺财是dog类型</span></span><br><span class="line">    x = wangcai         <span class="comment">// x不可以接收dog类型</span></span><br><span class="line">    <span class="keyword">var</span> fugui = &amp;dog&#123;&#125;  <span class="comment">// 富贵是*dog类型</span></span><br><span class="line">    x = fugui           <span class="comment">// x可以接收*dog类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时实现Mover接口的是<code>*dog</code>类型，所以不能给x传入dog类型的wangcai，此时x只能存储<code>*dog</code>类型的值。</p>
<h2 id="类型与接口的关系"><a href="#类型与接口的关系" class="headerlink" title="类型与接口的关系"></a>类型与接口的关系</h2><h3 id="一个类型实现多个接口"><a href="#一个类型实现多个接口" class="headerlink" title="一个类型实现多个接口"></a>一个类型实现多个接口</h3><p>一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。 例如，狗可以叫，也可以动。我们就分别定义Sayer接口和Mover接口，如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sayer 接口</span></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">	say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mover 接口</span></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">	move()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Sayer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%s会叫汪汪汪\n"</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Mover接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%s会动\n"</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x Sayer</span><br><span class="line">	<span class="keyword">var</span> y Mover</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a = dog&#123;name: <span class="string">"旺财"</span>&#125;</span><br><span class="line">	x = a</span><br><span class="line">	y = a</span><br><span class="line">	x.say()  <span class="comment">//旺财会叫汪汪汪</span></span><br><span class="line">	y.move()  <span class="comment">//旺财会动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="多个类型实现同一接口"><a href="#多个类型实现同一接口" class="headerlink" title="多个类型实现同一接口"></a>多个类型实现同一接口</h3><p>Go语言中不同的类型还可以实现同一接口，例如狗可以动，汽车也可以动，可以使用如下代码实现这个关系：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Mover 接口</span></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">	move()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> car <span class="keyword">struct</span> &#123;</span><br><span class="line">	brand <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dog类型实现Mover接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%s会动\n"</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//car类型实现Mover接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c car)</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%s也会跑\n"</span>,c.brand)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x Mover</span><br><span class="line">	<span class="keyword">var</span> a = dog&#123;name:<span class="string">"旺财"</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> b = car&#123;brand:<span class="string">"BMW"</span>&#125;</span><br><span class="line">	x = a</span><br><span class="line">	x.move()  <span class="comment">//旺财会动</span></span><br><span class="line">	fmt.Printf(<span class="string">"%v\n"</span>,x)  <span class="comment">//&#123;旺财&#125;</span></span><br><span class="line">	x = b</span><br><span class="line">	x.move()  <span class="comment">//BMW也会跑</span></span><br><span class="line">	fmt.Printf(<span class="string">"%v\n"</span>,x)  <span class="comment">//&#123;BMW&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>并且一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。</p>
<h2 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h2><p>接口与接口间可以通过嵌套创造出新的接口。<br>嵌套得到的接口的使用与普通接口一样，这里我们让cat实现animal接口：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sayer 接口</span></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">	say()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Mover 接口</span></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">	move()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口嵌套</span></span><br><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">	Sayer</span><br><span class="line">	Mover</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"喵喵喵"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"猫会动"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x animal</span><br><span class="line">	x = cat&#123;name: <span class="string">"花花"</span>&#125;</span><br><span class="line">	x.move()  <span class="comment">//猫会动</span></span><br><span class="line">	x.say()  <span class="comment">//喵喵喵</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h2><p>空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。<br>空接口类型的变量可以存储任意类型的变量。</p>
<h3 id="空接口的应用"><a href="#空接口的应用" class="headerlink" title="空接口的应用"></a>空接口的应用</h3><h4 id="空接口作为函数的参数"><a href="#空接口作为函数的参数" class="headerlink" title="空接口作为函数的参数"></a>空接口作为函数的参数</h4><p>使用空接口实现可以接收任意类型的函数参数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空接口作为函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, a, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="空接口作为map的值"><a href="#空接口作为map的值" class="headerlink" title="空接口作为map的值"></a>空接口作为map的值</h4><p>使用空接口实现可以保存任意值的字典。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空接口作为map值</span></span><br><span class="line"><span class="keyword">var</span> studentInfo = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">studentInfo[<span class="string">"name"</span>] = <span class="string">"李白"</span></span><br><span class="line">studentInfo[<span class="string">"age"</span>] = <span class="number">18</span></span><br><span class="line">studentInfo[<span class="string">"married"</span>] = <span class="literal">false</span></span><br><span class="line">fmt.Println(studentInfo)</span><br></pre></td></tr></table></figure></p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h2><p>Socket是BSD UNIX的进程通信机制，通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄。Socket可以理解为TCP/IP网络的API，它定义了许多函数或例程，程序员可以用它们来开发TCP/IP网络上的应用程序。电脑上运行的应用程序通常通过”套接字”向网络发出请求或者应答网络请求。</p>
<p>常用的Socket类型有两种： <strong>流式Socket</strong> 和 <strong>数据报式Socket</strong>，流式是一种面向连接的Socket，针对于面向连接的TCP服务应用，数据报式Socket是一种无连接的Socket，针对于无连接的UDP服务应用。</p>
<h3 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h3><h3 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h3><h3 id="TCP黏包"><a href="#TCP黏包" class="headerlink" title="TCP黏包"></a>TCP黏包</h3><h2 id="http编程"><a href="#http编程" class="headerlink" title="http编程"></a>http编程</h2><h2 id="WebSocket编程"><a href="#WebSocket编程" class="headerlink" title="WebSocket编程"></a>WebSocket编程</h2><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><p>goroutine 只是由官方实现的超级”线程池”。goroutine 奉行<strong>通过通信来共享内存</strong>，而不是共享内存来通信。</p>
<p>每个实例4~5KB的栈内存占用和由于实现机制而大幅减少的创建和销毁开销是go高并发的根本原因。</p>
<p>goroutine的本质是协程，是实现并行计算的核心。</p>
<h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><p>在java/c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换，这一切通常会耗费程序员大量的心智。那么能不能有一种机制，程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行呢？</p>
<p>Go语言中的goroutine就是这样一种机制，goroutine的概念类似于线程，但 goroutine是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它<strong>在语言层面已经内置了调度和上下文切换的机制</strong>。</p>
<p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个goroutine去执行这个函数就可以了，就是这么简单粗暴。</p>
<p>一个goroutine必定对应一个函数，可以创建多个goroutine去执行相同的函数。</p>
<h3 id="调度模型简介"><a href="#调度模型简介" class="headerlink" title="调度模型简介"></a>调度模型简介</h3><p>groutine能拥有强大的并发实现是通过GPM调度模型实现，下面就来解释下goroutine的调度模型。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/Golang%E4%B8%AD%E9%98%B6/goroutine的调度模型.jpg">
</center>

<p>Go的调度器内部有四个重要的结构：M，P，S，Sched，如上图所示（Sched未给出）<br>M:M代表内核级线程，一个M就是一个线程，goroutine就是跑在M之上的；M是一个很大的结构，里面维护小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等非常多的信息; M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；<br>G:代表一个goroutine，它有自己的栈，instruction pointer和其他信息（正在等待的channel等等），用于调度。<br>P:P全称是Processor，处理器，它的主要用途就是用来执行goroutine的，所以它也维护了一个goroutine队列，里面存储了所有需要它来执行的goroutine<br>Sched：代表调度器，它维护有存储M和G的队列以及调度器的一些状态信息等。</p>
<h3 id="调度实现"><a href="#调度实现" class="headerlink" title="调度实现"></a>调度实现</h3><center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/Golang%E4%B8%AD%E9%98%B6/调度实现.jpg">
</center>

<p>从上图中看，有2个物理线程M，每一个M都拥有一个处理器P，每一个也都有一个正在运行的goroutine。<br>P的数量可以通过GOMAXPROCS()来设置，它其实也就代表了真正的并发度，即有多少个goroutine可以同时运行。<br>图中灰色的那些goroutine并没有运行，而是出于ready的就绪态，正在等待被调度。P维护着这个队列（称之为runqueue），<br>Go语言里，启动一个goroutine很容易：go function 就行，所以每有一个go语句被执行，runqueue队列就在其末尾加入一个<br>goroutine，在下一个调度点，就从runqueue中取出（如何决定取哪个goroutine？）一个goroutine执行。</p>
<p>当一个OS线程M0陷入阻塞时（如下图)，P转而在运行M1，图中的M1可能是正被创建，或者从线程缓存中取出。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/Golang%E4%B8%AD%E9%98%B6/阻塞.jpg">
</center>

<p>当MO返回时，它必须尝试取得一个P来运行goroutine，一般情况下，它会从其他的OS线程那里拿一个P过来，<br>如果没有拿到的话，它就把goroutine放在一个global runqueue里，然后自己睡眠（放入线程缓存里）。所有的P也会周期性的检查global runqueue并运行其中的goroutine，否则global runqueue上的goroutine永远无法执行。</p>
<p>另一种情况是P所分配的任务G很快就执行完了（分配不均），这就导致了这个处理器P很忙，但是其他的P还有任务，此时如果global runqueue没有任务G了，那么P不得不从其他的P里拿一些G来执行。一般来说，如果P从其他的P那里要拿任务的话，一般就拿run queue的一半，这就确保了每个OS线程都能充分的使用，如下图：</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/Golang%E4%B8%AD%E9%98%B6/分配不均.jpg">
</center>


<h3 id="启动单个goroutine"><a href="#启动单个goroutine" class="headerlink" title="启动单个goroutine"></a>启动单个goroutine</h3><p>启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个go关键字。<br>举个例子如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Hello Goroutine!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	hello()</span><br><span class="line">	fmt.Println(<span class="string">"main goroutine done!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个示例中hello函数和下面的语句是串行的，执行的结果是打印完<code>Hello Goroutine!</code>后打印<code>main goroutine done!</code>。</p>
<p>接下来我们在调用hello函数前面加上关键字go，也就是启动一个goroutine去执行hello这个函数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">	fmt.Println(<span class="string">"main goroutine done!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一次的执行结果只打印了<code>main goroutine done!</code>，并没有打印<code>Hello Goroutine!</code>。为什么呢？</p>
<p>在程序启动时，Go程序就会为main()函数创建一个默认的goroutine。</p>
<p>当main()函数返回的时候该goroutine就结束了，所有在main()函数中启动的goroutine会一同结束，main函数所在的goroutine就像是权利的游戏中的夜王，其他的goroutine都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。</p>
<p>所以我们要想办法让main函数等一等hello函数，最简单粗暴的方式就是<code>time.Sleep</code>了。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">    fmt.Println(<span class="string">"main goroutine done!"</span>)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行上面的代码你会发现，这一次先打印<code>main goroutine done!</code>，然后紧接着打印<code>Hello Goroutine!</code>。</p>
<p>首先为什么会先打印<code>main goroutine done!</code>是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的goroutine是继续执行的。</p>
<h3 id="启动多个goroutine"><a href="#启动多个goroutine" class="headerlink" title="启动多个goroutine"></a>启动多个goroutine</h3><p>在Go语言中实现并发就是这样简单，我们还可以启动多个goroutine。让我们再来一个例子： （这里使用了sync.WaitGroup来实现goroutine的同步）<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()  <span class="comment">// goroutine结束就登记-1</span></span><br><span class="line">	fmt.Println(<span class="string">"Hello Goroutine!"</span>,i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>) <span class="comment">// 启动一个goroutine就登记+1</span></span><br><span class="line">		<span class="keyword">go</span> hello(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait() <span class="comment">// 等待所有登记的goroutine都结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个goroutine是并发执行的，而goroutine的调度是随机的。</p>
<p><strong>可增长的栈</strong>:<br>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个goroutine的栈在其生命周期开始时只有很小的栈（典型情况下2KB），goroutine的栈不是固定的，他可以按需增大和缩小，goroutine的栈大小限制可以达到1GB，虽然极少会用到这个大。所以在Go语言中一次创建十万左右的goroutine也是可以的。</p>
<h2 id="runtime包"><a href="#runtime包" class="headerlink" title="runtime包"></a>runtime包</h2><h3 id="runtime-Gosched"><a href="#runtime-Gosched" class="headerlink" title="runtime.Gosched()"></a>runtime.Gosched()</h3><p>让出CPU时间片，重新等待安排任务。<br>runtime.Gosched函数的作用是暂停调用他的Goroutine的运行，调用他的Goroutine会被重新置于Gorunnable状态，并被放入调度器可运行G队列中。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">			fmt.Println(s)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(<span class="string">"world"</span>)</span><br><span class="line">	<span class="comment">//主协程</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++&#123;</span><br><span class="line">		<span class="comment">//切一下，再次分配任务</span></span><br><span class="line">		runtime.Gosched()</span><br><span class="line">		fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">world</span><br><span class="line">world</span><br><span class="line">hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure></p>
<h3 id="runtime-Goexit"><a href="#runtime-Goexit" class="headerlink" title="runtime.Goexit()"></a>runtime.Goexit()</h3><p>退出当前协程。<br>runtime.Goexit函数被调用后，会立即使调用他的Groution的运行被终止，但其他Goroutine并不会受到影响。runtime.Goexit函数在终止调用它的Goroutine的运行之前会先执行该Groution中还没有执行的defer语句。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> fmt.Println(<span class="string">"A.defer"</span>)</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> fmt.Println(<span class="string">"B.defer"</span>)</span><br><span class="line">			runtime.Goexit()</span><br><span class="line">			<span class="keyword">defer</span> fmt.Println(<span class="string">"C.defer"</span>)</span><br><span class="line">			fmt.Println(<span class="string">"B"</span>)</span><br><span class="line">		&#125;()</span><br><span class="line">		fmt.Println(<span class="string">"A"</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">//主协程</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="runtime-GOMAXPROCS"><a href="#runtime-GOMAXPROCS" class="headerlink" title="runtime.GOMAXPROCS()"></a>runtime.GOMAXPROCS()</h3><p>Go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。</p>
<p>Go语言中可以通过runtime.GOMAXPROCS()函数设置当前程序并发时占用的CPU逻辑核心数。<br>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p>
<p>我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里举个例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i ++&#123;</span><br><span class="line">		fmt.Print(<span class="string">"A:"</span>,i,<span class="string">" "</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i ++&#123;</span><br><span class="line">		fmt.Print(<span class="string">"B:"</span>,i,<span class="string">" "</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> a()</span><br><span class="line">	<span class="keyword">go</span> b()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。 将逻辑核心数设为2，此时两个任务并行执行，代码如下。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> a()</span><br><span class="line">	<span class="keyword">go</span> b()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A:<span class="number">1</span> A:<span class="number">2</span> A:<span class="number">3</span> A:<span class="number">4</span> A:<span class="number">5</span> A:<span class="number">6</span> A:<span class="number">7</span> A:<span class="number">8</span> A:<span class="number">9</span></span><br><span class="line">B:<span class="number">1</span> B:<span class="number">2</span> B:<span class="number">3</span> B:<span class="number">4</span> B:<span class="number">5</span> B:<span class="number">6</span> B:<span class="number">7</span> B:<span class="number">8</span> B:<span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<p>Go语言中的操作系统线程和goroutine的关系：</p>
<ol>
<li>一个操作系统线程对应用户态多个goroutine。</li>
<li>go程序可以同时使用多个操作系统线程。</li>
<li>goroutine和OS线程是多对多的关系，即m:n。</li>
</ol>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><h1 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h1><h1 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h1><h1 id="常用标准库"><a href="#常用标准库" class="headerlink" title="常用标准库"></a>常用标准库</h1><h1 id="beego框架"><a href="#beego框架" class="headerlink" title="beego框架"></a>beego框架</h1><p>beego是一个类似tornado的Go应用框架，采用了RESTFul的方式来实现应用框架，是一个超轻量级的框架。<br>bee 工具是一个为了协助快速开发 beego 项目而创建的项目，通过 bee 您可以很容易的进行 beego 项目的创建、热编译、开发、测试、和部署。</p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>创建一个新的beego项目过程略去。</p>
<h3 id="项目路由设置"><a href="#项目路由设置" class="headerlink" title="项目路由设置"></a>项目路由设置</h3><p>前面我们已经创建了 beego 项目，而且我们也看到它已经运行起来了，那么是如何运行起来的呢？让我们从入口文件先分析起来吧：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">"quickstart/routers"</span></span><br><span class="line">    <span class="string">"github.com/astaxie/beego"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    beego.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到 main 函数是入口函数，但是我们知道 Go 的执行过程是如下图所示的方式：</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/Golang%E4%B8%AD%E9%98%B6/init.png">
</center>

<p>这里我们就看到了我们引入了一个包 _ “quickstart/routers”,这个包只引入执行了里面的 init 函数，那么让我们看看这个里面做了什么事情：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"quickstart/controllers"</span></span><br><span class="line">    <span class="string">"github.com/astaxie/beego"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    beego.Router(<span class="string">"/"</span>, &amp;controllers.MainController&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>路由包里面我们看到执行了路由注册 <code>beego.Router</code>, 这个函数的功能是映射 URL 到 controller，第一个参数是 URL (用户请求的地址)，这里我们注册的是 <code>/</code>，也就是我们访问的不带任何参数的 URL，第二个参数是对应的 Controller，也就是我们即将把请求分发到那个控制器来执行相应的逻辑，我们可以执行类似的方式注册如下路由：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beego.Router(<span class="string">"/user"</span>, &amp;controllers.UserController&#123;&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这样用户就可以通过访问 <code>/user</code> 去执行 <code>UserController</code> 的逻辑。这就是我们所谓的路由，更多更复杂的路由规则请查询beego 的路由设置</p>
<p>再回来看看 main 函数里面的 beego.Run， beego.Run 执行之后，我们看到的效果好像只是监听服务端口这个过程，但是它内部做了很多事情：</p>
<ul>
<li><p>解析配置文件<br>beego 会自动解析在 conf 目录下面的配置文件 app.conf，通过修改配置文件相关的属性，我们可以定义：开启的端口，是否开启 session，应用名称等信息。</p>
</li>
<li><p>执行用户的 hookfunc<br>beego 会执行用户注册的 hookfunc，默认的已经存在了注册 mime，用户可以通过函数 AddAPPStartHook 注册自己的启动函数。</p>
</li>
<li><p>是否开启 session<br>会根据上面配置文件的分析之后判断是否开启 session，如果开启的话就初始化全局的 session。</p>
</li>
<li><p>是否编译模板<br>beego 会在启动的时候根据配置把 views 目录下的所有模板进行预编译，然后存在 map 里面，这样可以有效的提高模板运行的效率，无需进行多次编译。</p>
</li>
<li><p>是否开启文档功能<br>根据 EnableDocs 配置判断是否开启内置的文档路由功能</p>
</li>
<li><p>是否启动管理模块<br>beego 目前做了一个很酷的模块，应用内监控模块，会在 8088 端口做一个内部监听，我们可以通过这个端口查询到 QPS、CPU、内存、GC、goroutine、thread 等统计信息。</p>
</li>
<li><p>监听服务端口<br>这是最后一步也就是我们看到的访问 8080 看到的网页端口，内部其实调用了 ListenAndServe，充分利用了 goroutine 的优势</p>
</li>
</ul>
<p>一旦 run 起来之后，我们的服务就监听在两个端口了，一个服务端口 8080 作为对外服务，另一个 8088 端口实行对内监控。</p>
<p>通过这个代码的分析我们了解了 beego 运行起来的过程，以及内部的一些机制。接下来让我们去剥离 Controller 如何来处理逻辑的。</p>
<h3 id="Controller运行机制"><a href="#Controller运行机制" class="headerlink" title="Controller运行机制"></a>Controller运行机制</h3><p>前面我们了解了如何把用户的请求分发到控制器，这小节我们就介绍大家如何来写控制器，首先我们还是从源码分析入手：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controllers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"github.com/astaxie/beego"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MainController <span class="keyword">struct</span> &#123;</span><br><span class="line">        beego.Controller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MainController)</span> <span class="title">Get</span><span class="params">()</span></span> &#123;</span><br><span class="line">        this.Data[<span class="string">"Website"</span>] = <span class="string">"beego.me"</span></span><br><span class="line">        this.Data[<span class="string">"Email"</span>] = <span class="string">"astaxie@gmail.com"</span></span><br><span class="line">        this.TplName = <span class="string">"index.tpl"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码显示首先我们声明了一个控制器 <code>MainController</code>，这个控制器里面内嵌了 <code>beego.Controller</code>，这就是 Go 的嵌入方式，也就是 <code>MainController</code> 自动拥有了所有 <code>beego.Controller</code> 的方法。</p>
<p>而 <code>beego.Controller</code> 拥有很多方法，其中包括 <code>Init</code>、<code>Prepare</code>、<code>Post</code>、<code>Get</code>、<code>Delete</code>、<code>Head</code> 等方法。我们可以通过重写的方式来实现这些方法，而我们上面的代码就是重写了 <code>Get</code> 方法。</p>
<p>我们先前介绍过 beego 是一个 RESTful 的框架，所以我们的请求默认是执行对应 <code>req.Method</code> 的方法。例如浏览器的是 <code>GET</code> 请求，那么默认就会执行 <code>MainController</code> 下的 <code>Get</code> 方法。这样我们上面的 Get 方法就会被执行到，这样就进入了我们的逻辑处理。（用户可以改变这个行为，通过注册自定义的函数名)</p>
<p>里面的代码是需要执行的逻辑，这里只是简单的输出数据，我们可以通过各种方式获取数据，然后赋值到 <code>this.Data</code> 中，这是一个用来存储输出数据的 map，可以赋值任意类型的值，这里我们只是简单举例输出两个字符串。</p>
<p>最后一个就是需要去渲染的模板，<code>this.TplName</code> 就是需要渲染的模板，这里指定了 <code>index.tpl</code>，如果用户不设置该参数，那么默认会去到模板目录的 <code>Controller/&lt;方法名&gt;.tpl</code> 查找，例如上面的方法会去 <code>maincontroller/get.tpl</code> (<strong>文件、文件夹必须小写</strong>)。</p>
<p>用户设置了模板之后系统会自动的调用 <code>Render</code> 函数（这个函数是在 <code>beego.Controller</code> 中实现的），所以无需用户自己来调用渲染。</p>
<p>当然也可以不使用模版，直接用<code>this.Ctx.WriteString</code> 输出字符串，如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MainController)</span> <span class="title">Get</span><span class="params">()</span></span> &#123;</span><br><span class="line">        this.Ctx.WriteString(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="model逻辑"><a href="#model逻辑" class="headerlink" title="model逻辑"></a>model逻辑</h3><p>我们知道 Web 应用中我们用的最多的就是数据库操作，而 model 层一般用来做这些操作，我们的 <code>bee new</code> 例子不存在 Model 的演示，但是 <code>bee api</code> 应用中存在 model 的应用。说的简单一点，如果您的应用足够简单，那么 Controller 可以处理一切的逻辑，如果您的逻辑里面存在着可以复用的东西，那么就抽取出来变成一个模块。因此 Model 就是逐步抽象的过程，一般我们会在 Model 里面处理一些数据读取，如下是一个日志分析应用中的代码片段：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"loggo/utils"</span></span><br><span class="line">    <span class="string">"path/filepath"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    NotPV []<span class="keyword">string</span> = []<span class="keyword">string</span>&#123;<span class="string">"css"</span>, <span class="string">"js"</span>, <span class="string">"class"</span>, <span class="string">"gif"</span>, <span class="string">"jpg"</span>, <span class="string">"jpeg"</span>, <span class="string">"png"</span>, <span class="string">"bmp"</span>, <span class="string">"ico"</span>, <span class="string">"rss"</span>, <span class="string">"xml"</span>, <span class="string">"swf"</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> big = <span class="number">0xFFFFFF</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LogPV</span><span class="params">(urls <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    ext := filepath.Ext(urls)</span><br><span class="line">    <span class="keyword">if</span> ext == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> NotPV &#123;</span><br><span class="line">        <span class="keyword">if</span> v == strings.ToLower(ext) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以如果您的应用足够简单，那么就不需要 Model 了；如果你的模块开始多了，需要复用，需要逻辑分离了，那么 Model 是必不可少的。接下来我们将分析如何编写 View 层的东西。</p>
<h3 id="View编写"><a href="#View编写" class="headerlink" title="View编写"></a>View编写</h3><p>在前面编写 Controller 的时候，我们在 Get 里面写过这样的语句 <code>this.TplName = &quot;index.tpl&quot;</code>，设置显示的模板文件，默认支持 <code>tpl</code> 和 <code>html</code> 的后缀名，如果想设置其他后缀你可以调用 <code>beego.AddTemplateExt</code> 接口设置，那么模板如何来显示相应的数据呢？beego 采用了 Go 语言默认的模板引擎，所以和 Go 的模板语法一样，Go 模板的详细使用方法请参考《Go Web 编程》模板使用指南</p>
<p>我们看看快速入门里面的代码（去掉了 css 样式）：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Beego<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"hero-unit"</span> <span class="attr">style</span>=<span class="string">"background-color:#A9F16C"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hero-text"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome to Beego!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"description"</span>&gt;</span></span><br><span class="line">                            Beego is a simple &amp; powerful Go web framework which is inspired by tornado and sinatra.</span><br><span class="line">                            <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">                            Official website: <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://&#123;&#123;.Website&#125;&#125;"</span>&gt;</span>&#123;&#123;.Website&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">                            Contact me: &#123;&#123;.Email&#125;&#125;</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>我们在 Controller 里面把数据赋值给了 data（map 类型），然后我们在模板中就直接通过 key 访问 <code>.Website</code> 和 <code>.Email</code> 。这样就做到了数据的输出。接下来我们讲解如何让静态文件输出。</p>
<h3 id="静态文件处理"><a href="#静态文件处理" class="headerlink" title="静态文件处理"></a>静态文件处理</h3><p>前面我们介绍了如何输出静态页面，但是我们的网页往往包含了很多的静态文件，包括图片、JS、CSS 等，刚才创建的应用里面就创建了如下目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── static</span><br><span class="line">    │   ├── css</span><br><span class="line">    │   ├── img</span><br><span class="line">    │   └── js</span><br></pre></td></tr></table></figure></p>
<p>beego 默认注册了 static 目录为静态处理的目录，注册样式：URL 前缀和映射的目录（在/main.go文件中beego.Run()之前加入）：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StaticDir[<span class="string">"/static"</span>] = <span class="string">"static"</span></span><br></pre></td></tr></table></figure></p>
<p>用户可以设置多个静态文件处理目录，例如你有多个文件下载目录 download1、download2，你可以这样映射（在 /main.go 文件中 beego.Run() 之前加入）：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beego.SetStaticPath(<span class="string">"/down1"</span>, <span class="string">"download1"</span>)</span><br><span class="line">beego.SetStaticPath(<span class="string">"/down2"</span>, <span class="string">"download2"</span>)</span><br></pre></td></tr></table></figure></p>
<p>这样用户访问 URL <code>http://localhost:8080/down1/123.txt</code> 则会请求 download1 目录下的 123.txt 文件。</p>
<h2 id="beego的MVC架构介绍"><a href="#beego的MVC架构介绍" class="headerlink" title="beego的MVC架构介绍"></a>beego的MVC架构介绍</h2><h3 id="controller设计"><a href="#controller设计" class="headerlink" title="controller设计"></a>controller设计</h3><h4 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h4><p>beego 目前支持 INI、XML、JSON、YAML 格式的配置文件解析，但是默认采用了 INI 格式解析，用户可以通过简单的配置就可以获得很大的灵活性。</p>
<h5 id="默认配置解析"><a href="#默认配置解析" class="headerlink" title="默认配置解析"></a>默认配置解析</h5><h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h1 id="插件库"><a href="#插件库" class="headerlink" title="插件库"></a>插件库</h1>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/17/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/" rel="prev" title="C语言指针">
      <i class="fa fa-chevron-left"></i> C语言指针
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/" rel="next" title="区块链基础">
      区块链基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#函数"><span class="nav-number">1.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包-closure"><span class="nav-number">1.1.</span> <span class="nav-text">闭包(closure)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包详解"><span class="nav-number">1.1.1.</span> <span class="nav-text">闭包详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#闭包结构体"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">闭包结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#例1："><span class="nav-number">1.1.1.2.</span> <span class="nav-text">例1：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#例2："><span class="nav-number">1.1.1.3.</span> <span class="nav-text">例2：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#例3："><span class="nav-number">1.1.1.4.</span> <span class="nav-text">例3：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#延迟引用"><span class="nav-number">1.1.2.</span> <span class="nav-text">延迟引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-range-和-for-区别"><span class="nav-number">1.1.3.</span> <span class="nav-text">for range 和 for 区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#方法"><span class="nav-number">2.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#方法定义"><span class="nav-number">2.1.</span> <span class="nav-text">方法定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#receiver-T-和-T-的差别"><span class="nav-number">2.1.1.</span> <span class="nav-text">receiver T 和 *T 的差别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#普通函数与方法的区别"><span class="nav-number">2.1.2.</span> <span class="nav-text">普通函数与方法的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#匿名字段"><span class="nav-number">2.2.</span> <span class="nav-text">匿名字段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法集"><span class="nav-number">2.3.</span> <span class="nav-text">方法集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#表达式"><span class="nav-number">2.4.</span> <span class="nav-text">表达式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#接口-interface"><span class="nav-number">3.</span> <span class="nav-text">接口(interface)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#接口类型"><span class="nav-number">3.1.</span> <span class="nav-text">接口类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要使用接口"><span class="nav-number">3.2.</span> <span class="nav-text">为什么要使用接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口的定义"><span class="nav-number">3.3.</span> <span class="nav-text">接口的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#值接收者和指针接收者"><span class="nav-number">3.4.</span> <span class="nav-text">值接收者和指针接收者</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#值接收者实现接口"><span class="nav-number">3.4.1.</span> <span class="nav-text">值接收者实现接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针接收者实现接口"><span class="nav-number">3.4.2.</span> <span class="nav-text">指针接收者实现接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型与接口的关系"><span class="nav-number">3.5.</span> <span class="nav-text">类型与接口的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一个类型实现多个接口"><span class="nav-number">3.5.1.</span> <span class="nav-text">一个类型实现多个接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多个类型实现同一接口"><span class="nav-number">3.5.2.</span> <span class="nav-text">多个类型实现同一接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口嵌套"><span class="nav-number">3.6.</span> <span class="nav-text">接口嵌套</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#空接口"><span class="nav-number">3.7.</span> <span class="nav-text">空接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#空接口的应用"><span class="nav-number">3.7.1.</span> <span class="nav-text">空接口的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#空接口作为函数的参数"><span class="nav-number">3.7.1.1.</span> <span class="nav-text">空接口作为函数的参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空接口作为map的值"><span class="nav-number">3.7.1.2.</span> <span class="nav-text">空接口作为map的值</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络编程"><span class="nav-number">4.</span> <span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#socket编程"><span class="nav-number">4.1.</span> <span class="nav-text">socket编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP编程"><span class="nav-number">4.1.1.</span> <span class="nav-text">TCP编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP编程"><span class="nav-number">4.1.2.</span> <span class="nav-text">UDP编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP黏包"><span class="nav-number">4.1.3.</span> <span class="nav-text">TCP黏包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http编程"><span class="nav-number">4.2.</span> <span class="nav-text">http编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WebSocket编程"><span class="nav-number">4.3.</span> <span class="nav-text">WebSocket编程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#并发编程"><span class="nav-number">5.</span> <span class="nav-text">并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Goroutine"><span class="nav-number">5.1.</span> <span class="nav-text">Goroutine</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#调度模型简介"><span class="nav-number">5.1.1.</span> <span class="nav-text">调度模型简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度实现"><span class="nav-number">5.1.2.</span> <span class="nav-text">调度实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启动单个goroutine"><span class="nav-number">5.1.3.</span> <span class="nav-text">启动单个goroutine</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启动多个goroutine"><span class="nav-number">5.1.4.</span> <span class="nav-text">启动多个goroutine</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#runtime包"><span class="nav-number">5.2.</span> <span class="nav-text">runtime包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#runtime-Gosched"><span class="nav-number">5.2.1.</span> <span class="nav-text">runtime.Gosched()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#runtime-Goexit"><span class="nav-number">5.2.2.</span> <span class="nav-text">runtime.Goexit()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#runtime-GOMAXPROCS"><span class="nav-number">5.2.3.</span> <span class="nav-text">runtime.GOMAXPROCS()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Channel"><span class="nav-number">5.3.</span> <span class="nav-text">Channel</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据操作"><span class="nav-number">6.</span> <span class="nav-text">数据操作</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存布局"><span class="nav-number">7.</span> <span class="nav-text">内存布局</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常用标准库"><span class="nav-number">8.</span> <span class="nav-text">常用标准库</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#beego框架"><span class="nav-number">9.</span> <span class="nav-text">beego框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#快速入门"><span class="nav-number">9.1.</span> <span class="nav-text">快速入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#项目路由设置"><span class="nav-number">9.1.1.</span> <span class="nav-text">项目路由设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Controller运行机制"><span class="nav-number">9.1.2.</span> <span class="nav-text">Controller运行机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#model逻辑"><span class="nav-number">9.1.3.</span> <span class="nav-text">model逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#View编写"><span class="nav-number">9.1.4.</span> <span class="nav-text">View编写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态文件处理"><span class="nav-number">9.1.5.</span> <span class="nav-text">静态文件处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#beego的MVC架构介绍"><span class="nav-number">9.2.</span> <span class="nav-text">beego的MVC架构介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#controller设计"><span class="nav-number">9.2.1.</span> <span class="nav-text">controller设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#参数配置"><span class="nav-number">9.2.1.1.</span> <span class="nav-text">参数配置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#默认配置解析"><span class="nav-number">9.2.1.1.1.</span> <span class="nav-text">默认配置解析</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#微服务"><span class="nav-number">10.</span> <span class="nav-text">微服务</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#插件库"><span class="nav-number">11.</span> <span class="nav-text">插件库</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="chen"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">chen</p>
  <div class="site-description" itemprop="description">大人，时代变了</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/747948341@qq.com" title="E-Mail → 747948341@qq.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chen</span>
</div>



        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
