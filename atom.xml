<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>群芳髓</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-24T05:41:34.307Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker基础</title>
    <link href="http://yoursite.com/2020/01/24/docker%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/01/24/docker基础/</id>
    <published>2020-01-24T05:28:43.000Z</published>
    <updated>2020-01-24T05:41:34.307Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go面试</title>
    <link href="http://yoursite.com/2020/01/24/Go%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2020/01/24/Go面试/</id>
    <published>2020-01-24T05:28:24.000Z</published>
    <updated>2020-01-24T05:28:24.104Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>排序算法及Go实现</title>
    <link href="http://yoursite.com/2020/01/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8AGo%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2020/01/23/排序算法及Go实现/</id>
    <published>2020-01-23T04:37:31.000Z</published>
    <updated>2020-01-25T15:55:52.695Z</updated>
    
    <content type="html"><![CDATA[<p>排序算法的Go语言实现。</p><a id="more"></a><blockquote><p>如果中途对某些算法过程不懂可以去看这个网站：<br><a href="https://visualgo.net/zh/sorting" target="_blank" rel="noopener">visualgo.net</a></p><p>参考文档：<br><a href="https://itimetraveler.github.io/2017/07/18/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8Ejava%E5%AE%9E%E7%8E%B0/?utm_source=juhe&amp;utm_source=juhe#%E4%BA%94%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88Bubble-Sort%EF%BC%89" target="_blank" rel="noopener">八大排序算法总结与java实现</a><br><a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">十大经典排序算法（动图演示）</a></p></blockquote><h1 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h1><h2 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h2><p>十种常见排序算法可以分为两大类：</p><ul><li><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li><li><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</li></ul><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8AGo%E5%AE%9E%E7%8E%B0/排序算法.png"></center><h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8AGo%E5%AE%9E%E7%8E%B0/算法复杂度.png"></center><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。<br><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。<br><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。<br><strong>空间复杂度</strong>：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</p><blockquote><p>数组指针和指针数组:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组指针：</span></span><br><span class="line">a *[<span class="number">10</span>] <span class="keyword">int</span> <span class="comment">//(a *是个指针，指向int[10]的数组)</span></span><br><span class="line"><span class="comment">//指针数组：</span></span><br><span class="line">a [<span class="number">10</span>]* <span class="keyword">int</span> <span class="comment">//(a[10] 是数组，数组的元素是指向int的指针)</span></span><br></pre></td></tr></table></figure></p></blockquote><h1 id="直接插入排序-Insertion-Sort"><a href="#直接插入排序-Insertion-Sort" class="headerlink" title="直接插入排序(Insertion Sort)"></a>直接插入排序(Insertion Sort)</h1><p>插入排序的设计初衷是<strong>往有序的数组中快速插入一个新的元素</strong>。<br>它的算法思想是：把要排序的数组分为了两个部分, 一部分是数组的全部元素(除去待插入的元素), 另一部分是待插入的元素; 先将第一部分排序完成, 然后再插入这个元素. 其中第一部分的排序也是通过再次拆分为两部分来进行的。</p><p>插入排序由于操作不尽相同, 可分为 直接插入排序 , 折半插入排序(又称二分插入排序), 链表插入排序 , 希尔排序 。我们先来看下直接插入排序。</p><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>直接插入排序的基本思想是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过为止。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8AGo%E5%AE%9E%E7%8E%B0/使用插入排序为一列数字进行排序的过程.gif">    <div style="color:orange;    display: inline-block;    color: #999;    padding: 0px;">使用插入排序为一列数字进行排序的过程</div></center><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤2~5</li></ol><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8AGo%E5%AE%9E%E7%8E%B0/直接插入排序演示.gif">    <div style="color:orange;    display: inline-block;    color: #999;    padding: 0px;"> 直接插入排序演示 </div></center><p>算法实现中比较有意思的一点是，在每次比较操作发现取出来的新元素小于等于已排序的元素时，可以将已排序的元素移到下一位置，然后将取出来的新元素插入该位置（即相邻位置对调），接着再与前面的已排序的元素进行比较，如上图所示，这样做缺点是交换操作代价比较大。另一种做法是：将新元素取出（挖坑），从左到右依次与已排序的元素比较，如果已排序的元素大于取出的新元素，那么将该元素移动到下一个位置（填坑），接着再与前面的已排序的元素比较，直到找到已排序的元素小于等于新元素的位置，这时再将新元素插入进去。就像基本思想中的动图演示的那样。</p><p>如果<strong>比较操作</strong>的代价比<strong>交换操作</strong>大的话，可以采用<strong>二分查找法</strong>来减少比较操作的数目。可以认为是插入排序的一个变种，称为<strong>二分查找插入排序</strong>。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setArray</span><span class="params">()</span> <span class="params">(a [10]<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">rand.Seed(time.Now().Unix())</span><br><span class="line">n := <span class="built_in">len</span>(a) - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">a[i] = rand.Intn(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>  a</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertSort</span><span class="params">(a *[10]<span class="keyword">int</span>)</span> *[10]<span class="title">int</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(a) - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n ; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := i; j &gt;= <span class="number">0</span>; j -- &#123;</span><br><span class="line"><span class="keyword">if</span> a [j] &gt; a [j +<span class="number">1</span>] &#123;</span><br><span class="line">a [j], a[j+<span class="number">1</span>] = a [j+<span class="number">1</span>], a[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := setArray()</span><br><span class="line">fmt.Println(<span class="string">"排序前:"</span>,a)</span><br><span class="line">insertSort(&amp;a)</span><br><span class="line">fmt.Println(<span class="string">"排序后:"</span>,a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">排序前: [<span class="number">96</span> <span class="number">80</span> <span class="number">81</span> <span class="number">88</span> <span class="number">60</span> <span class="number">65</span> <span class="number">84</span> <span class="number">8</span> <span class="number">55</span> <span class="number">0</span>]</span><br><span class="line">排序后: [<span class="number">0</span> <span class="number">8</span> <span class="number">55</span> <span class="number">60</span> <span class="number">65</span> <span class="number">80</span> <span class="number">81</span> <span class="number">84</span> <span class="number">88</span> <span class="number">96</span>]</span><br></pre></td></tr></table></figure></p><h2 id="直接插入排序复杂度"><a href="#直接插入排序复杂度" class="headerlink" title="直接插入排序复杂度"></a>直接插入排序复杂度</h2><p>直接插入排序复杂度如下：</p><ul><li>最好情况下，排序前对象已经按照要求的有序。<br>比较次数(KCN)： $n−1$ ；<br>移动次数(RMN)为0。<br>则对应的时间复杂度为 $O(n)$</li><li>最坏情况下，排序前对象为要求的顺序的反序。第i趟时第i个对象必须与前面i个对象都做排序码比较，并且每做1次比较就要做1次数据移动（从上面给出的代码中看出）。<br>比较次数(KCN)：    $\sum_{i=1}^{n-1}i = \frac{n(n-1)}{2} ≈ \frac{n^2}{2}$ ；<br>移动次数(RMN)为： $\sum_{i=1}^{n-1}i = \frac{n(n-1)}{2} ≈ \frac{n^2}{2}$ 。<br>则对应的时间复杂度为 $O(n^2)$</li><li>如果排序记录是随机的，那么根据概率相同的原则，在平均情况下的排序码比较次数和对象移动次数约为 $\frac{n^2}{2}$ 。<br>因此，直接插入排序的平均时间复杂度为 $O(n^2)$</li></ul><div class="table-container"><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td></tr></tbody></table></div><p>Tips:由于直接插入排序每次只移动一个元素的位， 并不会改变值相同的元素之间的排序， 因此它是一种稳定排序。</p><h1 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序(Shell Sort)"></a>希尔排序(Shell Sort)</h1><p>希尔排序，也称递减增量排序算法，1959年Shell发明。是插入排序的一种高速而稳定的改进版本。</p><p>希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><blockquote><p>第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。</p></blockquote><h2 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h2><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8AGo%E5%AE%9E%E7%8E%B0/希尔排序.gif"></center><p>将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次再将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。</p><p>可以看到步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。一般来说最简单的步长取值是<strong>初次取数组长度的一半</strong>为增量，之后每次再减半，直到增量为1。</p><h2 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h2><ol><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（<strong>一般初次取数组半长，之后每次再减半，直到增量为1</strong>）</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shellSort</span> <span class="params">(a *[10] <span class="keyword">int</span>)</span> *[10] <span class="title">int</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(a)</span><br><span class="line"><span class="keyword">for</span> key := n / <span class="number">2</span>; key &gt; <span class="number">0</span>; key = key / <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := key; i &lt; n; i ++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := i; j &gt;= key &amp;&amp; a[j] &lt; a[j-key]; j = j- key &#123;</span><br><span class="line">a[j], a[j-key] = a[j-key], a[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序复杂度"><a href="#希尔排序复杂度" class="headerlink" title="希尔排序复杂度"></a>希尔排序复杂度</h2><div class="table-container"><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>$O(n\log_{2}n$</td><td>$O(n\log_{2}n$</td><td>$O(n\log_{2}n$</td><td>$O(1)$</td></tr></tbody></table></div><h1 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序(Selection Sort)"></a>选择排序(Selection Sort)</h1><p>从算法逻辑上看，选择排序是一种简单直观的排序算法，在简单选择排序过程中，所需移动记录的次数比较少。</p><h2 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h2><p>选择排序的基本思想：比较 + 交换。</p><p>在未排序序列中找到最小（大）元素，存放到未排序序列的起始位置。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8AGo%E5%AE%9E%E7%8E%B0/选择排序.gif"></center><h2 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h2><ol><li>从待排序序列中，找到关键字最小的元素；</li><li>如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；</li><li>从余下的 N - 1 个元素中，找出关键字最小的元素，重复1、2步，直到排序结束。</li></ol><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectSort</span><span class="params">(a *[10] <span class="keyword">int</span>)</span> *[10] <span class="title">int</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(a) <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n ; i ++ &#123;</span><br><span class="line">min := i</span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt;= n  ; j ++ &#123;</span><br><span class="line"><span class="keyword">if</span> a[j] &lt; a[min]&#123;</span><br><span class="line">min = j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> min != i &#123;</span><br><span class="line">a[i], a[min] =a[min], a[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序复杂度"><a href="#选择排序复杂度" class="headerlink" title="选择排序复杂度"></a>选择排序复杂度</h2><div class="table-container"><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td></tr></tbody></table></div><p>选择排序的简单和直观名副其实，这也造就了它”出了名的慢性子”，无论是哪种情况，哪怕原数组已排序完成，它也将花费将近 $\frac{n^2}{2}$ 次遍历来确认一遍。即便是这样，它的排序结果也还是不稳定的。 唯一值得高兴的是，它并不耗费额外的内存空间。</p><h1 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h1><h2 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h2><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8AGo%E5%AE%9E%E7%8E%B0/冒泡排序演示.gif">    <div style="color:orange;    display: inline-block;    color: #999;    padding: 0px;">冒泡排序演示</div></center><h2 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h2><p>冒泡排序算法的运作如下：</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤1~3，直到没有任何一对数字需要比较。</li></ol><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(a *[10] <span class="keyword">int</span>)</span> *[10] <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(a); i &gt; <span class="number">0</span>; i --&#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span> ; j + <span class="number">1</span> &lt; i ; j++&#123;</span><br><span class="line"><span class="keyword">if</span> a[j] &gt; a[j + <span class="number">1</span>]&#123;</span><br><span class="line">a[j],a[j + <span class="number">1</span>] =a[j + <span class="number">1</span>], a[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序算法复杂度"><a href="#冒泡排序算法复杂度" class="headerlink" title="冒泡排序算法复杂度"></a>冒泡排序算法复杂度</h2><div class="table-container"><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td></tr></tbody></table></div><p>冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近$\frac{n^2}{2}$次, 时间复杂度为 $O(n²)$ 。<br>最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为$O(n)$。<br>平均来讲, 时间复杂度为$O(n²)$。<br>由于冒泡排序中只有缓存的temp变量(如果用c写就需要中间变量temp来交换两个值)需要内存空间, 因此空间复杂度为常量$O(1)$.</p><h1 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序(Quick Sort)"></a>快速排序(Quick Sort)</h1><p>快速排序（Quicksort）是对冒泡排序的一种改进，借用了分治的思想。</p><h2 id="基本思想-4"><a href="#基本思想-4" class="headerlink" title="基本思想"></a>基本思想</h2><p>快速排序的基本思想：挖坑填数+分治法。</p><p>首先选一个轴值(pivot，也有叫基准的)，通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8AGo%E5%AE%9E%E7%8E%B0/使用快速排序法对一列数字进行排序的过程.gif">    <div style="color:orange;    display: inline-block;    color: #999;    padding: 0px;">使用快速排序法对一列数字进行排序的过程</div></center><h2 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h2><p>快速排序使用分治策略来把一个序列（list）分为两个子序列（sub-lists）。步骤为：</p><ol><li>从数列中挑出一个元素，称为”基准”（pivot）。</li><li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li><li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><p>递归到最底部时，数列的大小是零或一，也就是已经排序好了。快速排序每趟仅将一个元素归位。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8AGo%E5%AE%9E%E7%8E%B0/快速排序演示.gif">    <div style="color:orange;    display: inline-block;    color: #999;    padding: 0px;">快速排序演示</div></center><h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><h1 id="堆排序-Heap-Sort"><a href="#堆排序-Heap-Sort" class="headerlink" title="堆排序(Heap Sort)"></a>堆排序(Heap Sort)</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排序算法的Go语言实现。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>为什么写博客</title>
    <link href="http://yoursite.com/2020/01/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2020/01/23/为什么写博客/</id>
    <published>2020-01-23T02:30:14.000Z</published>
    <updated>2020-01-23T03:20:48.845Z</updated>
    
    <content type="html"><![CDATA[<p>昨天花了一天时间，想要把博客从hexo迁移到hugo，最后以失败回滚而告终，暴露了很多问题。<br>究其根本是我没有明白自己搭建博客的本意。</p><a id="more"></a><p>当初搭建博客，主要原因无非有以下两点：</p><ol><li>对自己学习过程的记录，写下来才能理解也避免了健忘</li><li>把网上自己搜到的东西记录下来，避免自己日后重复的搜索浪费时间</li></ol><p>hexo确实加载速度比较慢，Hugo有着其难以比拟的差距。<br>但问题是：<br><strong><font color="#FF0000"> 一件东西好就应该去用它吗? </font></strong></p><p>答案当然是要根据实际情况来。</p><font color="#FF0000"> 很多时候，稳定的才是最好的。 </font><p>最近这两天是为了年后的实习面试做准备，而昨天为了博客的迁移，花了一整天的时间，最终还是以失败告终，当然若没有失败，我现在就不会写这篇反思。把宝贵的一天花在了别的目的而荒废了现在主要的矛盾 - 面试准备，这无疑是一种浪费。</p><p><strong><font color="#FF0000"> 不要把精力放在与自己目的无关的地方 </font></strong></p><p>爱折腾其实也没什么，但<strong>折腾的时候应该分清场合及时机</strong>，很明显昨日并不是一个好时机。</p><p>其次，是备份的问题。<br>昨日折腾前，我对文件进行了备份，可问题在于，我根本没有备份完全！！！<br>在备份的时候少备份了一个文件夹，以至于我的一篇博客需要重写，因为少了的那个文档有很多图片。<br>我之前硬盘也坏掉过一次，那一次我同样丢失了大量文件以至于我花了而后一周的时间把我做过的作业等重新做了一遍。无疑是对我精力的极大浪费。</p><p><strong><font color="#FF0000"> 针对此，有以下的要求 </font></strong>：</p><ol><li>把博客以及关键资料进行上云(在把博客迁移到hugo后)</li><li>额外买一块移动硬盘(等我有钱…)，把文件定期进行备份</li><li>进行大的变更前需要进行备份且多份备份，并且没有彻底升级完成就不要清理回收站</li></ol><p>最后，本次升级虽然以失败告终，但我随后仍会将博客从hexo迁移至hugo。当然，这是在拿到offer后。<br>以及本人考虑买一台纯linux的电脑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天花了一天时间，想要把博客从hexo迁移到hugo，最后以失败回滚而告终，暴露了很多问题。&lt;br&gt;究其根本是我没有明白自己搭建博客的本意。&lt;/p&gt;
    
    </summary>
    
      <category term="反思与总结" scheme="http://yoursite.com/categories/%E5%8F%8D%E6%80%9D%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo小技巧</title>
    <link href="http://yoursite.com/2020/01/22/hexo%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2020/01/22/hexo小技巧/</id>
    <published>2020-01-22T03:24:10.000Z</published>
    <updated>2020-01-24T13:19:27.506Z</updated>
    
    <content type="html"><![CDATA[<p>hexo的操作。<br><a id="more"></a></p><h1 id="安装hexo报错"><a href="#安装hexo报错" class="headerlink" title="安装hexo报错"></a>安装hexo报错</h1><p>进入下面这个文件夹清除cache:<br>路径：C:/Users/PC/AppData/Roaming/npm-cache<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean --force</span><br></pre></td></tr></table></figure></p><h1 id="更新hexo"><a href="#更新hexo" class="headerlink" title="更新hexo"></a>更新hexo</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm outdated</span><br><span class="line">npm uninstall hexo --save</span><br><span class="line">npm install hexo@4.2.0 --save //@后为版本号</span><br></pre></td></tr></table></figure><h1 id="添加图片并居中"><a href="#添加图片并居中" class="headerlink" title="添加图片并居中"></a>添加图片并居中</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">"border-radius: 0.3125em;</span></span></span><br><span class="line"><span class="tag"><span class="string">    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">"这里输入图片地址"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"color:orange; border-bottom: 1px solid #d9d9d9;</span></span></span><br><span class="line"><span class="tag"><span class="string">    display: inline-block;</span></span></span><br><span class="line"><span class="tag"><span class="string">    color: #999;</span></span></span><br><span class="line"><span class="tag"><span class="string">    padding: 2px;"</span>&gt;</span>这里输入题注<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="字的颜色"><a href="#字的颜色" class="headerlink" title="字的颜色"></a>字的颜色</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font color="#FF0000"&gt; 红色字体 <span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Next-主题中渲染-MathJax-数学公式"><a href="#Next-主题中渲染-MathJax-数学公式" class="headerlink" title="Next 主题中渲染 MathJax 数学公式"></a>Next 主题中渲染 MathJax 数学公式</h1><p>到博客根目录下，找到node_modules\kramed\lib\rules\inline.js，把第11行的 escape 变量的值做相应的修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span></span><br><span class="line">escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,</span><br></pre></td></tr></table></figure><p>这一步是在原基础上取消了对\,{,}的转义(escape)。<br>同时把第20行的em变量也要做相应的修改。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span></span><br><span class="line">em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure></p><p>重新启动hexo（先clean再generate）,问题完美解决。</p><h1 id="hexo草稿"><a href="#hexo草稿" class="headerlink" title="hexo草稿"></a>hexo草稿</h1><p>建立文章草稿<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new draft &lt;title&gt;</span><br></pre></td></tr></table></figure></p><p>本机预览草稿<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo S --draft</span><br></pre></td></tr></table></figure></p><p>将草稿发布为正式文章<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo P &lt;filename&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hexo的操作。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>区块链基础</title>
    <link href="http://yoursite.com/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/01/21/区块链基础/</id>
    <published>2020-01-21T14:22:20.000Z</published>
    <updated>2020-01-24T13:13:29.443Z</updated>
    
    <content type="html"><![CDATA[<p>基础的区块链知识，如共识算法等。</p><a id="more"></a><p>区块链本质上是一个去中心化的系统。<br>分布式记帐技术（也就是区块链技术）沿袭了复式簿记法的精神，每一笔交易必定有输入(Inputs)与输出(Outputs)，输入是“钱从哪里来”，输出则是“钱流向哪里”。<br>在分布式帐本的世界里，每一笔交易要被验证，记录到区块中，最重要的核心过程就是达成网络中各节点(node)的“共识”。</p><h1 id="什么是共识机制"><a href="#什么是共识机制" class="headerlink" title="什么是共识机制"></a>什么是共识机制</h1><p>区块链可以看作一本记录所有交易的分布式公开帐簿，区块链网络中的每个参与者都把它看作一本所有权的权威记录。</p><blockquote><p>公开账本历史数据不可篡改，那么公开账本每个新区块由谁来负责写入？</p></blockquote><p>因此需要一种机制来保证区块链中的每一区块只能由一个节点来负责写入，如何选出写入账本数据的节点，这就是共识机制。让平等的参与者按照某种秩序达成一致意见。<br>打个比方，现在有一个中心数据库，所有客户端都能来查询，每个客户端权限都是一样，但如果要对数据库进行增删改，不好意思，每次只允许一个客户端来操作，通俗讲，就是让数据库串行修改数据库。通过一个算法机制来抉择出操作的客户端。这个机制就是共识机制，<strong>所谓的共识就是在人人平等的社会里需要大家共同形成一个共识，产生一个操作者、临时决策者，代表大家来进行中心化的操作，大家按照这个共识来维持去中心化的网络世界。</strong></p><h1 id="主流共识算法"><a href="#主流共识算法" class="headerlink" title="主流共识算法"></a>主流共识算法</h1><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/共识算法.jpg"></center><h2 id="共识算法概述"><a href="#共识算法概述" class="headerlink" title="共识算法概述"></a>共识算法概述</h2><p>共识算法是区块链网络的重要元素，因为它维持着分布式系统的完整性和安全性。<br>区块链中的共识算法说到底还是分布式系统中最重要的一致性问题：</p><blockquote><p>在分布式网络中如何保证数据一致性。</p></blockquote><p>说到一致性问题，就不得不提大名鼎鼎的拜占庭将军问题。</p><blockquote><p>Leslie Lamport 证明，当叛变者不超过1/3时，存在有效的算法，不论叛变者如何折腾，忠诚的将军们总能达成一致的结果。如果叛变者过多，则无法保证一定能达到一致性。</p></blockquote><p>对于拜占庭将军问题分两种情况：<br><strong>非拜占庭错误</strong>:针对非拜占庭错误的情况，一般包括 Paxos、Raft 及其变种。<br>分布式数据库设计一般都是基于paxos或raft算法。<br><strong>能容忍拜占庭错误</strong>:对于要能容忍拜占庭错误的情况，一般包括 PBFT(实用拜占庭容错算法)系列、PoW 系列算法等。<br>从概率角度，PBFT 系列算法是确定的，一旦达成共识就不可逆转；而 PoW 系列算法则是不确定的，随着时间推移，被推翻的概率越来越小。</p><h2 id="实用拜占庭容错PBFT"><a href="#实用拜占庭容错PBFT" class="headerlink" title="实用拜占庭容错PBFT"></a>实用拜占庭容错PBFT</h2><p>PBFT算法要求至少要4个参与者,核心理论是 $n&gt;=3f+1$<br>n是系统中的总节点数，f是允许出现故障的节点数。换句话说，如果这个系统允许出现f个故障，那么这个系统必须包括n个节点，才能解决故障。</p><p>PBFT 模型下，有一个节点会被当做主节点，而其他节点都是备份节点。系统内的所有节点都会相互通信，最终目标是大家能以少数服从多数的原则达成数据的共识。如果主节点出现明显的撒谎迹象，其他的节点也可以联合起来更换主节点。</p><p>每一个共识过程分下面这几步：</p><ol><li>取一个副本作为主节点，其他的副本作为备份；</li><li>用户端向主节点发送使用服务操作的请求；</li><li>主节点通过广播将请求发送给其他副本；</li><li>所有副本执行请求并将结果发回用户端；</li><li>用户端需要等待F+1个不同副本节点发回相同的结果，作为整个操作的最终结果。</li></ol><p>从第五步也可以看出，只要客户端能保证多数人认可了一个相同的结果，这个结果就是最终的共识了。</p><h2 id="工作量证明PoW"><a href="#工作量证明PoW" class="headerlink" title="工作量证明PoW"></a>工作量证明PoW</h2><p>在工作量证明中，一个成员要想成为领导者并选择下一个要添加到区块链的区块，他们必须要找到解决一个特定数学问题的方法。<br>工作量证明最常用的技术原理是散列函数。由于输入散列函数h()的任意值n，会对应到一个h(n)结果，而n只要变动一个比特，就会引起雪崩效应，所以几乎无法从h(n)反推回n，因此借由指定查找h(n)的特征，让用户进行大量的穷举运算，就可以达成工作量证明。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1.架构简明扼要、有效可靠。<br>2.由于要获得多数节点承认，那攻击者必须投入超过总体一半的运算量（51%攻击），才能保证篡改结果。这使得攻击成功的成本变得非常高昂，难以实现。<br>3.某种程度上是公平的，你投入越多的算力，你获得打包权的几率也等比增加。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>1.非常浪费能源。投入在一种加密货币上的能源，可能会超过一个小型国家的总使用量。<br>3.由于加密货币在世界上已成为一种投资标的，所以有技术者或富有者，可以开发出由ASIC组成的特制计算机，垄断算力。这与加密货币的去中心化思想背道而驰。</p><p>也因此，后期开发的加密货币有针对抗ASIC的算法设计，例如以太坊采用的Ethash（Dagger-Hashimoto）算法。<br>后期开发的加密货币陆续使用了POS机制（例如以太坊）或DPOS机制（例如比特股﹑EOS）。</p><blockquote><p>工作量证明让矿工们需使用大量的能量，从而促进了矿池的产生。<strong>这让区块链变得更加中心化，而不是去中心化</strong>。</p></blockquote><h2 id="权益证明PoS"><a href="#权益证明PoS" class="headerlink" title="权益证明PoS"></a>权益证明PoS</h2><p>PoS 是试图解决在 PoW 中大量资源被浪费的缺点。恶意参与者将存在保证金被罚没的风险，即损失经济利益。<br>股权证明去掉了工作量证明对于能源和计算能力的要求，并用股权替代。股权就是在一段时间内成员愿意锁定的货币数量。作为回报，他们有和他们的股权成比例的机会成为下一个领导者，并选择下一个区块。现在有一些币种只用股权证明如Nxt和Blackcoin。</p><p>权益证明通过选举的形式，其中任意节点被随机选择来验证下一个区块。<br>在这里有一些小的术语区别，权益证明中没有矿工，但是有验证者(validator)。并不让人们”挖(mine)”新区块 而是”铸造(mint)” 或”制造(forge)”新区块。</p><p>验证者并不是被完全随机选择的，要成为验证者，<strong>节点需要在网络中存入一定数量的货币作为权益</strong>，可以将这理解为保证金。<br>权益的份额大小决定了被选为验证者的几率，从而得以创建下一个区块，这是线性相关的。假设Bob在网络中存入100美元 Alice存入1000美元，那么Alice比Bob有高于10倍的几率选为验证者。</p><p>因为这偏袒有钱的一方，似乎不太公平，但事实上这比起工作量证明更公平。</p><p>如果一个节点被选出来验证下一个区块，他将检查当中所有的交易是否有效。如果一切没问题，节点则通过该区块，区块将加到区块链中。作为奖励，该节点可获得当中每个交易费。<br>如果验证者通过了欺诈性交易，他们将失去一部分权益。只要权益高于验证者所获得的交易费，我们就可以信任他们能够很好的完成工作。否则，他们失去的钱比能获得的还多。</p><h2 id="授权股权证明机制DPOS"><a href="#授权股权证明机制DPOS" class="headerlink" title="授权股权证明机制DPOS"></a>授权股权证明机制DPOS</h2><p>(Delegated Proof of Stake),PoS 的改进算法，DPOS与POS原理相似。与POS的主要区别在于节点选举若干代理，由代理人验证和记账。<br>相较于PoW每10分钟产生一个区块，DPoS每3秒钟即可产生一个区块。</p><h1 id="Raft和Paxos"><a href="#Raft和Paxos" class="headerlink" title="Raft和Paxos"></a>Raft和Paxos</h1><p>算法演进:</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/算法演进.jpg"></center><h2 id="paxos算法"><a href="#paxos算法" class="headerlink" title="paxos算法"></a>paxos算法</h2><blockquote><p>Paxos算法是基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一。</p></blockquote><p>Paxos算法运行在允许宕机故障的异步系统中，不要求可靠的消息传递，可容忍消息丢失、延迟、乱序以及重复。它利用大多数 (Majority) 机制保证了2F+1的容错能力，即2F+1个节点的系统最多允许F个节点同时出现故障</p><h3 id="问题产生的背景"><a href="#问题产生的背景" class="headerlink" title="问题产生的背景"></a>问题产生的背景</h3><p>在常见的分布式系统中，总会发生诸如<strong>机器宕机</strong>或<strong>网络异常</strong>（包括消息的延迟、丢失、重复、乱序，还有网络分区）等情况。Paxos算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对某个数据的值达成一致，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。</p><blockquote><p>注：这里某个数据的值并不只是狭义上的某个数，它可以是一条日志，也可以是一条命令（command）。。。根据应用场景不同，某个数据的值有不同的含义。</p></blockquote><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/paxos背景.png"></center><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>一个或多个提议进程 (Proposer) 可以发起提案 (Proposal)，最终要达成一致的value就在提案里。系统中的多数派同时认可该提案，即达成了一致。最多只针对一个确定的提案达成一致。</p><p>Paxos将系统中的角色分为提议者 (Proposer)，决策者 (Acceptor)，和最终决策学习者 (Learner):</p><ul><li>Proposer: 提出提案 (Proposal)。Proposal信息包括提案编号 (Proposal ID) 和提议的值 (Value)。</li><li>Acceptor：参与决策，回应Proposers的提案。收到Proposal后可以接受提案，若Proposal获得多数Acceptors的接受，则称该Proposal被批准。</li><li>Learner：不参与决策，从Proposers/Acceptors学习最新达成一致的提案（Value）。</li></ul><p>在具体的实现中，<strong>一个进程可能同时充当多种角色</strong>。比如一个进程可能既是Proposer又是Acceptor又是Learner。</p><p>注：</p><ul><li><strong>暂且</strong>认为 <strong>『提案=value』</strong>，即提案只包含value。在我们接下来的推导过程中会发现如果提案只包含value，会有问题，于是我们再对提案重新设计。</li><li><strong>暂且</strong> 认为 <strong>『Proposer可以直接提出提案』</strong>。在我们接下来的推导过程中会发现如果Proposer直接提出提案会有问题，需要增加一个学习提案的过程。</li></ul><p>回到刚刚说的『对某个数据的值达成一致』，指的是Proposer、Acceptor、Learner都认为同一个value被选定（chosen）。那么，Proposer、Acceptor、Learner分别在什么情况下才能认为某个value被选定呢？</p><ul><li>Proposer：只要Proposer发的提案被Acceptor接受（刚开始先认为只需要一个Acceptor接受即可，在推导过程中会发现需要半数以上的Acceptor同意才行），Proposer就认为该提案里的value被选定了。</li><li>Acceptor：只要Acceptor接受了某个提案，Acceptor就任务该提案里的value被选定了。</li><li>Learner：Acceptor告诉Learner哪个value被选定，Learner就认为那个value被选定。<center>  <img style="border-radius: 0.3125em;  box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/paxos相关概念.png"></center></li></ul><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>假设有一组可以<strong>提出（propose）value</strong>（value在提案Proposal里）的<strong>进程集合</strong>。一个一致性算法需要保证提出的这么多value中， <strong>只有一个</strong> value被选定（chosen）。如果没有value被提出，就不应该有value被选定。如果一个value被选定，那么所有进程都应该能学习（learn）到这个被选定的value。对于一致性算法， <strong>安全性（safaty）</strong> 要求如下：</p><ul><li>只有被提出的value才能被选定。</li><li>只有一个value被选定，并且如果某个进程认为某个value被选定了，那么这个value必须是真的被选定的那个。</li></ul><p>我们不去精确地定义其 <strong>活性（liveness）</strong> 要求。我们的目标是保证 <strong>最终有一个提出的value被选定</strong> 。当一个value被选定后，进程最终也能学习到这个value。</p><blockquote><p>Paxos的目标：保证最终有一个value会被选定，当value被选定后，进程最终也能获取到被选定的value。</p></blockquote><p>假设不同角色之间可以通过发送消息来进行通信，那么：</p><ul><li>每个角色以任意的速度执行，可能因出错而停止，也可能会重启。一个value被选定后，所有的角色可能失败然后重启，除非那些失败后重启的角色能记录某些信息，否则等他们重启后无法确定被选定的值。</li><li>消息在传递过程中可能出现任意时长的延迟，可能会重复，也可能丢失。但是消息不会被损坏，即消息内容不会被篡改（拜占庭将军问题）。</li></ul><h3 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h3><h4 id="最简单的方案——只有一个Acceptor"><a href="#最简单的方案——只有一个Acceptor" class="headerlink" title="最简单的方案——只有一个Acceptor"></a>最简单的方案——只有一个Acceptor</h4><p>假设只有一个Acceptor（可以有多个Proposer），只要Acceptor接受它收到的第一个提案，则该提案被选定，该提案里的value就是被选定的value。这样就保证只有一个value会被选定。<br>但是，如果这个唯一的Acceptor宕机了，那么整个系统就无法工作了！</p><p>因此，必须要有多个Acceptor！</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/一个Acceptor.png"></center><h4 id="多个Acceptor"><a href="#多个Acceptor" class="headerlink" title="多个Acceptor"></a>多个Acceptor</h4><p>多个Acceptor的情况如下图。那么，如何保证在多个Proposer和多个Acceptor的情况下选定一个value呢？</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/多个Acceptor.png"></center><p>下面开始寻找解决方案。</p><p>如果我们希望即使只有一个Proposer提出了一个value，该value也最终被选定。<br>那么，就得到下面的约束：</p><blockquote><p>P1：一个Acceptor必须接受它收到的第一个提案。</p></blockquote><p>但是，这又会引出另一个问题：如果每个Proposer分别提出不同的value，发给不同的Acceptor。根据P1，Acceptor分别接受自己收到的value，就导致不同的value被选定。出现了不一致。如下图：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/1.png"></center><p>刚刚是因为『一个提案只要被一个Acceptor接受，则该提案的value就被选定了』才导致了出现上面不一致的问题。因此，我们需要加一个规定：</p><blockquote><p>规定：一个提案被选定需要被半数以上的Acceptor接受</p></blockquote><p>这个规定又暗示了：『一个Acceptor必须能够接受不止一个提案！』不然可能导致最终没有value被选定。比如上图的情况。v1、v2、v3都没有被选定，因为它们都只被一个Acceptor的接受。</p><p>最开始讲的『<strong>提案=value</strong>』已经不能满足需求了，于是重新设计提案，给每个提案加上一个提案编号，表示提案被提出的顺序。令『<strong>提案=提案编号+value</strong>』。</p><p>虽然允许多个提案被选定，但必须保证所有被选定的提案都具有相同的value值。否则又会出现不一致。<br>于是有了下面的约束：</p><blockquote><p>P2：如果某个value为v的提案被选定了，那么每个编号更高的被选定提案的value必须也是v。</p></blockquote><p>一个提案只有被Acceptor接受才可能被选定，因此我们可以把P2约束改写成对Acceptor接受的提案的约束P2a。</p><blockquote><p>P2a：如果某个value为v的提案被选定了，那么每个编号更高的被Acceptor接受的提案的value必须也是v。</p></blockquote><p>只要满足了P2a，就能满足P2。</p><p>但是，考虑如下的情况：假设总的有5个Acceptor。Proposer2提出[M1,V1]的提案，Acceptor2~5（半数以上）均接受了该提案，于是对于Acceptor2~5和Proposer2来讲，它们都认为V1被选定。Acceptor1刚刚从宕机状态恢复过来（之前Acceptor1没有收到过任何提案），此时Proposer1向Acceptor1发送了[M2,V2]的提案（V2≠V1且M2&gt;M1），对于Acceptor1来讲，这是它收到的第一个提案。根据P1（一个Acceptor必须接受它收到的第一个提案。）,Acceptor1必须接受该提案！同时Acceptor1认为V2被选定。这就出现了两个问题：</p><ol><li>Acceptor1认为V2被选定，Acceptor2~5和Proposer2认为V1被选定。出现了不一致。</li><li>V1被选定了，但是编号更高的被Acceptor1接受的提案[M2,V2]的value为V2，且V2≠V1。这就跟P2a（如果某个value为v的提案被选定了，那么每个编号更高的被Acceptor接受的提案的value必须也是v）矛盾了。</li></ol><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/2.png"></center><p>所以我们要对P2a约束进行强化！<br>P2a是对Acceptor接受的提案约束，但其实提案是Proposer提出来的，所有我们可以对Proposer提出的提案进行约束。得到P2b：</p><blockquote><p>P2b：如果某个value为v的提案被选定了，那么之后任何Proposer提出的编号更高的提案的value必须也是v。</p></blockquote><p>由P2b可以推出P2a进而推出P2。</p><p>那么，如何确保在某个value为v的提案被选定后，Proposer提出的编号更高的提案的value都是v呢？<br>只要满足P2c即可：</p><blockquote><p>P2c：对于任意的N和V，如果提案[N, V]被提出，那么存在一个半数以上的Acceptor组成的集合S，满足以下两个条件中的任意一个：</p></blockquote><ul><li>S中每个Acceptor都没有接受过编号小于N的提案。</li><li>S中Acceptor接受过的最大编号的提案的value为V。</li></ul><h4 id="Acceptor生成提案"><a href="#Acceptor生成提案" class="headerlink" title="Acceptor生成提案"></a>Acceptor生成提案</h4><p>为了满足P2b，这里有个比较重要的思想：Proposer生成提案之前，应该先去『<strong>学习</strong>』已经被选定或者可能被选定的value，然后以该value作为自己提出的提案的value。如果没有value被选定，Proposer才可以自己决定value的值。这样才能达成一致。这个学习的阶段是通过一个『<strong>Prepare请求</strong>』实现的。</p><p>于是我们得到了如下的<strong>提案生成算法</strong>：</p><ol><li>Proposer选择一个<strong>新的提案编号N</strong>，然后向<strong>某个Acceptor集合</strong>（半数以上）发送请求，我们将该请求称为<strong>编号为N</strong>的<strong>Prepare请求</strong>。  要求该集合中的每个Acceptor做出如下响应（response）。<br>(a) 向Proposer承诺保证<strong>不再接受</strong>任何编号<strong>小于N的提案</strong>。<br>(b) 如果Acceptor已经接受过提案，那么就向Proposer响应<strong>已经接受过</strong>的编号小于N的<strong>最大编号的提案</strong>。</li><li>如果Proposer收到了<strong>半数以上</strong>的Acceptor的响应，那么它就可以生成编号为N，Value为V的 <strong>提案[N,V]</strong>。这里的V是所有的响应中<strong>编号最大的提案的Value</strong>。如果所有的响应中都没有提案，那 么此时V就可以由Proposer自己选择。<br>生成提案后，Proposer将该提案发送给<strong>半数以上</strong>的Acceptor集合，并期望这些Acceptor能接受该提案。我们称该请求为<strong>Accept请求</strong>。（注意：此时接受Accept请求的Acceptor集合不一定是之前响应Prepare请求的Acceptor集合）</li></ol><h4 id="Acceptor接受提案"><a href="#Acceptor接受提案" class="headerlink" title="Acceptor接受提案"></a>Acceptor接受提案</h4><p>Acceptor可以<strong>忽略任何请求</strong>（包括Prepare请求和Accept请求）而不用担心破坏算法的安全性。因此，我们这里要讨论的是什么时候Acceptor可以响应一个请求。</p><p>我们对Acceptor接受提案给出如下约束：</p><blockquote><p>P1a：一个Acceptor只要尚未响应过任何编号大于N的Prepare请求，那么他就可以接受这个编号为N的提案。</p></blockquote><p>如果Acceptor收到一个编号为N的Prepare请求，在此之前它已经响应过编号大于N的Prepare请求。根据P1a，该Acceptor不可能接受编号为N的提案。因此，该Acceptor可以忽略编号为N的Prepare请求。当然，也可以回复一个error，让Proposer尽早知道自己的提案不会被接受。</p><p>因此，一个Acceptor只需记住：</p><ol><li>已接受的编号最大的提案</li><li>已响应的请求的最大编号。</li></ol><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/3.png"></center><h3 id="Paxos算法描述"><a href="#Paxos算法描述" class="headerlink" title="Paxos算法描述"></a>Paxos算法描述</h3><p>经过上面的推导，我们总结下Paxos算法的流程。<br>Paxos算法分为<strong>两个阶段</strong>。具体如下：</p><ul><li><p>阶段一：<br>(a) Proposer选择一个提<strong>案编号N</strong>，然后向<strong>半数以上</strong>的Acceptor发送编号为N的<strong>Prepare请求</strong>。<br>(b) 如果一个Acceptor收到一个编号为N的Prepare请求，且N大于该Acceptor已经响应过的所有Prepare请求的编号，那么它就会将它已经 <strong>接受过的编号最大的提案（如果有的话）</strong> 作为响应反馈给Proposer，同时该Acceptor承诺<strong>不再接受</strong>任何编号小于N的提案。</p></li><li><p>阶段二：<br>(a) 如果Proposer收到<strong>半数以上</strong>Acceptor对其发出的编号为N的Prepare请求的 <strong>响应</strong> ，那么它就会发送一个针对 <strong>[N,V]提案</strong> 的 <strong>Accept请求</strong> 给半数以上的Acceptor。注意：V就是收到的响应中编号最大的提案的value，如果响应中不包含任何提案，那么V就由Proposer <strong>自己决定</strong>。<br>(b) 如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor <strong>没有</strong> 对编号大于N的Prepare请求做出过响应，它就<strong>接受该提案</strong>。</p></li></ul><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/paxos算法演示.jpg"></center><h3 id="Learner学习被选定的value"><a href="#Learner学习被选定的value" class="headerlink" title="Learner学习被选定的value"></a>Learner学习被选定的value</h3><p>Learner学习（获取）被选定的value有如下三种方案：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Learner学习被选定的value.png"></center><h3 id="如何保证Paxos算法的活性"><a href="#如何保证Paxos算法的活性" class="headerlink" title="如何保证Paxos算法的活性"></a>如何保证Paxos算法的活性</h3><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/如何保证Paxos算法的活性.png"></center><p>通过 <strong>选取主Proposer</strong> ，就可以保证Paxos算法的活性。至此，我们得到一个<strong>既能保证安全性，又能保证活性</strong>的分布式一致性算法——Paxos算法。</p><h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><blockquote><p>这个网站的动画做得很好 <a href="http://thesecretlivesofdata.com/raft/#home" target="_blank" rel="noopener">Raft</a></p></blockquote><h3 id="Raft算法概述"><a href="#Raft算法概述" class="headerlink" title="Raft算法概述"></a>Raft算法概述</h3><p>Raft实现了和Paxos相同的功能，它将一致性分解为多个子问题：Leader选举（Leader election）、日志同步（Log replication）、安全性（Safety）、日志压缩（Log compaction）、成员变更（Membership change）等。</p><p>Raft将系统中的角色分为领导者（Leader）、跟从者（Follower）和候选人（Candidate）：</p><ul><li>Leader：接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志。</li><li>Follower：接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志。</li><li>Candidate：Leader选举过程中的临时角色。</li></ul><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Raft1.jpg"></center><p>Raft要求系统在任意时刻最多只有一个Leader，在网络分裂的情况下可能存在多个leader。正常工作期间只有Leader和Followers。</p><p>Raft算法角色状态转换如下：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Raft算法角色状态转换.jpg"></center><p>Follower只响应其他服务器的请求。如果Follower超时没有收到Leader的消息，它会成为一个Candidate并且开始一次Leader选举。收到大多数服务器投票的Candidate会成为新的Leader。Leader在宕机之前会一直保持Leader的状态。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Raft2.jpg"></center><p>Raft算法将时间分为一个个的任期（term），每一个term的开始都是Leader选举。在成功选举Leader之后，Leader会在整个term内管理整个集群。如果Leader选举失败，该term就会因为没有Leader而结束。</p><h3 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h3><p>Raft 使用心跳（heartbeat）触发Leader选举。当服务器启动时，初始化为Follower。Leader向所有Followers周期性发送heartbeat。如果Follower在选举超时时间内没有收到Leader的heartbeat，就会等待一段随机的时间后发起一次Leader选举。</p><p>Follower将其当前term加一然后转换为Candidate。它首先给自己投票并且给集群中的其他服务器发送 RequestVote RPC （RPC细节参见八、Raft算法总结）。结果有以下三种情况：</p><ul><li>赢得了多数的选票，成功选举为Leader；</li><li>收到了Leader的消息，表示有其它服务器已经抢先当选了Leader；</li><li>没有服务器赢得多数的选票，Leader选举失败，等待选举时间超时后发起下一次选举。</li></ul><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Leader选举过程.jpg"></center><p>选举出Leader后，Leader通过定期向所有Followers发送心跳信息维持其统治。若Follower一段时间未收到Leader的心跳则认为Leader可能已经挂了，再次发起Leader选举过程。<br>Raft保证选举出的Leader上一定具有最新的已提交的日志，这一点将在安全性中说明。</p><h3 id="日志同步"><a href="#日志同步" class="headerlink" title="日志同步"></a>日志同步</h3><p>Leader选出后，就开始接收客户端的请求。Leader把请求作为日志条目（Log entries）加入到它的日志中，然后并行的向其他服务器发起 AppendEntries RPC （RPC细节参见八、Raft算法总结）复制日志条目。当这条日志被复制到大多数服务器上，Leader将这条日志应用到它的状态机并向客户端返回执行结果。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Raft日志同步过程.jpg"></center><p>某些Followers可能没有成功的复制日志，Leader会无限的重试 AppendEntries RPC直到所有的Followers最终存储了所有的日志条目。</p><p>日志由有序编号（log index）的日志条目组成。每个日志条目包含它被创建时的任期号（term），和用于状态机执行的命令。如果一个日志条目被复制到大多数服务器上，就被认为可以提交（commit）了。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Raft日志.jpg"></center><p>Raft日志同步保证如下两点：</p><ul><li>如果不同日志中的两个条目有着相同的索引和任期号，则它们所存储的命令是相同的。</li><li>如果不同日志中的两个条目有着相同的索引和任期号，则它们之前的所有条目都是完全一样的。</li></ul><p>一般情况下，Leader和Followers的日志保持一致，因此 AppendEntries 一致性检查通常不会失败。然而，Leader崩溃可能会导致日志不一致：旧的Leader可能没有完全复制完日志中的所有条目。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Leader和Followers上日志不一致.jpg"></center><p>上图阐述了一些Followers可能和新的Leader日志不同的情况。一个Follower可能会丢失掉Leader上的一些条目，也有可能包含一些Leader没有的条目，也有可能两者都会发生。丢失的或者多出来的条目可能会持续多个任期。</p><p>Leader通过强制Followers复制它的日志来处理日志的不一致，Followers上的不一致的日志会被Leader的日志覆盖。</p><p>Leader为了使Followers的日志同自己的一致，Leader需要找到Followers同它的日志一致的地方，然后覆盖Followers在该位置之后的条目。</p><p>Leader会从后往前试，每次AppendEntries失败后尝试前一个日志条目，直到成功找到每个Follower的日志一致位点，然后向后逐条覆盖Followers在该位置之后的条目。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>Raft增加了如下两条限制以保证安全性：</p><ul><li>拥有最新的已提交的log entry的Follower才有资格成为Leader。</li><li>Leader只能推进commit index来提交当前term的已经复制到大多数服务器上的日志，旧term日志的提交要等到提交当前term的日志来间接提交（log index 小于 commit index的日志被间接提交）。</li></ul><p>之所以要这样，是因为可能会出现已提交的日志又被覆盖的情况：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/已提交的日志被覆盖.jpg"></center><p>在阶段a，term为2，S1是Leader，且S1写入日志（term, index）为(2, 2)，并且日志被同步写入了S2；</p><p>在阶段b，S1离线，触发一次新的选举，此时S5被选为新的Leader，此时系统term为3，且写入了日志（term, index）为（3， 2）;</p><p>S5尚未将日志推送到Followers就离线了，进而触发了一次新的选举，而之前离线的S1经过重新上线后被选中变成Leader，此时系统term为4，此时S1会将自己的日志同步到Followers，按照上图就是将日志（2， 2）同步到了S3，而此时由于该日志已经被同步到了多数节点（S1, S2, S3），因此，此时日志（2，2）可以被提交了。；</p><p>在阶段d，S1又下线了，触发一次选主，而S5有可能被选为新的Leader（这是因为S5可以满足作为主的一切条件：1. term = 5 &gt; 4，2. 最新的日志为（3，2），比大多数节点（如S2/S3/S4的日志都新），然后S5会将自己的日志更新到Followers，于是S2、S3中已经被提交的日志（2，2）被截断了。</p><p>增加上述限制后，即使日志（2，2）已经被大多数节点（S1、S2、S3）确认了，但是它不能被提交，因为它是来自之前term（2）的日志，直到S1在当前term（4）产生的日志（4， 4）被大多数Followers确认，S1方可提交日志（4，4）这条日志，当然，根据Raft定义，（4，4）之前的所有日志也会被提交。此时即使S1再下线，重新选主时S5不可能成为Leader，因为它没有包含大多数节点已经拥有的日志（4，4）。</p><h3 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h3><p>在实际的系统中，不能让日志无限增长，否则系统重启时需要花很长的时间进行回放，从而影响可用性。Raft采用对整个系统进行snapshot来解决，snapshot之前的日志都可以丢弃。</p><p>每个副本独立的对自己的系统状态进行snapshot，并且只能对已经提交的日志记录进行snapshot。<br>当Leader要发给某个日志落后太多的Follower的log entry被丢弃，Leader会将snapshot发给Follower。或者当新加进一台机器时，也会发送snapshot给它。发送snapshot使用InstalledSnapshot RPC（RPC细节参见八、Raft算法总结）。</p><p>做snapshot既不要做的太频繁，否则消耗磁盘带宽， 也不要做的太不频繁，否则一旦节点重启需要回放大量日志，影响可用性。推荐当日志达到某个固定的大小做一次snapshot。</p><p>做一次snapshot可能耗时过长，会影响正常日志同步。可以通过使用copy-on-write技术避免snapshot过程影响正常日志同步。</p><h3 id="成员变更"><a href="#成员变更" class="headerlink" title="成员变更"></a>成员变更</h3><p>成员变更是在集群运行过程中副本发生变化，如增加/减少副本数、节点替换等。</p><p>成员变更也是一个分布式一致性问题，既所有服务器对新成员达成一致。但是成员变更又有其特殊性，因为在成员变更的一致性达成的过程中，参与投票的进程会发生变化。</p><p>如果将成员变更当成一般的一致性问题，直接向Leader发送成员变更请求，Leader复制成员变更日志，达成多数派之后提交，各服务器提交成员变更日志后从旧成员配置（Cold）切换到新成员配置（Cnew）。</p><p>因为各个服务器提交成员变更日志的时刻可能不同，造成各个服务器从旧成员配置（Cold）切换到新成员配置（Cnew）的时刻不同。</p><p>成员变更不能影响服务的可用性，但是成员变更过程的某一时刻，可能出现在Cold和Cnew中同时存在两个不相交的多数派，进而可能选出两个Leader，形成不同的决议，破坏安全性。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/成员变更的某一时刻Cold和Cnew中同时存在两个不相交的多数派.jpg"></center><p>由于成员变更的这一特殊性，成员变更不能当成一般的一致性问题去解决。</p><p>为了解决这一问题，Raft提出了两阶段的成员变更方法。集群先从旧成员配置Cold切换到一个过渡成员配置，称为共同一致（joint consensus），共同一致是旧成员配置Cold和新成员配置Cnew的组合Cold U Cnew，一旦共同一致Cold U Cnew被提交，系统再切换到新成员配置Cnew。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Raft两阶段成员变更.jpg"></center><p>Raft两阶段成员变更过程如下：</p><ol><li>Leader收到成员变更请求从Cold切成Cnew；</li><li>Leader在本地生成一个新的log entry，其内容是Cold∪Cnew，代表当前时刻新旧成员配置共存，写入本地日志，同时将该log entry复制至Cold∪Cnew中的所有副本。在此之后新的日志同步需要保证得到Cold和Cnew两个多数派的确认；</li><li>Follower收到Cold∪Cnew的log entry后更新本地日志，并且此时就以该配置作为自己的成员配置；</li><li>如果Cold和Cnew中的两个多数派确认了Cold U Cnew这条日志，Leader就提交这条log entry；</li><li>接下来Leader生成一条新的log entry，其内容是新成员配置Cnew，同样将该log entry写入本地日志，同时复制到Follower上；</li><li>Follower收到新成员配置Cnew后，将其写入日志，并且从此刻起，就以该配置作为自己的成员配置，并且如果发现自己不在Cnew这个成员配置中会自动退出；</li><li>Leader收到Cnew的多数派确认后，表示成员变更成功，后续的日志只要得到Cnew多数派确认即可。Leader给客户端回复成员变更执行成功。</li></ol><p>两阶段成员变更比较通用且容易理解，但是实现比较复杂，同时两阶段的变更协议也会在一定程度上影响变更过程中的服务可用性，因此我们期望增强成员变更的限制，以简化操作流程。</p><p>两阶段成员变更，之所以分为两个阶段，是因为对Cold与Cnew的关系没有做任何假设，为了避免Cold和Cnew各自形成不相交的多数派选出两个Leader，才引入了两阶段方案。</p><p>如果增强成员变更的限制，假设Cold与Cnew任意的多数派交集不为空，这两个成员配置就无法各自形成多数派，那么成员变更方案就可能简化为一阶段。</p><p>那么如何限制Cold与Cnew，使之任意的多数派交集不为空呢？方法就是每次成员变更只允许增加或删除一个成员。</p><p>可从数学上严格证明，<strong>只要每次只允许增加或删除一个成员，Cold与Cnew不可能形成两个不相交的多数派</strong>。</p><p>一阶段成员变更：</p><ul><li>成员变更限制每次只能增加或删除一个成员（如果要变更多个成员，连续变更多次）。</li><li>成员变更由Leader发起，Cnew得到多数派确认后，返回客户端成员变更成功。</li><li>一次成员变更成功前不允许开始下一次成员变更，因此新任Leader在开始提供服务前要将自己本地保存的最新成员配置重新投票形成多数派确认。</li><li>Leader只要开始同步新成员配置，即可开始使用新的成员配置进行日志同步。</li></ul><h2 id="Raft与Multi-Paxos的异同"><a href="#Raft与Multi-Paxos的异同" class="headerlink" title="Raft与Multi-Paxos的异同"></a>Raft与Multi-Paxos的异同</h2><p>Raft与Multi-Paxos都是基于领导者的一致性算法，乍一看有很多地方相同，下面总结一下Raft与Multi-Paxos的异同。</p><p>Raft与Multi-Paxos中相似的概念：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Raft与Multi-Paxos中相似的概念.jpg"></center><p>Raft与Multi-Paxos的不同：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/Raft与Multi-Paxos的不同.jpg"></center><h1 id="公有链、联盟链、私有链"><a href="#公有链、联盟链、私有链" class="headerlink" title="公有链、联盟链、私有链"></a>公有链、联盟链、私有链</h1><p>按照部署模式可分为公共链、联盟链、私有链三种，对应的是去中心化分布式系统、部分去中心化分布式系统和弱中心分布式系统。</p><h2 id="公有链——对任何人开放，任何人都能参与"><a href="#公有链——对任何人开放，任何人都能参与" class="headerlink" title="公有链——对任何人开放，任何人都能参与"></a>公有链——对任何人开放，任何人都能参与</h2><p>公有链通常也称为非许可链（Permissionless Blockchain），任何人都可以参与区块链数据维护和读取，容易部署应用程序，完全去中心化不受任何机构控制。</p><p>公有链是真正意义上的完全去中心化的区块链，它通过密码学保证交易不可篡改，同时也利用密码学验证以及经济上的激励，在互为陌生的网络环境中建立共识，从而形成去中心化的信用机制。在公有链中的共识机制一般是工作量证明（PoW）和权益证明（PoS） 。</p><h2 id="联盟链——仅对联盟成员开放"><a href="#联盟链——仅对联盟成员开放" class="headerlink" title="联盟链——仅对联盟成员开放"></a>联盟链——仅对联盟成员开放</h2><p>联盟链是一种需要注册许可的区块链，这种区块链也称为许可链（Permissioned Blockchain）。联盟链仅限于联盟成员参与，联盟规模可以大到国与国之间，也可以是不同的机构企业之间。</p><p>区块链上的读写权限、参与记账权限按联盟规则来制定。整个网络由成员机构共同维护，网络接入一般通过成员机构的网关节点接入，共识过程由预先选好的节点控制。因此联盟链一般不采用工作量证明的挖矿机制，而是多采用权益证明（PoS）或PBFT（Practical Byzantine Fault Tolerant）、RAFT等共识算法。<br>和公有链最高每秒完成交易相比，联盟链交易速度更快且交易成本大幅降低。</p><h2 id="私有链——仅行业内部透明，不对外开放"><a href="#私有链——仅行业内部透明，不对外开放" class="headerlink" title="私有链——仅行业内部透明，不对外开放"></a>私有链——仅行业内部透明，不对外开放</h2><p>私有链，仅限于企业、国家机构或者单独个体使用，不完全能够解决信任问题，但是可以改善可审计性。常用于企业内部的数据库管理、审计等，政府的预算和执行，或者政府的行业统计数据等。他们彼此之间需要透明，但没必要对外公众透明。</p><p>私有链的价值主要是提供安全、可追溯、不可篡改、自动执行的运算平台，可以同时防范来自内部和外部对数据的安全攻击，这个在传统的系统是很难做到的。</p><h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><blockquote><p>这篇文章写的很好：<a href="http://www.gjermundbjaanes.com/understanding-ethereum-smart-contracts/" target="_blank" rel="noopener">Understanding Ethereum Smart Contracts</a></p></blockquote><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://zhuanlan.zhihu.com/p/34474913" target="_blank" rel="noopener">共识算法</a><br><a href="https://blog.csdn.net/ggq89/article/details/80188930" target="_blank" rel="noopener">股份授权证明(DPOS)概述</a><br><a href="https://zhuanlan.zhihu.com/p/32052223" target="_blank" rel="noopener">Raft算法详解</a><br><a href="https://www.cnblogs.com/linbingdong/p/6253479.html" target="_blank" rel="noopener">分布式系列文章——Paxos算法原理与推导</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基础的区块链知识，如共识算法等。&lt;/p&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链 面试" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE-%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Golang中阶</title>
    <link href="http://yoursite.com/2020/01/21/Golang%E4%B8%AD%E9%98%B6/"/>
    <id>http://yoursite.com/2020/01/21/Golang中阶/</id>
    <published>2020-01-21T14:05:43.000Z</published>
    <updated>2020-01-25T09:21:46.524Z</updated>
    
    <content type="html"><![CDATA[<p>基础篇学完，现在是中阶篇。</p><a id="more"></a><blockquote><p>参考文档：<br><a href="https://zhuanlan.zhihu.com/p/92634505" target="_blank" rel="noopener">闭包（closure）到底包了什么</a><br><a href="https://blog.csdn.net/netdxy/article/details/72054431" target="_blank" rel="noopener">Golang 闭包的理解</a><br><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/" target="_blank" rel="noopener">深入解析Go</a><br><a href="http://www.topgoer.com/" target="_blank" rel="noopener">Go语言</a></p></blockquote><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="闭包-closure"><a href="#闭包-closure" class="headerlink" title="闭包(closure)"></a>闭包(closure)</h2><p>Go里有函数类型的变量，这样，虽然不能在一个函数里直接声明另一个函数，但是可以在一个函数中声明一个匿名函数类型的变量，此时的匿名函数称为闭包（closure）。<br>闭包是以引用方式捕获外部变量，它不关心这些捕获的变量和常量是否超出了作用域，只要闭包还在使用它，那这些变量就还会存在。</p><p>先看一个demo：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">         i++</span><br><span class="line">         <span class="keyword">return</span> i</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数f返回了一个函数，返回的这个函数就是一个闭包。这个函数中本身是没有定义变量i的，而是引用了它所在的环境（函数f）中的变量i。<br>再看一下效果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c1 := f(<span class="number">0</span>)</span><br><span class="line">c2 := f(<span class="number">0</span>)</span><br><span class="line">c1() <span class="comment">// 打印 1</span></span><br><span class="line">c2() <span class="comment">// 打印 1</span></span><br></pre></td></tr></table></figure></p><p>c1 跟 c2 引用的是不同的环境，在调用 i++ 时修改的不是同一个 i，因此两次的输出都是 1。函数 f 每进入一次，就形成了一个新的环境，对应的闭包中，函数都是同一个函数，环境却是引用不同的环境。</p><h3 id="闭包详解"><a href="#闭包详解" class="headerlink" title="闭包详解"></a>闭包详解</h3><p><strong>闭包是函数和它所引用的环境组合而成的实体</strong>(即：闭包=函数+引用环境)。</p><h4 id="闭包结构体"><a href="#闭包结构体" class="headerlink" title="闭包结构体"></a>闭包结构体</h4><p>回到闭包的实现来，前面说过，闭包是函数和它所引用的环境。那么是不是可以表示为一个结构体呢：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Closure <span class="keyword">struct</span> &#123;</span><br><span class="line">    F <span class="function"><span class="keyword">func</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line">    i *<span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>事实上，Go在底层确实就是这样表示一个闭包的。</p><h4 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h4><p>函数b调用了a的变量，并且函数b作为了a的返回值，又将a()赋值给了变量c，此时的c就是一个闭包<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    b := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := a()</span><br><span class="line">    c() <span class="comment">//1</span></span><br><span class="line">    c() <span class="comment">//2</span></span><br><span class="line">    c() <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">    a() <span class="comment">//不会输出i，不打印任何值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExFunc</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sum := n</span><br><span class="line">    a := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 把匿名函数作为值赋给变量a (Go 不允许函数嵌套, 然而你可以利用匿名函数实现函数嵌套)</span></span><br><span class="line">        fmt.Println(sum + <span class="number">1</span>) <span class="comment">// 调用本函数外的变量</span></span><br><span class="line">    &#125; <span class="comment">// 这里没有()匿名函数不会马上执行</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">    <span class="comment">//  或者直接 return 匿名函数</span></span><br><span class="line">    <span class="comment">//  return func() &#123; //直接在返回处的匿名函数</span></span><br><span class="line">    <span class="comment">//    fmt.Println(sum + 1)</span></span><br><span class="line">    <span class="comment">//  &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myFunc := ExFunc(<span class="number">10</span>)</span><br><span class="line">    myFunc() <span class="comment">// 这里输出11</span></span><br><span class="line"></span><br><span class="line">    myAnotherFunc := ExFunc(<span class="number">20</span>)</span><br><span class="line">    myAnotherFunc() <span class="comment">// 这里输出21</span></span><br><span class="line"></span><br><span class="line">    myFunc()  <span class="comment">// 这里输出11</span></span><br><span class="line">    myAnotherFunc()  <span class="comment">// 这里输出21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例3："><a href="#例3：" class="headerlink" title="例3："></a>例3：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExFunc</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        n++ <span class="comment">// 这里对外部变量加 1</span></span><br><span class="line">        fmt.Println(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myFunc := ExFunc(<span class="number">10</span>)</span><br><span class="line">    myFunc() <span class="comment">// 这里输出 11</span></span><br><span class="line"></span><br><span class="line">    myAnotherFunc := ExFunc(<span class="number">20</span>)</span><br><span class="line">    myAnotherFunc() <span class="comment">// 这里输出 21</span></span><br><span class="line"></span><br><span class="line">    myFunc() <span class="comment">// 这里输出 12</span></span><br><span class="line">    myAnotherFunc() <span class="comment">// 这里输出 22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此得出以下两点<br>1.内函数对外函数 的变量的修改，是对变量的引用<br>2.变量被引用后，它所在的函数结束，这变量也不会马上被烧毁</p><p>闭包函数出现的条件：<br>1.被嵌套的函数引用到非本函数的外部变量，而且这外部变量不是“全局变量”;<br>2.嵌套的函数被独立了出来(被父函数返回或赋值 变成了独立的个体)，而被引用的变量所在的父函数已结束.</p><h3 id="延迟引用"><a href="#延迟引用" class="headerlink" title="延迟引用"></a>延迟引用</h3><p>闭包复制的是原对象指针，这就很容易解释延迟引用现象。</p><h3 id="for-range-和-for-区别"><a href="#for-range-和-for-区别" class="headerlink" title="for range 和 for 区别"></a>for range 和 for 区别</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dummy [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dummy); i++ &#123;</span><br><span class="line">f = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><code>i</code> 自加到 3 才会跳出循环，所以循环结束后 <code>i</code> 最后的值为 3。<br>用 <code>for range</code> 来实现这个例子就不会这样:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dummy [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> dummy &#123;</span><br><span class="line">f = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><p>这是因为 <code>for range</code> 和 <code>for</code> 底层实现上的不同。</p><h1 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h1><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h1 id="并发操作"><a href="#并发操作" class="headerlink" title="并发操作"></a>并发操作</h1><h1 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h1><h1 id="常用标准库"><a href="#常用标准库" class="headerlink" title="常用标准库"></a>常用标准库</h1><h1 id="beego框架"><a href="#beego框架" class="headerlink" title="beego框架"></a>beego框架</h1><p>beego是一个类似tornado的Go应用框架，采用了RESTFul的方式来实现应用框架，是一个超轻量级的框架。<br>bee 工具是一个为了协助快速开发 beego 项目而创建的项目，通过 bee 您可以很容易的进行 beego 项目的创建、热编译、开发、测试、和部署。</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>创建一个新的beego项目过程略去。</p><h3 id="项目路由设置"><a href="#项目路由设置" class="headerlink" title="项目路由设置"></a>项目路由设置</h3><p>前面我们已经创建了 beego 项目，而且我们也看到它已经运行起来了，那么是如何运行起来的呢？让我们从入口文件先分析起来吧：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">"quickstart/routers"</span></span><br><span class="line">    <span class="string">"github.com/astaxie/beego"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    beego.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们看到 main 函数是入口函数，但是我们知道 Go 的执行过程是如下图所示的方式：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/21/Golang%E4%B8%AD%E9%98%B6/init.png"></center><p>这里我们就看到了我们引入了一个包 _ “quickstart/routers”,这个包只引入执行了里面的 init 函数，那么让我们看看这个里面做了什么事情：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"quickstart/controllers"</span></span><br><span class="line">    <span class="string">"github.com/astaxie/beego"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    beego.Router(<span class="string">"/"</span>, &amp;controllers.MainController&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>路由包里面我们看到执行了路由注册 <code>beego.Router</code>, 这个函数的功能是映射 URL 到 controller，第一个参数是 URL (用户请求的地址)，这里我们注册的是 <code>/</code>，也就是我们访问的不带任何参数的 URL，第二个参数是对应的 Controller，也就是我们即将把请求分发到那个控制器来执行相应的逻辑，我们可以执行类似的方式注册如下路由：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beego.Router(<span class="string">"/user"</span>, &amp;controllers.UserController&#123;&#125;)</span><br></pre></td></tr></table></figure></p><p>这样用户就可以通过访问 <code>/user</code> 去执行 <code>UserController</code> 的逻辑。这就是我们所谓的路由，更多更复杂的路由规则请查询beego 的路由设置</p><p>再回来看看 main 函数里面的 beego.Run， beego.Run 执行之后，我们看到的效果好像只是监听服务端口这个过程，但是它内部做了很多事情：</p><ul><li><p>解析配置文件<br>beego 会自动解析在 conf 目录下面的配置文件 app.conf，通过修改配置文件相关的属性，我们可以定义：开启的端口，是否开启 session，应用名称等信息。</p></li><li><p>执行用户的 hookfunc<br>beego 会执行用户注册的 hookfunc，默认的已经存在了注册 mime，用户可以通过函数 AddAPPStartHook 注册自己的启动函数。</p></li><li><p>是否开启 session<br>会根据上面配置文件的分析之后判断是否开启 session，如果开启的话就初始化全局的 session。</p></li><li><p>是否编译模板<br>beego 会在启动的时候根据配置把 views 目录下的所有模板进行预编译，然后存在 map 里面，这样可以有效的提高模板运行的效率，无需进行多次编译。</p></li><li><p>是否开启文档功能<br>根据 EnableDocs 配置判断是否开启内置的文档路由功能</p></li><li><p>是否启动管理模块<br>beego 目前做了一个很酷的模块，应用内监控模块，会在 8088 端口做一个内部监听，我们可以通过这个端口查询到 QPS、CPU、内存、GC、goroutine、thread 等统计信息。</p></li><li><p>监听服务端口<br>这是最后一步也就是我们看到的访问 8080 看到的网页端口，内部其实调用了 ListenAndServe，充分利用了 goroutine 的优势</p></li></ul><p>一旦 run 起来之后，我们的服务就监听在两个端口了，一个服务端口 8080 作为对外服务，另一个 8088 端口实行对内监控。</p><p>通过这个代码的分析我们了解了 beego 运行起来的过程，以及内部的一些机制。接下来让我们去剥离 Controller 如何来处理逻辑的。</p><h3 id="Controller运行机制"><a href="#Controller运行机制" class="headerlink" title="Controller运行机制"></a>Controller运行机制</h3><p>前面我们了解了如何把用户的请求分发到控制器，这小节我们就介绍大家如何来写控制器，首先我们还是从源码分析入手：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controllers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"github.com/astaxie/beego"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MainController <span class="keyword">struct</span> &#123;</span><br><span class="line">        beego.Controller</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MainController)</span> <span class="title">Get</span><span class="params">()</span></span> &#123;</span><br><span class="line">        this.Data[<span class="string">"Website"</span>] = <span class="string">"beego.me"</span></span><br><span class="line">        this.Data[<span class="string">"Email"</span>] = <span class="string">"astaxie@gmail.com"</span></span><br><span class="line">        this.TplName = <span class="string">"index.tpl"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码显示首先我们声明了一个控制器 <code>MainController</code>，这个控制器里面内嵌了 <code>beego.Controller</code>，这就是 Go 的嵌入方式，也就是 <code>MainController</code> 自动拥有了所有 <code>beego.Controller</code> 的方法。</p><p>而 <code>beego.Controller</code> 拥有很多方法，其中包括 <code>Init</code>、<code>Prepare</code>、<code>Post</code>、<code>Get</code>、<code>Delete</code>、<code>Head</code> 等方法。我们可以通过重写的方式来实现这些方法，而我们上面的代码就是重写了 <code>Get</code> 方法。</p><p>我们先前介绍过 beego 是一个 RESTful 的框架，所以我们的请求默认是执行对应 <code>req.Method</code> 的方法。例如浏览器的是 <code>GET</code> 请求，那么默认就会执行 <code>MainController</code> 下的 <code>Get</code> 方法。这样我们上面的 Get 方法就会被执行到，这样就进入了我们的逻辑处理。（用户可以改变这个行为，通过注册自定义的函数名)</p><p>里面的代码是需要执行的逻辑，这里只是简单的输出数据，我们可以通过各种方式获取数据，然后赋值到 <code>this.Data</code> 中，这是一个用来存储输出数据的 map，可以赋值任意类型的值，这里我们只是简单举例输出两个字符串。</p><p>最后一个就是需要去渲染的模板，<code>this.TplName</code> 就是需要渲染的模板，这里指定了 <code>index.tpl</code>，如果用户不设置该参数，那么默认会去到模板目录的 <code>Controller/&lt;方法名&gt;.tpl</code> 查找，例如上面的方法会去 <code>maincontroller/get.tpl</code> (<strong>文件、文件夹必须小写</strong>)。</p><p>用户设置了模板之后系统会自动的调用 <code>Render</code> 函数（这个函数是在 <code>beego.Controller</code> 中实现的），所以无需用户自己来调用渲染。</p><p>当然也可以不使用模版，直接用<code>this.Ctx.WriteString</code> 输出字符串，如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MainController)</span> <span class="title">Get</span><span class="params">()</span></span> &#123;</span><br><span class="line">        this.Ctx.WriteString(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="model逻辑"><a href="#model逻辑" class="headerlink" title="model逻辑"></a>model逻辑</h3><p>我们知道 Web 应用中我们用的最多的就是数据库操作，而 model 层一般用来做这些操作，我们的 <code>bee new</code> 例子不存在 Model 的演示，但是 <code>bee api</code> 应用中存在 model 的应用。说的简单一点，如果您的应用足够简单，那么 Controller 可以处理一切的逻辑，如果您的逻辑里面存在着可以复用的东西，那么就抽取出来变成一个模块。因此 Model 就是逐步抽象的过程，一般我们会在 Model 里面处理一些数据读取，如下是一个日志分析应用中的代码片段：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"loggo/utils"</span></span><br><span class="line">    <span class="string">"path/filepath"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    NotPV []<span class="keyword">string</span> = []<span class="keyword">string</span>&#123;<span class="string">"css"</span>, <span class="string">"js"</span>, <span class="string">"class"</span>, <span class="string">"gif"</span>, <span class="string">"jpg"</span>, <span class="string">"jpeg"</span>, <span class="string">"png"</span>, <span class="string">"bmp"</span>, <span class="string">"ico"</span>, <span class="string">"rss"</span>, <span class="string">"xml"</span>, <span class="string">"swf"</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> big = <span class="number">0xFFFFFF</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LogPV</span><span class="params">(urls <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    ext := filepath.Ext(urls)</span><br><span class="line">    <span class="keyword">if</span> ext == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> NotPV &#123;</span><br><span class="line">        <span class="keyword">if</span> v == strings.ToLower(ext) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以如果您的应用足够简单，那么就不需要 Model 了；如果你的模块开始多了，需要复用，需要逻辑分离了，那么 Model 是必不可少的。接下来我们将分析如何编写 View 层的东西。</p><h3 id="View编写"><a href="#View编写" class="headerlink" title="View编写"></a>View编写</h3><p>在前面编写 Controller 的时候，我们在 Get 里面写过这样的语句 <code>this.TplName = &quot;index.tpl&quot;</code>，设置显示的模板文件，默认支持 <code>tpl</code> 和 <code>html</code> 的后缀名，如果想设置其他后缀你可以调用 <code>beego.AddTemplateExt</code> 接口设置，那么模板如何来显示相应的数据呢？beego 采用了 Go 语言默认的模板引擎，所以和 Go 的模板语法一样，Go 模板的详细使用方法请参考《Go Web 编程》模板使用指南</p><p>我们看看快速入门里面的代码（去掉了 css 样式）：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Beego<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"hero-unit"</span> <span class="attr">style</span>=<span class="string">"background-color:#A9F16C"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hero-text"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome to Beego!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"description"</span>&gt;</span></span><br><span class="line">                            Beego is a simple &amp; powerful Go web framework which is inspired by tornado and sinatra.</span><br><span class="line">                            <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">                            Official website: <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://&#123;&#123;.Website&#125;&#125;"</span>&gt;</span>&#123;&#123;.Website&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">                            Contact me: &#123;&#123;.Email&#125;&#125;</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>我们在 Controller 里面把数据赋值给了 data（map 类型），然后我们在模板中就直接通过 key 访问 <code>.Website</code> 和 <code>.Email</code> 。这样就做到了数据的输出。接下来我们讲解如何让静态文件输出。</p><h3 id="静态文件处理"><a href="#静态文件处理" class="headerlink" title="静态文件处理"></a>静态文件处理</h3><p>前面我们介绍了如何输出静态页面，但是我们的网页往往包含了很多的静态文件，包括图片、JS、CSS 等，刚才创建的应用里面就创建了如下目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── static</span><br><span class="line">    │   ├── css</span><br><span class="line">    │   ├── img</span><br><span class="line">    │   └── js</span><br></pre></td></tr></table></figure></p><p>beego 默认注册了 static 目录为静态处理的目录，注册样式：URL 前缀和映射的目录（在/main.go文件中beego.Run()之前加入）：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StaticDir[<span class="string">"/static"</span>] = <span class="string">"static"</span></span><br></pre></td></tr></table></figure></p><p>用户可以设置多个静态文件处理目录，例如你有多个文件下载目录 download1、download2，你可以这样映射（在 /main.go 文件中 beego.Run() 之前加入）：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beego.SetStaticPath(<span class="string">"/down1"</span>, <span class="string">"download1"</span>)</span><br><span class="line">beego.SetStaticPath(<span class="string">"/down2"</span>, <span class="string">"download2"</span>)</span><br></pre></td></tr></table></figure></p><p>这样用户访问 URL <code>http://localhost:8080/down1/123.txt</code> 则会请求 download1 目录下的 123.txt 文件。</p><h2 id="beego的MVC架构介绍"><a href="#beego的MVC架构介绍" class="headerlink" title="beego的MVC架构介绍"></a>beego的MVC架构介绍</h2><h3 id="controller设计"><a href="#controller设计" class="headerlink" title="controller设计"></a>controller设计</h3><h4 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h4><p>beego 目前支持 INI、XML、JSON、YAML 格式的配置文件解析，但是默认采用了 INI 格式解析，用户可以通过简单的配置就可以获得很大的灵活性。</p><h5 id="默认配置解析"><a href="#默认配置解析" class="headerlink" title="默认配置解析"></a>默认配置解析</h5><h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h1 id="插件库"><a href="#插件库" class="headerlink" title="插件库"></a>插件库</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基础篇学完，现在是中阶篇。&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>C语言指针</title>
    <link href="http://yoursite.com/2020/01/17/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2020/01/17/C语言指针/</id>
    <published>2020-01-17T11:34:26.000Z</published>
    <updated>2020-01-21T14:00:57.628Z</updated>
    
    <content type="html"><![CDATA[<p>想要理解指针其实很简单，画张图就行了。</p><blockquote><p>不只是指针，只要是不会的画图就行～</p></blockquote><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a =<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> *p1 = &amp;a;</span><br><span class="line"><span class="keyword">int</span> **p2 = &amp;p1;</span><br><span class="line"><span class="keyword">int</span> ***p3 = &amp;p2;</span><br></pre></td></tr></table></figure><p>把代码转换成图片：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/17/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/9.jpg"></center><p>看这样，是不是就很容易理解了？所以遇到指针弄不懂的话就画张图，就是这么简单！</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h2><p>在赋值运算符“=”左边的就是左值，在赋值运算符“=”后边的就是右值。</p><p><font color="#dd0000">从一个左值中必定可以解析出对应对象的地址</font>，除非该对象是位字段（bit-field）或者被声明为寄存器存储类。生成左值的运算符包括下标运算符（subscript operator）<code>[]</code>和间接运算符（indirection operator）<code>*</code>，如下表所示（如果 array 已被声明为数组，而 ptr 被声明为指针变量）。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/17/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/1.png"></center><p>可修改的左值，其类型不可以被声明为限定符 const，并且可修改的左值不能是数组类型。如果可修改的左值所表示的对象是结构或联合类型，那么它的元素都不可以被声明（不管是直接地或间接地）为具有限定符 const 的类型。</p><h3 id="变量做左值和右值的区别"><a href="#变量做左值和右值的区别" class="headerlink" title="变量做左值和右值的区别"></a>变量做左值和右值的区别</h3><p><code>x = 2;</code> :这里x为整形变量，这里作为左值，代表的是一块内存单元，表示的是地址。<br><code>x = y;</code> :现在看变量做右值情况，y做右值，这里呢就不再表示地址，而是代表该内存单元上的值，然后赋给x。</p><h3 id="常量做左值和右值的区别"><a href="#常量做左值和右值的区别" class="headerlink" title="常量做左值和右值的区别"></a>常量做左值和右值的区别</h3><p><code>x = 2;</code> :这里2做右值， 2是一个常量，没有任何疑问。<br><code>1 = 2;</code> :这里我们看左值，是1是常量，这里就会有问题了，编译会报错，因为常量不可被修改、不可以被赋值。</p><h3 id="数组名做左值和右值的区别"><a href="#数组名做左值和右值的区别" class="headerlink" title="数组名做左值和右值的区别"></a>数组名做左值和右值的区别</h3><p>有字符数组<code>char a[100];</code><br>当a做右值时候，我们可以把它赋给<code>char *</code>类型的指针，用来指向这个数组，这种情况下数组名做右值代表该数组首元素的首地址，是常量，是完全可以的。<br><strong>数组变量名就代表数组的首地址（也就是数组的地址）</strong>。数组名无论右值和还是左值，都代表是地址，是常量，因此它不可以做左值，因为常量不可被修改。</p><h3 id="字符串常量做右值"><a href="#字符串常量做右值" class="headerlink" title="字符串常量做右值"></a>字符串常量做右值</h3><p>字符串常量是用双引号括起来的字符串，既然也是常量，也理所当然不可以做左值。<br>做右值时，会表示该字符串在内存中存储位置的首地址,就是<code>char *  p = “dotcpp.com”;</code>用法的原因。</p><h2 id="变量和内存"><a href="#变量和内存" class="headerlink" title="变量和内存"></a>变量和内存</h2><p>下图是内存地址空间的分布情况。内存由低地址向高地址方向增长，栈则相反。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/17/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/内存地址空间.png"></center><h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><p>用<code>int num = 97</code>这个局部变量来分析变量在内存中的存储模型。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/17/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/2.png"></center><p>已知：num的类型是int，占用了4个字节的内存空间，其值是97，地址是<code>0028FF40</code>。我们从以下几个方面去分析。<br>1、内存的数据<br>内存的数据就是变量的值对应的二进制，一切都是二进制。97的二进制是 : <code>00000000 00000000 00000000 0110000</code> , 但使用的小端模式存储时，低位数据存放在低地址，所以图中画的时候是倒过来的。</p><blockquote><p>小端序就是先存小的(低地址)，大端序就是先存大的(高地址)</p></blockquote><p>2、内存数据的类型<br>内存的数据类型决定了这个数据占用的字节数，以及计算机将如何解释这些字节。num的类型是int，因此将被解释为 一个整数。<br>3、内存数据的名称<br>内存的名称就是变量名。实质上，内存数据都是以地址来标识的，根本没有内存的名称这个说法，这只是高级语言提供的抽象机制 ，方便我们操作内存数据。而且在C语言中，并不是所有的内存数据都有名称，例如使用<code>malloc</code>申请的堆内存就没有。<br>4、内存数据的地址<br>如果一个类型占用的字节数大于1，则其变量的地址就是地址值最小的那个字节的地址。因此num的地址是 <code>0028FF40</code>。 内存的地址用于标识这个内存块。</p><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>如果2个程序单元（例如2个函数）是通过拷贝 他们所共享的数据的 指针来工作的，这就是浅拷贝，因为真正要访问的数据并没有被拷贝。如果被访问的数据被拷贝了，在每个单元中都有自己的一份，对目标数据的操作相互 不受影响，则叫做深拷贝。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/17/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/10.png"></center><h1 id="为什么需要指针"><a href="#为什么需要指针" class="headerlink" title="为什么需要指针"></a>为什么需要指针</h1><p>指针解决了一些编程中基本的问题。<br>第一，指针的使用使得不同区域的代码可以轻易的共享内存数据，这样可以使程序更为快速高效。<br>第二，指针使得一些复杂的链接性的数据结构的构建成为可能，如链表，链式二叉树等等。<br>第三，有些操作必须使用指针。如操作申请的堆内存。还有：C语言中的一切函数调用中，值传递都是“按值传递(pass by value)”的，如果我们要在函数中修改被传递过来的对象，就必须通过这个对象的指针来完成。</p><h1 id="p-p以及-amp-p"><a href="#p-p以及-amp-p" class="headerlink" title="*p,p以及&amp;p"></a>*p,p以及&amp;p</h1><p><strong>指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。</strong><br>在讲指针之前，需要先明白各个符号的含义。以下面的情况说明：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;a; <span class="comment">//声明了一个指针变量p，取a的地址给p，那么p就存放了a的存储地址</span></span><br><span class="line"><span class="comment">//可以把int* p = &amp;a拆成两步，第一步是int* p,声明一个指针；第二步是p=&amp;a,取a的地址给指针变量p，&amp;a的运算结果是一个指针</span></span><br></pre></td></tr></table></figure></p><p>结论：<br><strong>*p</strong>：<code>*</code>是间接寻址运算符，当它作用与指针时将访问指针所指向的对象。<code>*p</code>代表指针变量p指向的变量a的存储内容，<code>*p = 5;</code><br><strong>p</strong>：p是一个指针，该指针变量的存储内容是一个地址，因为p指向a，所以p的存储内容（存储空间的值）就是系统为变量a分配的存储地址；<br><strong>&amp;p</strong>：是对指针变量p进行取地址的操作，返回的是p在内存中的地址。</p><h2 id="定义指针变量"><a href="#定义指针变量" class="headerlink" title="定义指针变量"></a>定义指针变量</h2><p>C语言中，定义变量时，在变量名 前 写一个 <code>*</code> 星号，这个变量就变成了对应变量类型的指针变量。必要时要加<code>()</code> 来避免优先级的问题。</p><h2 id="取地址"><a href="#取地址" class="headerlink" title="取地址"></a>取地址</h2><p>既然有了指针变量，那就得让他保存其它变量的地址，使用<code>&amp;</code> 运算符取得一个变量的地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">//-----------------------</span></span><br><span class="line">    <span class="keyword">int</span>* p_first = arr;</span><br><span class="line">    <span class="keyword">int</span> (*fp_add)(<span class="keyword">int</span> ,<span class="keyword">int</span> )  =  add;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* msg = <span class="string">"Hello world"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>特殊的情况，他们并不一定需要使用<code>&amp;</code>取地址：<br>1.数组名的值就是这个数组的第一个元素的地址。<br>2.函数名的值就是这个函数的地址。<br>3.字符串字面值常量作为右值时，就是这个字符串对应的字符数组的名称,也就是这个字符串在内存中的地址。</p></blockquote><h2 id="解地址"><a href="#解地址" class="headerlink" title="解地址"></a>解地址</h2><p>我们需要一个数据的指针变量干什么？当然使用通过它来操作（读/写）它指向的数据啦。对一个指针解地址，就可以取到这个内存数据，解地址 的写法，就是在指针的前面加一个<code>*</code>号。<br>解指针的实质是：从指针指向的内存块中取出这个内存数据。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> age = <span class="number">19</span>;</span><br><span class="line"><span class="keyword">int</span>*p_age = &amp;age;</span><br><span class="line">*p_age = <span class="number">20</span>;  <span class="comment">//通过指针修改指向的内存数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"age = %d\n"</span>, *p_age);   <span class="comment">//通过指针读取指向的内存数据</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"address of age is = %p\n"</span>, &amp;age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"address of p_age is = %p\n"</span>, &amp;p_age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"age = %d\n"</span>, age);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><div align="center">    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);    margin-left:-0px;" src="/2020/01/17/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/5.png"></div><h2 id="指针变量和指向关系"><a href="#指针变量和指向关系" class="headerlink" title="指针变量和指向关系"></a>指针变量和指向关系</h2><p>用来保存指针的变量，就是指针变量。如果指针变量p1保存了变量 num的地址，则就说：p1指向了变量num，也可以说p1指向了num所在的内存块。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/17/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/3.png"></center><p>上图中，指针变量p1指向了num所在的内存块 ，即从地址<code>0028FF40</code>开始的4个byte 的内存块。</p><h2 id="指针之间的赋值"><a href="#指针之间的赋值" class="headerlink" title="指针之间的赋值"></a>指针之间的赋值</h2><p>指针赋值和int变量赋值一样，就是将地址的值拷贝给另外一个。指针之间的赋值是一种浅拷贝，是在多个编程单元之间共享内存数据的高效的方法。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p1  = &amp; num;</span><br><span class="line"><span class="keyword">int</span>* p3 = p1;</span><br><span class="line"><span class="comment">//通过指针 p1 、 p3 都可以对内存数据num进行读写，如果2个函数分别使用了p1 和p3，那么这2个函数就共享了数据num。</span></span><br></pre></td></tr></table></figure></p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/17/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/4.png"></center><p>上图两个指针指向了同一个地址。</p><h2 id="例1-1"><a href="#例1-1" class="headerlink" title="例1"></a>例1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">12</span>; <span class="keyword">int</span> b; <span class="keyword">int</span> *p; <span class="keyword">int</span> **ptr;</span><br><span class="line">p=&amp;a; <span class="comment">//&amp;a 的结果是一个指针，类型是int*，指向的类型是</span></span><br><span class="line"><span class="comment">//int，指向的地址是a 的地址。</span></span><br><span class="line">*p=<span class="number">24</span>; <span class="comment">//*p 的结果，在这里它的类型是int，它所占用的地址是</span></span><br><span class="line"><span class="comment">//p 所指向的地址，显然，*p 就是变量a。</span></span><br><span class="line">ptr=&amp;p; <span class="comment">//&amp;p 的结果是个指针，该指针的类型是p 的类型加个*，</span></span><br><span class="line"><span class="comment">//在这里是int **。该指针所指向的类型是p 的类型，这</span></span><br><span class="line"><span class="comment">//里是int*。该指针所指向的地址就是指针p 自己的地址。</span></span><br><span class="line">*ptr=&amp;b; <span class="comment">//*ptr 是个指针，&amp;b 的结果也是个指针，且这两个指针</span></span><br><span class="line"><span class="comment">//的类型和所指向的类型是一样的，所以用&amp;b 来给*ptr 赋</span></span><br><span class="line"><span class="comment">//值就是毫无问题的了。</span></span><br><span class="line">**ptr=<span class="number">34</span>; <span class="comment">//*ptr 的结果是ptr 所指向的东西，在这里是一个指针，</span></span><br><span class="line"><span class="comment">//对这个指针再做一次*运算，结果是一个int 类型的变量。</span></span><br></pre></td></tr></table></figure><h1 id="指针的声明"><a href="#指针的声明" class="headerlink" title="指针的声明"></a>指针的声明</h1><p>指针其实就是一个变量，指针的声明方式与一般的变量声明方式没太大区别：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> p; <span class="comment">//这是一个普通的整型变量</span></span><br><span class="line"><span class="keyword">int</span> *p; <span class="comment">//首先从P 处开始,先与*结合,所以P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针</span></span><br><span class="line"><span class="keyword">int</span> p[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组</span></span><br><span class="line"><span class="keyword">int</span> *p[<span class="number">3</span>]; <span class="comment">//首因为[]的优先级比*高，所以P是一个数组，数组里的元素是指针类型，因此P是一个由返回整型数据的指针所组成的数组</span></span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与"()"这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P是一个指针，该指针指向由整型数据组成的数组</span></span><br><span class="line"><span class="keyword">int</span> **p; <span class="comment">//首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">//从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据</span></span><br><span class="line"><span class="keyword">int</span> (*p)(<span class="keyword">int</span>); <span class="comment">//从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指针，该指针指向有一个整型参数且返回类型为整型的函数</span></span><br><span class="line"><span class="keyword">int</span> *(*p(<span class="keyword">int</span>))[<span class="number">3</span>]; <span class="comment">//从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.</span></span><br></pre></td></tr></table></figure></p><p>声明一个指针变量并不会自动分配任何内存。<strong>在对指针进行间接访问之前，指针必须进行初始化</strong>：或是使他指向现有的内存，或者给他动态分配内存，否则我们并不知道指针指向哪儿，这将是一个很严重的问题。初始化操作如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 方法1：使指针指向现有的内存 */</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;x;　　<span class="comment">//指针p被初始化，指向变量x ，其中取地址符&amp;用于产生操作数内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方法2：动态分配内存给指针 */</span></span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">10</span>); <span class="comment">//malloc函数用于动态分配内存</span></span><br><span class="line"><span class="built_in">free</span>(p);　<span class="comment">// free函数用于释放一块已经分配的内存，常与malloc函数一起使用，要使用这两个函数需要头文件stdlib.h</span></span><br><span class="line">p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p><p>指针的初始化实际上就是给指针一个合法的地址，让程序能够清楚地知道指针指向哪儿。</p><h1 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h1><p>指针可以指向一份普通类型的数据，例如 int、double、char 等，也可以指向一份指针类型的数据，例如 int <em>、double </em>、char <em> 等。<br>如果一个指针指向的是另外一个指针，我们就称它为<em>*二级指针</em></em>，或者指向指针的指针。<br>假设有一个 int 类型的变量 a，p1是指向 a 的指针变量，p2 又是指向 p1 的指针变量，它们的关系如下图所示：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/17/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/8.jpg"></center><p>将这种关系转换为C语言代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a =<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> *p1 = &amp;a;</span><br><span class="line"><span class="keyword">int</span> **p2 = &amp;p1;</span><br></pre></td></tr></table></figure></p><p><strong>想要获取指针指向的数据时，一级指针加一个<code>*</code>，二级指针加两个<code>*</code>，三级指针加三个<code>*</code>，以此类推。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a =<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> *p1 = &amp;a;</span><br><span class="line">    <span class="keyword">int</span> **p2 = &amp;p1;</span><br><span class="line">    <span class="keyword">int</span> ***p3 = &amp;p2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d, %d, %d, %d\n"</span>, a, *p1, **p2, ***p3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;p2 = %#X, p3 = %#X\n"</span>, &amp;p2, p3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;p1 = %#X, p2 = %#X, *p3 = %#X\n"</span>, &amp;p1, p2, *p3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" &amp;a = %#X, p1 = %#X, *p2 = %#X, **p3 = %#X\n"</span>, &amp;a, p1, *p2, **p3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span></span><br><span class="line">&amp;p2 = <span class="number">0X28FF3C</span>, p3 = <span class="number">0X28FF3C</span></span><br><span class="line">&amp;p1 = <span class="number">0X28FF40</span>, p2 = <span class="number">0X28FF40</span>, *p3 = <span class="number">0X28FF40</span></span><br><span class="line">&amp;a = <span class="number">0X28FF44</span>, p1 = <span class="number">0X28FF44</span>, *p2 = <span class="number">0X28FF44</span>, **p3 = <span class="number">0X28FF44</span></span><br></pre></td></tr></table></figure></p><p>以三级指针 p3 为例来分析上面的代码。<code>***p3</code>等价于<code>*(*(*p3))</code>。<code>*p3</code> 得到的是 p2 的值，也即 p1 的地址；<code>*(*p3)</code> 得到的是 p1 的值，也即 a 的地址；经过三次“取值”操作后，<code>*(*(*p3))</code> 得到的才是 a 的值。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/17/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/9.jpg"></center><h1 id="细说指针"><a href="#细说指针" class="headerlink" title="细说指针"></a>细说指针</h1><p>指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容：指针的类型、指针所指向的类型、指针的值或者叫指针所指向的内存区、指针本身所占据的内存区。<br>先声明几个指针放着做例子：<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)<span class="keyword">int</span>*ptr;</span><br><span class="line">(<span class="number">2</span>)<span class="keyword">char</span>*ptr;</span><br><span class="line">(<span class="number">3</span>)<span class="keyword">int</span>**ptr;</span><br><span class="line">(<span class="number">4</span>)<span class="keyword">int</span>(*ptr)[<span class="number">3</span>];</span><br><span class="line">(<span class="number">5</span>)<span class="keyword">int</span>*(*ptr)[<span class="number">4</span>];</span><br></pre></td></tr></table></figure></p><h2 id="指针的类型"><a href="#指针的类型" class="headerlink" title="指针的类型"></a>指针的类型</h2><p>从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)<span class="keyword">int</span>*ptr;<span class="comment">//指针的类型是int*</span></span><br><span class="line">(<span class="number">2</span>)<span class="keyword">char</span>*ptr;<span class="comment">//指针的类型是char*</span></span><br><span class="line">(<span class="number">3</span>)<span class="keyword">int</span>**ptr;<span class="comment">//指针的类型是int**</span></span><br><span class="line">(<span class="number">4</span>)<span class="keyword">int</span>(*ptr)[<span class="number">3</span>];<span class="comment">//指针的类型是int(*)[3]</span></span><br><span class="line">(<span class="number">5</span>)<span class="keyword">int</span>*(*ptr)[<span class="number">4</span>];<span class="comment">//指针的类型是int*(*)[4]</span></span><br></pre></td></tr></table></figure></p><h2 id="指针所指向的类型"><a href="#指针所指向的类型" class="headerlink" title="指针所指向的类型"></a>指针所指向的类型</h2><p>当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。<br>从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)<span class="keyword">int</span>*ptr; <span class="comment">//指针所指向的类型是int</span></span><br><span class="line">(<span class="number">2</span>)<span class="keyword">char</span>*ptr; <span class="comment">//指针所指向的的类型是char</span></span><br><span class="line">(<span class="number">3</span>)<span class="keyword">int</span>**ptr; <span class="comment">//指针所指向的的类型是int*</span></span><br><span class="line">(<span class="number">4</span>)<span class="keyword">int</span>(*ptr)[<span class="number">3</span>]; <span class="comment">//指针所指向的的类型是int()[3]</span></span><br><span class="line">(<span class="number">5</span>)<span class="keyword">int</span>*(*ptr)[<span class="number">4</span>]; <span class="comment">//指针所指向的的类型是int*()[4]</span></span><br></pre></td></tr></table></figure></p><p>指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。把与指针搅和在一起的”类型”这个概念分成”指针的类型”和”指针所指向的类型”两个概念，是精通指针的关键点之一。</p><h2 id="指针的值或者叫指针所指向的内存区"><a href="#指针的值或者叫指针所指向的内存区" class="headerlink" title="指针的值或者叫指针所指向的内存区"></a>指针的值或者叫指针所指向的内存区</h2><p>指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。<br>指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为si zeof(指针所指向的类型)的一片内存区。<br>我们说一个指针的值是XX，就相当于说该指针指向了以XX 为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。<br><strong>以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？</strong></p><h2 id="指针本身所占据的内存区"><a href="#指针本身所占据的内存区" class="headerlink" title="指针本身所占据的内存区"></a>指针本身所占据的内存区</h2><p>指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在32 位平台里，指针本身占据了4 个字节的长度。指针本身占据的内存这个概念在判断一个指针表达式是否是左值时很有用。</p><h1 id="指针的算术运算"><a href="#指针的算术运算" class="headerlink" title="指针的算术运算"></a>指针的算术运算</h1><p>C 指针的算术运算只限于两种形式：</p><h2 id="指针-整数-："><a href="#指针-整数-：" class="headerlink" title="指针 +/- 整数 ："></a>指针 +/- 整数 ：</h2><p>可以对指针变量 p 进行 p++、p—、p + i 等操作，所得结果也是一个指针，只是指针所指向的内存地址相比于 p 所指的内存地址前进或者后退了 i 个操作数。用一张图来说明一下：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/17/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/6.png"></center><p>在上图中，10000000等是内存地址的十六进制表示（数值是假定的），p 是一个 int 类型的指针，指向内存地址 0x10000008 处。则 p++ 将指向与 p 相邻的下一个内存地址，由于 int 型数据占 4 个字节，因此 p++ 所指的内存地址为 1000000b。其余类推。不过要注意的是，这种运算并不会改变指针变量 p 自身的地址，只是改变了它所指向的地址。</p><h3 id="例1-2"><a href="#例1-2" class="headerlink" title="例1"></a>例1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr[<span class="number">20</span>]=<span class="string">"the_example"</span>;</span><br><span class="line">    <span class="keyword">int</span> *ptr=(<span class="keyword">int</span> *)arr; <span class="comment">//强制类型转换并不会改变a 的类型</span></span><br><span class="line">    ptr++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,*ptr); <span class="comment">//输出: arr[4] - 'e'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上例中，指针ptr 的类型是<code>int*</code>，它指向的类型是int，它被初始化为指向数组arr。接下来指针ptr被加了1，编译器是这样处理的：它把指针ptr 的值加上了<code>sizeof(int)</code>，在32位程序中，是被加上了4。由于地址是用字节做单位的，故ptr 所指向的地址由原来的数组arr的地址向高地址方向增加了4个字节。由于char 类型的长度是一个字节，所以，原来ptr是指向数组arr的第0个字节开始的四个字节，此时指向了数组a中从第4个字节开始的四个字节。</p><h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><p>我们可以用一个指针和一个循环来遍历一个数组，看例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">20</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *ptr=<span class="built_in">array</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    (*ptr)++;</span><br><span class="line">    ptr++；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子将整型数组中各个单元的值加1。由于每次循环都将指针ptr加1 个单元，所以每次循环都能访问数组的下一个单元。</p><h3 id="例3-一个误区"><a href="#例3-一个误区" class="headerlink" title="例3(一个误区)"></a>例3(一个误区)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">20</span>] = <span class="string">"You_are_a_girl"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = a;  <span class="comment">//指针p指向a</span></span><br><span class="line"><span class="keyword">char</span> **ptr = &amp;p; <span class="comment">//char类型指针*ptr指向指针p</span></span><br><span class="line"><span class="comment">//该步骤可分为两步，char**ptr,声明一个指针ptr指向了一个char类型的指针；然后ptr=&amp;p,将p的地址赋值给ptr</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;a = %p\n"</span>, &amp;a);<span class="comment">//输出数组a的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p = %p\n"</span>, p); <span class="comment">//输出指针p所指向的地址，即a的地址(因为指针所存放的值是一个地址)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;p = %p\n"</span>, &amp;p); <span class="comment">//输出指针p在内存中的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p = %c\n"</span>, *p); <span class="comment">//输出Y。*p就是访问指针p指向的对象a，打印第一个字符就是Y,可以用*p++来访问下一个元素(*优先级大于++)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ptr = %p\n"</span>, ptr); <span class="comment">//输出指针ptr存放的内容，即&amp;p</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;ptr = %p\n"</span>, &amp;ptr); <span class="comment">//输出指针ptr在内存中的地址，即ptr本身的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;*ptr = %p\n"</span>, &amp;*ptr); <span class="comment">//输出指针ptr指向的对象的地址，即&amp;p</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*ptr = %p\n"</span>, *ptr); <span class="comment">//输出指针ptr指向的对象，即p存放的值，也是a的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"**ptr = %c\n"</span>, **ptr); <span class="comment">//指针*ptr指向指针p，那么**ptr就等于*p，则输出a的第一个字符Y</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;**ptr = %p\n"</span>, &amp;**ptr); <span class="comment">//输出a的地址</span></span><br><span class="line"><span class="comment">//**ptr++;   这样是非法的</span></span><br><span class="line"><span class="comment">//*(*ptr)++;  //等于*p++</span></span><br><span class="line"><span class="comment">//printf("a = %c\n", **ptr); //打印输出第二个字符o，</span></span><br><span class="line"><span class="comment">//(**ptr)++;  //指向a的第一个元素Y，对Y进行+1变为Z</span></span><br><span class="line"><span class="comment">//printf("a = %c\n", **ptr);   //打印输出Z，更改a的第一个字符Y为</span></span><br><span class="line">ptr++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ptr = %p\n"</span>, ptr);  <span class="comment">//输出之前指针ptr所指向的地址+4，即之前指针p在内存中的地址+4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*ptr = %p\n"</span>, *ptr); <span class="comment">//</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"**ptr = %c\n"</span>, **ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部分运行结果：</p><div align="center">    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);    margin-left:-0px;" src="/2020/01/17/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/7.png"></div><p>ptr 的类型是<code>char **</code>,指向的类型是一个<code>char *</code>类型,该指向的地址就是p的地址(&amp;p),当执行<code>ptr++</code>;时,会使指针加一个<code>sizeof(char*)</code>,即<code>&amp;p+4</code>;那<code>*(&amp;p+4)</code>指向哪呢,这个你去问上帝吧,或者他会告诉你在哪。所以最后的输出会是一个随机的值,或许是一个非法操作，一般而言程序会出错。</p><h2 id="指针-指针"><a href="#指针-指针" class="headerlink" title="指针 - 指针"></a>指针 - 指针</h2><p>只有当两个指针都指向同一个数组中的元素时，才允许从一个指针减去另一个指针。<strong>减法运算的值是两个指针在内存中的距离</strong>（以数组元素的长度为单位，而不是以字节为单位），因为减法运算的结果将除以数组元素类型的长度。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> sub;</span><br><span class="line">    <span class="keyword">int</span> *p1 = &amp;a[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> *p2 = &amp;a[<span class="number">8</span>];</span><br><span class="line">    sub = p2-p1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sub);　　　　<span class="comment">// 输出结果为 6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="指针与数组的关系"><a href="#指针与数组的关系" class="headerlink" title="指针与数组的关系"></a>指针与数组的关系</h1><p>数组的数组名其实可以看作一个指针，<strong>通过数组和下标实现的表达式可以等价地通过指针及其偏移量来实现</strong>，这就是数组和指针的互通之处。但有一点要明确的是，数组和指针并不是完全等价，指针是一个变量，而数组名不是变量，数组名是数组中第 1 个元素的地址，数组可以看做是一个用于保存变量的容器。</p><h1 id="指针与结构的关系"><a href="#指针与结构的关系" class="headerlink" title="指针与结构的关系"></a>指针与结构的关系</h1><p>结构指针是指向结构的指针，C语言中使用 -&gt; 操作符来访问结构指针的成员。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;message;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    message mess = &#123;<span class="string">"tongye"</span>,<span class="number">23</span>,<span class="number">83</span>&#125;;</span><br><span class="line">    message *p = &amp;mess;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p-&gt;mess);　　　　　　<span class="comment">// 输出结果为：tongye</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,p-&gt;score);         <span class="comment">// 输出结果为：83</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="指针和函数的关系"><a href="#指针和函数的关系" class="headerlink" title="指针和函数的关系"></a>指针和函数的关系</h1><p><strong>C语言的所有参数均是以“传值调用”的方式进行传递的</strong>，这意味着函数将获得参数值的一份拷贝。这样，函数可以放心修改这个拷贝值，而不必担心会修改调用程序实际传递给它的参数。</p><h2 id="指针作为函数的参数"><a href="#指针作为函数的参数" class="headerlink" title="指针作为函数的参数"></a>指针作为函数的参数</h2><p>传值调用的好处是是被调函数不会改变调用函数传过来的值，可以放心修改。但是有时候需要被调函数回传一个值给调用函数，这样的话，传值调用就无法做到。为了解决这个问题，可以使用传指针调用。<strong>指针参数使得被调函数能够访问和修改主调函数中对象的值</strong>。<br>用函数交换2个变量的值的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_bad</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_ok</span><span class="params">(<span class="keyword">int</span>*pa,<span class="keyword">int</span>*pb)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line">    swap_bad(a,b);       <span class="comment">//Can`t swap;</span></span><br><span class="line">    swap_ok(&amp;a,&amp;b);      <span class="comment">//OK</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误的写法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_bad</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确的写法：通过指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_ok</span><span class="params">(<span class="keyword">int</span>*pa,<span class="keyword">int</span>*pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t=*pa;</span><br><span class="line">    *pa=*pb;</span><br><span class="line">    *pb=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/17/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/11.png">    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/17/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/12.png"></center><h2 id="指向函数的指针"><a href="#指向函数的指针" class="headerlink" title="指向函数的指针"></a>指向函数的指针</h2><p>在C语言中，函数本身不是变量，但是可以定义指向函数的指针，也称作函数指针，函数指针指向函数的入口地址。这种类型的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值等等。 声明一个函数指针的方法如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 （* 指针变量名）（[形参列表]）;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*pointer)(<span class="keyword">int</span> *,<span class="keyword">int</span> *);        <span class="comment">// 声明一个函数指针</span></span><br></pre></td></tr></table></figure></p><p>上述代码声明了一个函数指针 pointer ，该指针指向一个函数，函数具有两个 int * 类型的参数，且返回值类型为 int。下面的代码演示了函数指针的用法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">str_comp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *m,<span class="keyword">const</span> <span class="keyword">char</span> *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//库函数 strcmp 用于比较两个字符串，其原型是：int strcmp(const char *s1,const char *s2);</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(m,n) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数 comp 接受一个函数指针作为它的第三个参数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">comp</span><span class="params">(<span class="keyword">char</span> *a,<span class="keyword">char</span> *b,<span class="keyword">int</span> (*prr)(<span class="keyword">const</span> <span class="keyword">char</span> *,<span class="keyword">const</span> <span class="keyword">char</span>*))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((*prr)(a,b) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"str1 = str2\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"str1 != str2\n"</span>);</span><br><span class="line">&#125;       <span class="comment">// 声明一个函数 comp ,注意该函数的第三个参数，是一个函数指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">20</span>]; <span class="comment">//声明一个字符数组</span></span><br><span class="line">    <span class="keyword">char</span> str2[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> (*p)(<span class="keyword">const</span> <span class="keyword">char</span> *,<span class="keyword">const</span> <span class="keyword">char</span> *) = str_comp; <span class="comment">//声明并初始化一个函数指针</span></span><br><span class="line"></span><br><span class="line">    gets(str1); <span class="comment">//使用 gets() 函数从 I/O 读取一行字符串</span></span><br><span class="line">    gets(str2);</span><br><span class="line">    comp(str1,str2,p); <span class="comment">//函数指针 p 作为参数传给 comp 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码的功能是从键盘读取两行字符串（长度不超过20），判断二者是否相等。</p><h3 id="使用typedef定义函数指针"><a href="#使用typedef定义函数指针" class="headerlink" title="使用typedef定义函数指针"></a>使用typedef定义函数指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFun</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*funP)</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">//定义函数指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    funP p;</span><br><span class="line">    p=&amp;MyFun; <span class="comment">//将MyFun函数的地址赋给FunP变量</span></span><br><span class="line">    (*p)(<span class="number">20</span>); <span class="comment">//这是通过函数指针变量FunP来调用MyFun函数的。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>typedef的功能是定义新的类型。第一句就是定义了一种funP的类型，并定义这种类型为指向某种函数的指针，这种函数以一个int为参数并返回void类型。后面就可以像使用int，char一样使用funP了。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><blockquote><p><a href="https://blog.csdn.net/tianmaxingkong_/article/details/41593483" target="_blank" rel="noopener">C语言，指针变量的*p,p以及&amp;p的区别</a><br><a href="https://www.cnblogs.com/linuxAndMcu/p/11262773.html" target="_blank" rel="noopener">深入理解C语言 - 指针详解</a><br><a href="https://blog.csdn.net/constantin_/article/details/79575638" target="_blank" rel="noopener">C语言指针详解</a><br><a href="https://blog.csdn.net/Tomstrong_369/article/details/54376231" target="_blank" rel="noopener">C语言指针详解</a><br><a href="https://www.cnblogs.com/lulipro/p/7460206.html" target="_blank" rel="noopener">C指针</a><br><a href="https://www.dotcpp.com/wp/692.html" target="_blank" rel="noopener">左值和右值</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想要理解指针其实很简单，画张图就行了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不只是指针，只要是不会的画图就行～&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>hugo</title>
    <link href="http://yoursite.com/2020/01/17/hugo/"/>
    <id>http://yoursite.com/2020/01/17/hugo/</id>
    <published>2020-01-17T11:34:26.000Z</published>
    <updated>2020-01-22T13:37:51.921Z</updated>
    
    <content type="html"><![CDATA[<p>从hexo迁移到hugo<br>因为有bug，所以放弃了～</p><a id="more"></a><blockquote><p>参考文档：<br><a href="https://jdhao.github.io/2018/10/10/hexo_to_hugo/" target="_blank" rel="noopener">从 Hexo 切换为 Hugo</a><br><a href="https://github.com/reuixiy/io-oi.me/blob/master/content/zh/tech/Hugo%20%E4%B8%BB%E9%A2%98%20MemE%20%E6%96%87%E6%A1%A3.md" target="_blank" rel="noopener">hugo</a></p></blockquote><h2 id="hugo安装"><a href="#hugo安装" class="headerlink" title="hugo安装"></a>hugo安装</h2><h2 id="Windows7下Chocolatey的安装"><a href="#Windows7下Chocolatey的安装" class="headerlink" title="Windows7下Chocolatey的安装"></a>Windows7下Chocolatey的安装</h2><p>点击“开始”，搜索栏输入‘cmd’,右键‘cmd.exe’,选择‘以管理员身份运行’，在命令行界面输入:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="string">"%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe"</span> -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command <span class="string">"iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))"</span> &amp;&amp; SET <span class="string">"PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin"</span></span><br></pre></td></tr></table></figure></p><p>命令行键入choco，显示如下，安装成功</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/17/hugo/1.png"></center><h2 id="windows安装hugo"><a href="#windows安装hugo" class="headerlink" title="windows安装hugo"></a>windows安装hugo</h2><p>Windows下Hugo提供了Chocolatey方式的安装:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco install hugo -confirm</span><br></pre></td></tr></table></figure></p><p>安装扩展版：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco install hugo-extended -confirm</span><br></pre></td></tr></table></figure></p><p>卸载hugo：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco uninstall hugo -confirm</span><br></pre></td></tr></table></figure></p><p>安装完成后：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/17/hugo/2.png"></center><p>验证安装:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hugo version</span><br></pre></td></tr></table></figure></p><p>如果没问题的话，会输出Hugo的版本号等一些信息。<br>查看hugo安装地址：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">where</span> hugo</span><br></pre></td></tr></table></figure></p><h2 id="创建一个站点"><a href="#创建一个站点" class="headerlink" title="创建一个站点"></a>创建一个站点</h2><p>安装以后，首先我们需要建立一个博客目录，下面存放的是博客的所有配置以及博文等资料，例如要建立一个名为<code>Blog</code> 的站点，使用下面的命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hugo new site Blog</span><br></pre></td></tr></table></figure></p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/17/hugo/3.png"></center><p>文件目录在：<code>C:/Windows/System32/Blog</code><br>建立站点以后，博客根目录下默认有这些文件和子目录：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">archetypes/  config.toml  content/  data/  layouts/  static/  themes/</span><br></pre></td></tr></table></figure></p><p><code>config.toml</code>就是博客的配置文件，<code>archetypes</code> 目录下有一个 <code>default.md</code>，存放的是建立新博文时候默认使用的模板，可以根据自己需求修改。<code>content</code> 目录用来存放博文，<code>static</code> 可以存放一些自己的文件，<code>themes</code> 文件夹用于存放不同的主题。</p><h1 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h1><blockquote><p>特别注意：请安装扩展版（extended）的 Hugo</p></blockquote><p>以安装MemE为例：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Blog</span><br><span class="line">git init</span><br><span class="line">git submodule add https://github.com/reuixiy/hugo-theme-meme.git themes/meme</span><br></pre></td></tr></table></figure></p><p>将 MemE 更新到最新版本:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/Blog $ git submodule update --rebase --remote</span><br></pre></td></tr></table></figure></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>安装完 Hugo 和 MemE 后，再进行以下两步操作——替换 <code>config.toml</code> 和新建文章。</p><h3 id="替换-config-toml"><a href="#替换-config-toml" class="headerlink" title="替换 config.toml"></a>替换 config.toml</h3><p>对于简体中文用户，你可以通过文件浏览器打开站点文件夹，然后将 Hugo 默认生成的 <code>config.toml</code> 删除，再进入 <code>themes/meme/config-examples/zh-cn/</code> 目录，将 MemE 提供的 <code>config.toml</code> 复制到站点根目录下。当然，你也可以直接通过终端：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/Blog $ rm config.toml &amp;&amp; cp themes/meme/config-examples/zh-cn/config.toml config.toml</span><br></pre></td></tr></table></figure></p><h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><p>新建一篇文章和一个关于页面：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hugo new posts/test.md</span><br><span class="line">hugo new about/_index.md</span><br></pre></td></tr></table></figure></p><p>这个命令会在 <code>content</code> 目录下建立 <code>post</code> 目录，并在 <code>post</code> 下生成 <code>test.md</code> 文件，博文书写就在这个文件里使用 Markdown 语法完成。博文的 front matter 里<code>draft</code> 选项默认为 <code>true</code>，需要改为 <code>false</code> 才能发表博文，建议直接更改上面说的<code>archetypes</code> 目录下的 <code>default</code> 文件，把 <code>draft: true</code> 改为 <code>draft: false</code>，这样生成的博文就是默认可以发表的。</p><p>和 Hexo 一样，在 front matter 里面，使用 tags 指定文章的 tag，使用categories 指定文章的类别，示例如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tags: [LaTeX, Hexo, font]</span><br><span class="line">categories: [Mac, Linux]</span><br></pre></td></tr></table></figure></p><p>把 Hexo 博客里的所有博文 Markdown 文件拷贝到 <code>content/post/</code> 目录下，就完成了博文的迁移。</p><h2 id="部署到-github-pages"><a href="#部署到-github-pages" class="headerlink" title="部署到 github pages"></a>部署到 github pages</h2><p>确定生成的博客效果无误后，就可以将博客部署到服务器了，我使用的是免费的 GitHub pages 服务。本部分假定我们在 github pages 建立的是 User/Organization Pages ，地址名称形式为<br><code>https://&lt;USERNAME|ORGANIZATION&gt;.github.io/</code>，如果不是这种类型地址，请参考 Hugo 官方指导。<br>如果之前已经建立了 xxxx.github.io 这种形式的仓库，并且使用 Hexo 往这个仓库部署过，但是不想要之前的东西了，在博客的根目录下，运行下面的命令即可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir public</span><br><span class="line"><span class="built_in">cd</span> public</span><br><span class="line">git init</span><br><span class="line">git remote add upstream https://github.com/sweetyknight/sweetyknight.github.io</span><br></pre></td></tr></table></figure></p><p>然后，我们把 public 下面的内容 push 到 github :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m  <span class="string">"hello world"</span></span><br><span class="line">git push -f upstream master <span class="comment"># 第一次 push 必须使用 -f，因为此时远程仓库非空，和本地有冲突</span></span><br></pre></td></tr></table></figure></p><blockquote><p>如果在github的remote上已经有了文件，会出现错误。此时应当先pull一下：<br>git pull origin master<br>然后再进行：<br>git push -f upstream master</p></blockquote><p>第一次发布需要执行的命令多一点，以后发布只需要执行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m  <span class="string">"hello world"</span></span><br><span class="line">git push  upstream master</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从hexo迁移到hugo&lt;br&gt;因为有bug，所以放弃了～&lt;/p&gt;
    
    </summary>
    
      <category term="hugo" scheme="http://yoursite.com/categories/hugo/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解数据库原理</title>
    <link href="http://yoursite.com/2020/01/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/01/15/深入理解数据库原理/</id>
    <published>2020-01-15T12:01:55.000Z</published>
    <updated>2020-01-15T12:05:31.205Z</updated>
    
    <content type="html"><![CDATA[<p>有时间就自己重写一遍。</p><a id="more"></a><p><a href="https://blog.csdn.net/zhangcanyan/article/details/51439012" target="_blank" rel="noopener">数据库的原理，一篇文章搞定（一）</a><br><a href="https://blog.csdn.net/zhangcanyan/article/details/51439021" target="_blank" rel="noopener">数据库的原理，一篇文章搞定（二）</a><br><a href="https://blog.csdn.net/zhangcanyan/article/details/51439034" target="_blank" rel="noopener">数据库的原理，一篇文章搞定（三）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时间就自己重写一遍。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>时间复杂度的理解</title>
    <link href="http://yoursite.com/2020/01/15/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/01/15/时间复杂度的理解/</id>
    <published>2020-01-15T10:48:31.000Z</published>
    <updated>2020-01-22T16:24:39.240Z</updated>
    
    <content type="html"><![CDATA[<p>之前对时间复杂度不是很理解，看到两篇文章讲的很好就记录下来。</p><a id="more"></a><h1 id="时间复杂度-O-log-n-意味着什么？"><a href="#时间复杂度-O-log-n-意味着什么？" class="headerlink" title="时间复杂度 O(log n) 意味着什么？"></a>时间复杂度 O(log n) 意味着什么？</h1><p>对于 $O(1)$ ，它表示时间复杂度为1，即解决这一问题的实现很直接，只需一步或者固定几个步骤。比如从哈希表中取值，通过索引只需在哈希表中查找一次便得到结果。而 $O(n)$ 表示完成这一任务的时间复杂度与输入有关，与输入成正比，比如遍历数组。<br>而 $O(log n)$ 又该怎样理解？它的典型场景便是二分查找法，原理是不断将输入进行二等分直到找到目标。<br>已知有 16 个元素的有序数组，比如我们要找的是数字 13。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/15/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%90%86%E8%A7%A3/1.png"></center><p>找到中间元素，这里也就是元素16所处的位置，它中间为分界线将整个数列均分。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/15/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%90%86%E8%A7%A3/2.png"></center><p>将目标与中间元素进行比较，因为13小于16，所以我们保留前半部分继续寻找。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/15/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%90%86%E8%A7%A3/3.png"></center><p>重复上面的步骤，找到中间元素 8，因为13比8大，所以保留8后面的这部分</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/15/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%90%86%E8%A7%A3/4.png"></center><p>继续上面的步骤，直到没有剩余的元素便找到我们的目标了。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/15/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%90%86%E8%A7%A3/5.png"></center><p>上面的步骤，每一次操作都将总数减小到原来的一半。我们从16个元素中找一个目标时二分了4次，总结成公式：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/15/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%90%86%E8%A7%A3/6.png">    16个元素中二分的公式</center><p>推而广之，从 n 个元素中查找，需要多少次呢，还不知道，假设需要 k次。那么用上面的公式则可以表示为：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/15/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%90%86%E8%A7%A3/7.png">    从 n 个元素中查找的公式</center><p>去掉幂的括号则变成了：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/15/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%90%86%E8%A7%A3/8.png"></center><p>最后我们去掉分母，得到了一个简洁的公式：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/15/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%90%86%E8%A7%A3/9.png"></center><p>所以对上面公式两边取对数便得到了 k 的值：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/15/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%90%86%E8%A7%A3/10.png"></center><p>于是，我们推导出了如果输入为 n，查找一个结果的时间复杂度为 O(log n)。</p><h2 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num1, num2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">num1 += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j*=<span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line">num2 += num1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$j$ 每循环一次乘了 $2$ 。<br>$j$初始为$1$，所以循环$x$ 次之后 $j=2^{x}$<br>$j &gt; n $ 时停止循环，也就是 $2^{x}&gt;n$ ,此时 $x=\log_{2}n$<br>所以 $j$ 循环了 $\log_{2}n$ 次<br>总时间复杂度为 $O(n*\log_{2}n)$</p><blockquote><p>参考文档：<br><a href="https://juejin.im/entry/593f56528d6d810058a355f4" target="_blank" rel="noopener">时间复杂度 O(log n) 意味着什么</a><br><a href="https://www.zhihu.com/question/20503898" target="_blank" rel="noopener">简单的时间复杂度问题</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前对时间复杂度不是很理解，看到两篇文章讲的很好就记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>树-原理篇</title>
    <link href="http://yoursite.com/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/"/>
    <id>http://yoursite.com/2020/01/14/树-原理篇/</id>
    <published>2020-01-14T09:37:34.000Z</published>
    <updated>2020-01-23T03:52:22.232Z</updated>
    
    <content type="html"><![CDATA[<p>树的基本原理。</p><a id="more"></a><h1 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h1><h2 id="结点的度与树的度"><a href="#结点的度与树的度" class="headerlink" title="结点的度与树的度"></a>结点的度与树的度</h2><p>结点的度：树中某个结点的子树的个数<br>树的度：树中所有的结点的度中的最大值，通常将度为m的树称为<code>m次树</code>(m-tree)</p><h2 id="分支结点与叶子结点"><a href="#分支结点与叶子结点" class="headerlink" title="分支结点与叶子结点"></a>分支结点与叶子结点</h2><p>分支结点：树中度不为零的结点被称为非终端结点，也叫分支结点(branch)。分支结点中，每个结点的分支数就是该结点的度。对于度为1的结点，其分支数为1，被称为单分支结点，以此类推，如双分支结点。<br>叶子结点：度为零的结点(leaf)</p><h2 id="路径与路径长度"><a href="#路径与路径长度" class="headerlink" title="路径与路径长度"></a>路径与路径长度</h2><p>路径：从结点k1出发到达k2所通过的树中结点序列(包括k1和k2)<br>路径长度：该路径通过的结点树减1(即路径上的分支树)</p><h2 id="孩子结点、双亲结点、兄弟结点"><a href="#孩子结点、双亲结点、兄弟结点" class="headerlink" title="孩子结点、双亲结点、兄弟结点"></a>孩子结点、双亲结点、兄弟结点</h2><p>在一棵树中，每个结点的后继结点被称为该结点的孩子结点。<br>相应的，该结点被称为孩子结点的双亲结点。<br>具有同一双亲结点的孩子结点互为兄弟结点。<br>进一步，可以把每个结点对应的子树的所有结点(除自身外)称为该结点的子孙结点，把从根结点到某个结点的路径上经过的所有结点(除自身外)称为祖先结点。</p><h2 id="结点层次和树的高度"><a href="#结点层次和树的高度" class="headerlink" title="结点层次和树的高度"></a>结点层次和树的高度</h2><p>树的每个结点都处在一定的层次上。结点层次(level)或结点深度(depth)从树根开始定义，根结点为第一层，以此类推。<br>树中结点的最大层次称为树的高度或树的深度。</p><h2 id="有序树和无序树"><a href="#有序树和无序树" class="headerlink" title="有序树和无序树"></a>有序树和无序树</h2><p>若树中各结点的子树是按照一定次序从左到有安排且次序不能随意变换则称为有序树，否则是无序树。</p><h2 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h2><p>森林（forest）是m(m&gt;0)棵互不相交的树的集合。对树中的每个结点而言，其子树的集合即为森林。树和森林的概念相近。删去一棵树的根，就得到一个森林；反之，加上一个结点作为树根，森林就变成了一棵树。</p><blockquote><p>前驱结点：节点val值小于该结点val值并且值最大的结点<br>后继结点：节点val值大于该结点val值并且值最小的结点</p></blockquote><h1 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h1><p>1.非空树的结点总数等于树中所有结点的度之和加1<br>2.度为k的非空树的第i层最多有 $k^{i-1}$ 个结点，其中i&gt;=1<br>3.深度为h的k叉树最多有$\frac{k^{h}-1}{k-1}$ 个结点<br>4.具有n个结点的k叉树的最小深度为$\left \lceil \log_{k}(n(k-1)+1) \right \rceil$  ,$\left \lceil x \right \rceil$  表示向上取整(大于等于x的最小整数)</p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树性质"><a href="#二叉树性质" class="headerlink" title="二叉树性质"></a>二叉树性质</h2><p>1.二叉树中，第 i 层最多有$2^{i-1}$ 个结点。<br>2.高度为k的二叉树最多有 $2^{k}-1$ 个结点。<br>3.二叉树中，叶子结点数为 $n_{0}$，度为 2 (双分支)的结点数为$n_{2}$，则 $n_{0}=n_{2}+1$ 。<br>4.具有n(n&gt;0)个结点的完全二叉树的深度为$h=\left \lceil \log_{2}(n+1) \right \rceil$ 或$h=\left \lfloor log_{2}n \right \rfloor +1$</p><blockquote><p>性质 3 的计算方法为：对于一个二叉树来说，除了度为 0 的叶子结点和度为 2 的结点，剩下的就是度为 1 的结点（设为$n_{1}$），那么总结点 $n=n_{0} + n_{1} + n_{2}$  。<br>同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为 B，那么总结点数 n=B+1。而分枝数是可以通过$n_{1}$和$n_{2}$表示的，即<script type="math/tex">B=n_{1}+2*n_{2}</script> 。所以，n 用另外一种方式表示为 $n=n_{1}+2*n_{2}+1$ 。<br>两种方式得到的 n 值组成一个方程组，就可以得出 $n_{0}=n_{2}+1$。</p></blockquote><p>二叉树还可以继续分类，衍生出满二叉树和完全二叉树。</p><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。共有有$2^{h}-1$个节点</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/满二叉树.gif"></center><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/完全二叉树.gif"></center><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><p>二叉树的遍历是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。<br>四种主要的遍历思想为：<br>前序遍历：根结点 —-&gt; 左子树 —-&gt; 右子树(划分依据是根结点的访问顺序)<br>中序遍历：左子树—-&gt; 根结点 —-&gt; 右子树<br>后序遍历：左子树 —-&gt; 右子树 —-&gt; 根结点<br>层次遍历：只需按层次遍历即可</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/二叉树遍历.png">    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/二叉树遍历1.png"></center><h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p>二叉查找树（BST：Binary Search Tree）是一种特殊的二叉树，它改善了二叉树节点查找的效率。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>1.如果节点的左子树不空，则左子树上所有结点的值均小于等于它的根结点的值；<br>2.如果节点的右子树不空，则右子树上所有结点的值均大于等于它的根结点的值；</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/二叉查找树.gif"></center><p>上图中展示了两个二叉树。二叉树（b）是一个二叉查找树（BST），它符合二叉查找树的性质规定。而二叉树（a），则不是二叉查找树。因为节点 10 的右孩子节点 8 小于节点 10，但却出现在节点 10 的右子树中。同样，节点 8 的右孩子节点 4 小于节点 8，但出现在了它的右子树中。无论是在哪个位置，只要不符合二叉查找树的性质规定，就不是二叉查找树。</p><h2 id="查找算法过程"><a href="#查找算法过程" class="headerlink" title="查找算法过程"></a>查找算法过程</h2><p>假设我们要查找节点 n，从 BST 的根节点开始。算法不断地比较节点值的大小直到找到该节点，或者判定不存在。每一步我们都要处理两个节点：树中的一个节点，称为节点 c，和要查找的节点 n，然后并比较 c 和 n 的值。开始时，节点 c 为 BST 的根节点。然后执行以下步骤：</p><ol><li>如果 c 值为空，则 n 不在 BST 中；</li><li>比较 c 和 n 的值；</li><li>如果值相同，则找到了指定节点 n；</li><li>如果 n 的值小于 c，那么如果 n 存在，必然在 c 的左子树中。回到第 1 步，将 c 的左孩子作为 c；</li><li>如果 n 的值大于 c，那么如果 n 存在，必然在 c 的右子树中。回到第 1 步，将 c 的右孩子作为 c；</li></ol><p>通过 BST 查找节点，理想情况下我们需要检查的节点数可以减半。<br>如下图中的 BST 树，包含了 15 个节点。从根节点开始执行查找算法，第一次比较决定我们是移向左子树还是右子树。对于任意一种情况，一旦执行这一步，我们需要访问的节点数就减少了一半，从 15 降到了 7。同样，下一步访问的节点也减少了一半，从 7 降到了 3，以此类推。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/二叉查找树1.gif"></center><p>根据这一特点，查找算法的时间复杂度应该是$O(log_{2}n)$ ，简写为$O(\lg n)$<br> BST 算法查找时间依赖于树的拓扑结构。最佳情况是$O(log_{2}n)$，而最坏情况是$O(n)$。</p><h2 id="插入结点算法"><a href="#插入结点算法" class="headerlink" title="插入结点算法"></a>插入结点算法</h2><ol><li>若b是空树，则将s所指结点作为根节点插入，否则：</li><li>若s-&gt;data等于b的根节点的数据域之值，则返回，或者报错，否则：</li><li>若s-&gt;data小于b的根节点的数据域之值，则把s所指节点插入到左子树中，否则：<br>把s所指节点插入到右子树中。（新插入节点总是叶子节点）</li></ol><p>当合适的节点找到时，该算法结束。从而使新节点被放入 BST 中成为某一父节点合适的孩子节点。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/二叉-查找.gif"></center><h2 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h2><p>从 BST 中删除节点比插入节点难度更大。因为删除一个非叶子节点，就必须选择其他节点来填补因删除节点所造成的树的断裂。如果不选择节点来填补这个断裂，那么就违背了 BST 的性质要求。<br>分三种情况进行处理：<br>1.删除叶子节点<br>叶子节点删除是最简单的情况，由于叶子节点没有左右子树，删除后不会破坏原有的树形结构，所以我们只需要找到节点并且把它置为null即可。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/二叉删除1.gif">  </center><p>2.被删除的节点只有一个子节点<br>比如我们要删除上图中3所在的节点，3只有一个左子树1。<br>实际上我们只需要把5所在节点的左子树指向原来3的左子树即可。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/二叉删除2.gif"></center><p>3.被删除的节点左右子树都有<br>这种情况比较复杂，为了不破坏二叉查找树的结构，我们可以按照以下操作进行：</p><ul><li>找出左子树中最大或者右子树中最小的值val</li><li>将当前节点的值替换为val</li><li>在左子树或者右子树中找到val删除</li></ul><blockquote><p>由于二叉查找树的性质，如果将当前节点替换为左子树中最大的或者右子树中最小的一定不会破坏二叉查找树的结构。</p></blockquote><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/二叉删除3.gif"></center><h1 id="平衡二叉树-AVL"><a href="#平衡二叉树-AVL" class="headerlink" title="平衡二叉树(AVL)"></a>平衡二叉树(AVL)</h1><p>二叉搜索树的查找效率取决于树的高度，因此保持树的高度最小，即可保证树的查找效率。AVL是BST的一个进化体，也是一棵二叉查找树。</p><h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h2><p>平衡二叉查找树，简称AVL树(有别于AVL算法)，它具有如下几个性质：</p><ol><li>可以是空树。</li><li>假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。</li></ol><p>平衡之意，如天平，即两边的分量大约相同。</p><blockquote><p>平衡因子<br>某节点的左子树与右子树的高度(深度)差即为该节点的平衡因子（BF,Balance Factor），平衡二叉树中不存在平衡因子大于 1 的节点。在一棵平衡二叉树中，节点的平衡因子只能取 0 、1 或者 -1 ，分别对应着左右子树等高，左子树比较高，右子树比较高。</p></blockquote><h2 id="AVL树插入时的失衡与调整"><a href="#AVL树插入时的失衡与调整" class="headerlink" title="AVL树插入时的失衡与调整"></a>AVL树插入时的失衡与调整</h2><p>以下是一颗平衡二叉树：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/AVL1.jpg"></center><p>在此平衡二叉树插入节点 99 ，树结构变为：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/AVL2.webp"></center><p>在动图中，节点 66 的左子树高度为 1，右子树高度为 3，此时平衡因子为 -2，树失去平衡，此时只有一棵不平衡子树。以节点 66 为父节点的那颗树就称为<strong>最小失衡子树</strong>。</p><blockquote><p>最小失衡子树：在新插入的结点向上查找，以第一个平衡因子的绝对值超过 1 的结点为根的子树称为最小不平衡子树。也就是说，一棵失衡的树，是有可能有多棵子树同时失衡的。而这个时候，我们只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。</p></blockquote><p>平衡二叉树的失衡调整主要是通过旋转最小失衡子树来实现的。根据旋转的方向有两种处理方式，左旋与右旋。右子树过高，向左旋转；左子树过高，向右旋转。旋转的目的就是减少高度，通过降低整棵树的高度来平衡。</p><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/AVL3.jpg"></center><p>以上图为例，加入新节点 99 后， 节点 66 的左子树高度为 1，右子树高度为 3，此时平衡因子为 -2。为保证树的平衡，此时需要对节点 66 做出旋转，因为右子树高度高于左子树，对节点进行左旋操作，流程如下：</p><ol><li>节点的右孩子替代此节点位置</li><li>右孩子的左子树变为该节点的右子树</li><li>节点本身变为右孩子的左子树</li></ol><p>整个操作流程如动图所示。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/AVL4.webp"></center><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p>右旋操作与左旋类似，操作流程为：</p><ol><li>节点的左孩子代表此节点</li><li>节点的左孩子的右子树变为节点的左子树</li><li>将此节点作为左孩子节点的右子树。</li></ol><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/AVL5.webp"></center><blockquote><p>在上面的例子我们可以看出，我们对不平衡的树进行旋转的时候，不仅需要考虑需要最小失衡子树的根结点的平衡因子，还要考虑根结点较高子树的根结点的平衡因子。</p></blockquote><p>为了方便讨论，我们使用连续的两个字母来表示平衡因子，以表示各种不同的情况。第一个字母表示最小不平衡子树根结点的平衡因子，第二个字母表示最小不平衡子树较高子树的根结点的平衡因子。使用L表示左子树较高，R表示右子树较高，E表示左右子树等高。</p><h3 id="LL型-A的左孩子的左子树插入节点"><a href="#LL型-A的左孩子的左子树插入节点" class="headerlink" title="LL型(A的左孩子的左子树插入节点)"></a>LL型(A的左孩子的左子树插入节点)</h3><p>在LL型的不平衡树中，我们首先找到最小不平衡子树，再以其根结点向右旋转，只需要执行一次右旋即可。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/AVL6.webp"></center><h3 id="RR型-A的右孩子的右子树插入节点"><a href="#RR型-A的右孩子的右子树插入节点" class="headerlink" title="RR型(A的右孩子的右子树插入节点)"></a>RR型(A的右孩子的右子树插入节点)</h3><p>只需要执行一次左旋即可。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/AVL7.webp"></center><h3 id="LR型-A的左孩子的右子树插入节点"><a href="#LR型-A的左孩子的右子树插入节点" class="headerlink" title="LR型(A的左孩子的右子树插入节点)"></a>LR型(A的左孩子的右子树插入节点)</h3><p>若 A 的左孩子节点 B 的右子树 E 插入节点 F ，导致节点 A 失衡，如图：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/AVL10.jpg"></center><p>对于LR，要分为两步进行旋。旋转之后为<strong>原来根结点的左孩子的右孩子作为新的根结点</strong>。第一次以较高子树的根为中心向左旋转，第二次以原树的根为中心，向右旋转。<br>调整过程如下：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/AVL8.jpg">    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/AVL9.jpg"></center><p>也就是说，经过这两步操作，使得 原来根节点的左孩子的右孩子 E 节点成为了新的根节点。</p><h3 id="RL型-A的右孩子的左子树插入节点"><a href="#RL型-A的右孩子的左子树插入节点" class="headerlink" title="RL型(A的右孩子的左子树插入节点)"></a>RL型(A的右孩子的左子树插入节点)</h3><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/AVL11.jpg"></center><p>右孩子插入左节点的过程与左孩子插入右节点过程类似，也是需要执行两步操作，使得旋转之后为<strong>原来根结点的右孩子的左孩子作为新的根节点</strong> 。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/AVL12.jpg">    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/AVL13.jpg"></center><p>经过这两步操作，使得 原来根节点的右孩子的左孩子 D 节点成为了新的根节点。</p><h2 id="AVL删除时的失衡与调整"><a href="#AVL删除时的失衡与调整" class="headerlink" title="AVL删除时的失衡与调整"></a>AVL删除时的失衡与调整</h2><p>AVL的树的删除策略与二叉查找树的删除策略相似，只是删除节点后造成树失去平衡性，需要做平衡处理。同时，删除操作与插入操作后的平衡修正区别在于，插入操作后只需要对插入栈中的弹出的第一个非平衡节点进行修正，而删除操作需要修正栈中的所有非平衡节点。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/AVL删除.png"></center><h1 id="平衡二叉树之红黑树"><a href="#平衡二叉树之红黑树" class="headerlink" title="平衡二叉树之红黑树"></a>平衡二叉树之红黑树</h1><p>红黑树本质上是一种二叉查找树，但它在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。这些规则使红黑树保证了一种平衡，插入、删除、查找的最坏时间复杂度都为$O(\log n)$。</p><blockquote><p>从根节点到叶节点的路径上黑色节点的个数，叫做树的黑色高度。</p></blockquote><h2 id="红黑树时间复杂度"><a href="#红黑树时间复杂度" class="headerlink" title="红黑树时间复杂度"></a>红黑树时间复杂度</h2><p>红黑树的应用比较广泛，主要是用它来存储有序的数据<br>一个由n个节点随机构成的二叉查找树的高度为$\log n$，查找的时间复杂度即与高度成正比，它的时间复杂度是$O(\log n)$ ，效率非常之高。证明如下：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/红黑树高度证明.webp"></center><h2 id="红黑树特性"><a href="#红黑树特性" class="headerlink" title="红黑树特性"></a>红黑树特性</h2><ol><li>每个节点或者是黑色，或者是红色。</li><li>根节点是黑色。</li><li>每个叶子节点是黑色，叶子节点是空(NIL或null)结点。</li><li>如果节点是红色的，则它的子节点必须是黑色的(反之不一定,即从每个叶子到根的所有路径上不能有两个连续的红色节点，但黑色节点是可以连续的。)</li><li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点(即相同的黑色高度)。</li></ol><blockquote><p>这些约束确保了红黑树的关键特性: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。<br>最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。</p><p>注意：<strong>新插入的节点颜色是红色的</strong>，这是因为插入一个红色节点比插入一个黑色节点违背红-黑规则的可能性更小，原因是插入黑色节点总会改变黑色高度（违背规则5），但是插入红色节点只有一半的机会会违背规则4（因为父节点是黑色的没事，父节点是红色的就违背规则4）。另外违背规则4比违背规则5要更容易修正。</p></blockquote><p>红黑树示意图：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/红黑树1.webp"></center><h2 id="红-黑树的自我修正"><a href="#红-黑树的自我修正" class="headerlink" title="红-黑树的自我修正"></a>红-黑树的自我修正</h2><p>当插入一个新的节点时，可能会破坏这种平衡性，红-黑树主要通过两种方式对平衡进行修正，左旋和右旋。</p><h3 id="左旋-1"><a href="#左旋-1" class="headerlink" title="左旋"></a>左旋</h3><p>左旋的顶端节点必须要有右子节点。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/红黑树4.gif"></center><h3 id="右旋-1"><a href="#右旋-1" class="headerlink" title="右旋"></a>右旋</h3><p>首先要说明的是节点本身是不会旋转的，旋转改变的是节点之间的关系，选择一个节点作为旋转的顶端，如果做一次右旋，这个顶端节点会向下和向右移动到它右子节点的位置，它的左子节点会上移到它原来的位置。右旋的顶端节点必须要有左子节点。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/红黑树3.gif"></center><h3 id="改变节点颜色"><a href="#改变节点颜色" class="headerlink" title="改变节点颜色"></a>改变节点颜色</h3><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/红黑树2.png"></center><p>新插入的节点为15，那么我们发现直接插入会违反规则3，改为黑色却发现违反规则5。这时候我们将其父节点颜色改为黑色，父节点的兄弟节点颜色也改为黑色。通常其祖父节点50颜色会由黑色变为红色，但是由于50是根节点，所以我们这里不能改变根节点颜色。</p><blockquote><p>注意：我们改变颜色是为了帮助我们判断何时执行什么旋转，而旋转是为了保证树的平衡。光改变节点颜色是不能起到任何作用的，旋转才是关键的操作，在新增节点或者删除节点之后，可能会破坏二叉树的平衡，那么何时执行旋转以及执行什么旋转，这是我们需要重点关注的。</p></blockquote><h2 id="红黑树插入"><a href="#红黑树插入" class="headerlink" title="红黑树插入"></a>红黑树插入</h2><p>往一个空的红黑树中，依次插入数据：<code>12 1 9 2 0 11 7 19 4</code><br>1.插入12</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/RB插入1.webp"></center><p>节点为根节点，所以为黑色，两个null节点为黑色节点。<br>2.插入 1</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/RB插入2.webp"></center><p>1小于12，所以是根节点的左孩子，如果为黑色，那么违反性质：从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。所以新增节点为红色。<br>3.插入 9</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/RB插入3.webp"></center><p>按照二叉搜索树的逻辑，9小于12、大于1，应该是1节点的右孩子。但，新增的两个NIL节点已经使得12，1，9，NI这条路径的黑色节点至少为两个，而12，NIL这条路径的黑色节点只有两个。所以要对1节点进行左旋，9节点变为12节点的左孩子，发现问题还是存在。继续，对12节点进行右旋，9节点为根节点，1、12分别为9节点的左右孩子。尝试着色，9节点必须为黑色，而1，12节点可以为红色，也可以为黑色。<br>4.插入 2</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/RB插入4.webp"></center><p>2大于1，直接作为1的右孩子即可。2的增加必然会增加两个黑色NIL节点，所以每条路径至少有三个黑色节点。则9，12，NIL这条路径中，12节点应该变为黑色；9，1，NIL这条路径中，1应该变为黑色。9，1，2，NIL这条路径中，2为空色来使得黑色节点个数为三个。验证一下，满足从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。则颜色调整完毕。<br>5.插入 0</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/RB插入5.webp"></center><p>0节点直接作为1节点的左孩子，保持跟2节点相同的颜色即可。左右子树依旧保持平衡。<br>6.插入 11</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/RB插入6.webp"></center><p>11节点作为12节点的左子树，颜色跟同一层的0，2节点保持一致即可。<br>7.插入 7</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/RB插入7.webp"></center><p>从二叉查找树的性质看，7节点作为2节点的右孩子即可。这时来分析着色问题，我们先看最短路径的黑色分布，9，12，NIL这条路径，有三个黑色节点，以此为参考，尝试改变9节点左子树的着色。目前最长的路径是9，1，2，7，NIL这条路径。保持三个黑色节点的话，9跟NIL已经为黑色节点，而红色节点又不能挨着，所以只能是1为红色节点，2为黑色节点，7为红色节点。那么9，1，0，NIIL这条路径，0就要为黑色节点。调整完毕。<br>8.插入 19</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/RB插入8.webp"></center><p>19节点作为12节点的右孩子，与左孩子保持一样的红色即可。<br>9.插入 4</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/RB插入9.webp"></center><p>4节点应该作为7节点的左子树，无论着什么颜色，以1节点为根节点的子树，都要破坏红黑性质。所以应该进行旋转。先以7为根节点进行一次右旋，再以2为根节点进行一次左旋。尝试着色即可。</p><blockquote><p>思维误区：把左右字数高度相差不能超过1加入到红黑树的性质中，这会导致推理逻辑发生错误。因为红黑树是用红黑着色来保证高度。<br>思维调整：先从二叉搜索树的角度对节点进行插入，然后从着色的角度对树进行旋转。</p></blockquote><h3 id="插入节点的五种情况"><a href="#插入节点的五种情况" class="headerlink" title="插入节点的五种情况"></a>插入节点的五种情况</h3><p>1.新节点N位于树的根上，没有父节点。<br>2.新节点的父节点P是黑色情形。<br>3.父节点P、叔叔节点U，都为红色。<br>4.父节点P是红色，叔叔节点U是黑色或NIL; 插入节点N是其父节点P的右孩子，而父节点P又是其父节点的左孩子。<br>5.父节点P是红色，而叔父节点U 是黑色或NIL，要插入的节点N 是其父节点的左孩子，而父节点P又是其父G的左孩子。</p><h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><p>B树,是一颗多路平衡查找树，但是它不是二叉树。我们描述一颗B树时需要指定它的阶数，所有结点的孩子结点的最大值称为B树的阶，阶数表示了一个结点<strong>最多</strong>有多少个孩子结点，一般用字母m表示阶数。当m取2时，就是我们常见的二叉搜索树。<br>由于B树是多叉结构，对于元素数量非常多的情况下，树的深度不会像二叉结构那么大，可以保证查询效率。</p><h2 id="B树定义"><a href="#B树定义" class="headerlink" title="B树定义"></a>B树定义</h2><p>一颗m阶的B树定义如下：<br>1.每个结点最多有$m-1$个关键字。<br>2.根结点最少可以只有1个关键字。<br>3.非根结点至少有$\left \lceil \frac{m}{2} \right \rceil -1$ 个关键字。<br>4.每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。<br>5.所有叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/B树.png"></center><p>上图是一颗阶数为4的B树。在<strong>实际应用中的B树的阶数m都非常大</strong>（通常大于100），所以即使存储大量的数据，B树的高度仍然比较小。每个结点中存储了关键字（key）和关键字对应的数据（data），以及孩子结点的指针。我们将一个key和其对应的data称为一个记录。但为了方便描述，除非特别说明，后续文中就用key来代替（key, value）键值对这个整体。在<strong>数据库中我们将B树（和B+树）作为索引结构，可以加快查询速度，此时B树中的key就表示键，而data表示了这个键对应的条目在硬盘上的逻辑地址</strong>。</p><h2 id="B树插入过程"><a href="#B树插入过程" class="headerlink" title="B树插入过程"></a>B树插入过程</h2><p><a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">B树插入</a></p><h2 id="B树删除过程"><a href="#B树删除过程" class="headerlink" title="B树删除过程"></a>B树删除过程</h2><p><a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">B树删除</a></p><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><blockquote><p>在一个B+树里：<br>只有最底层的节点（叶子节点）才保存信息，其它节点只是在搜索中用来指引到正确节点的。</p></blockquote><p>节点更多了，确实，你有了额外的节点，它们就是帮助你找到正确节点的『决策节点』,但是搜索复杂度还是在 O(log(N))。<br>对于B+树，不管查找成功与否，每次查找都是走了一条从根到叶子结点的路径。</p><h2 id="B-树定义"><a href="#B-树定义" class="headerlink" title="B+树定义"></a>B+树定义</h2><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/B+树.png"></center><p>这里我们采取维基百科上所定义的方式，即关键字个数比孩子结点个数小1，这种方式是和B树基本等价的。上图就是一颗阶数为4的B+树。<br>除此之外B+树还有以下的要求：<br>1.B+树包含2种类型的结点：内部结点（也称索引结点）和叶子结点。根结点本身即可以是内部结点，也可以是叶子结点。根结点的关键字个数最少可以只有1个。<br>2.B+树与B树最大的不同是内部结点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶子结点中。<br>3.m阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个子树），阶数m同时限制了叶子结点最多存储m-1个记录。<br>4.内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。<br>5.每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大<strong>顺序链接</strong>。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/14/%E6%A0%91-%E5%8E%9F%E7%90%86%E7%AF%87/3阶B+树.jpg"></center><h2 id="B-树插入过程"><a href="#B-树插入过程" class="headerlink" title="B+树插入过程"></a>B+树插入过程</h2><p><a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">B+树插入</a></p><h2 id="B树删除过程-1"><a href="#B树删除过程-1" class="headerlink" title="B树删除过程"></a>B树删除过程</h2><p><a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">B+树删除</a></p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://www.cnblogs.com/gaochundong/p/binary_search_tree.html" target="_blank" rel="noopener">BST</a><br><a href="https://www.cnblogs.com/maybe2030/p/4732377.html#_label1" target="_blank" rel="noopener">树</a><br><a href="https://blog.csdn.net/BaiHuaXiu123/article/details/52488443" target="_blank" rel="noopener">BST</a><br><a href="https://www.cnblogs.com/suimeng/p/4560056.html" target="_blank" rel="noopener">AVL</a><br><a href="https://zhuanlan.zhihu.com/p/56066942" target="_blank" rel="noopener">AVL</a><br><a href="https://www.cnblogs.com/songwenjie/p/8955856.html" target="_blank" rel="noopener">二叉树遍历</a><br><a href="https://blog.csdn.net/xiaoxiaoxuanao/article/details/61918125" target="_blank" rel="noopener">二叉树删除</a><br><a href="https://www.cnblogs.com/ysocean/p/8004211.html" target="_blank" rel="noopener">红黑树</a><br><a href="https://www.jianshu.com/p/d25e490e2441" target="_blank" rel="noopener">红黑树</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树的基本原理。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>面试-基础</title>
    <link href="http://yoursite.com/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/01/13/面试-基础/</id>
    <published>2020-01-13T07:48:01.000Z</published>
    <updated>2020-01-21T14:26:13.582Z</updated>
    
    <content type="html"><![CDATA[<p>面试中最基础的计网、操作系统以及数据库。</p><a id="more"></a><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/计网1_1.png">    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    font-size: 100%;    display: inline-block;    color: #999;    padding: 0px;">计算机网络体系分层结构</div></center><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。<br>所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/三次握手.png">    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 0px;">三次握手过程</div></center><p>1.TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了<code>LISTEN</code>（监听）状态；<br>2.TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位<code>SYN=1</code>，同时选择一个初始序列号<code>seq=x</code>，此时，TCP客户端进程进入了<code>SYN-SENT</code>（同步已发送状态）状态。<strong>TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</strong><br>3.TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 <code>ACK=1，SYN=1</code>，确认号是<code>ack=x+1</code>，同时也要为自己初始化一个序列号<code>seq=y</code>，此时，TCP服务器进程进入了<code>SYN-RCVD</code>（同步收到）状态。<strong>这个报文也不能携带数据，但是同样要消耗一个序号。</strong><br>4.TCP客户进程收到确认后，还要向服务器给出确认。确认报文的<code>ACK=1，ack=y+1</code>，自己的序列号<code>seq=x+1</code>，此时，TCP连接建立，客户端进入<code>ESTABLISHED</code>（已建立连接）状态。<strong>TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</strong><br>5.当服务器收到客户端的确认后也进入<code>ESTABLISHED</code>状态，此后双方就可以开始通信了。</p><h3 id="为什么TCP链接需要三次握手，两次不可以么"><a href="#为什么TCP链接需要三次握手，两次不可以么" class="headerlink" title="为什么TCP链接需要三次握手，两次不可以么"></a>为什么TCP链接需要三次握手，两次不可以么</h3><p>为了防止<strong>已失效的链接请求报文突然又传送到了服务端</strong>，因而产生错误。<br>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。<br>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/四次挥手.png">    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 0px;">四次挥手过程</div></center><p>1.客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，<code>FIN=1</code>，其序列号为<code>seq=u</code>（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入<code>FIN-WAIT-1</code>（终止等待1）状态。 <strong>TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</strong><br>2.服务器收到连接释放报文，发出确认报文，<code>ACK=1</code>，<code>ack=u+1</code>，并且带上自己的序列号<code>seq=v</code>，此时，服务端就进入了<code>CLOSE-WAIT</code>（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个<code>CLOSE-WAIT</code>状态持续的时间。<br>3.客户端收到服务器的确认请求后，此时，客户端就进入<code>FIN-WAIT-2</code>（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。<br>4.服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，<code>FIN=1</code>，<code>ack=u+1</code>，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为<code>seq=w</code>，此时，服务器就进入了<code>LAST-ACK</code>（最后确认）状态，等待客户端的确认。<br>5.客户端收到服务器的连接释放报文后，必须发出确认，<code>ACK=1</code>，<code>ack=w+1</code>，而自己的序列号是<code>seq=u+1</code>，此时，客户端就进入了<code>TIME-WAIT</code>（时间等待）状态。<strong>注意此时TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入<code>CLOSED</code>状态。</strong><br>6.服务器只要收到了客户端发出的确认，立即进入<code>CLOSED</code>状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p><h3 id="为什么客户端最后还要等待2-MSL"><a href="#为什么客户端最后还要等待2-MSL" class="headerlink" title="为什么客户端最后还要等待2*MSL"></a>为什么客户端最后还要等待2*MSL</h3><p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。<br>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。<br>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p><h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办</h3><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h2 id="Get与POST的区别"><a href="#Get与POST的区别" class="headerlink" title="Get与POST的区别"></a>Get与POST的区别</h2><p>1.从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；<br>2.从REST服务角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变；<br>3.从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的<code>header</code>中，以<code>?</code>分割URL和传输数据，参数之间以<code>&amp;</code>相连。特别地，如果数据是<code>英文字母/数字</code>，原样发送；否则，会将其编码为 <code>application/x-www-form-urlencoded MIME</code> 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用<code>BASE64</code>加密，得出如：<code>%E4%BD%A0%E5%A5%BD</code>，其中<code>％XX</code>中的<code>XX</code>为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的<code>body</code>中。<br>4.就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。<br>5.从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。</p><h2 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><p>计算机网络中的带宽、交换结点中的缓存和处理机等，都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏。这种情况就叫做拥塞。<br>拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。<strong>拥塞控制是一个全局性的过程，和流量控制不同，流量控制指点对点通信量的控制。</strong><br>发送方维持一个叫做<strong>拥塞窗口cwnd</strong>（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。<br>1.<strong>慢启动</strong>：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;一次传输轮次之后拥塞窗口就加倍。这就是乘法增长。<br> 为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：<br>当cwnd &lt; ssthresh时，使用慢启动算法。<br>当cwnd &gt; ssthresh时，改用拥塞避免算法。<br>当cwnd = ssthresh时，慢启动与拥塞避免算法任意。<br>2.<strong>拥塞避免</strong>：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。<br>无论是在慢启动阶段还是在拥塞避免阶段，只要发送方判断网络<strong>出现拥塞</strong>（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢启动门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如下图：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/慢启动.jpg"></center><p>这里只是为了讨论方便而将拥塞窗口大小的单位改为数据报的个数，实际上应当是字节。<br>3.<strong>快速重传</strong>：快速重传要求接收方在收到一个<strong>失序的报文段</strong>后就立即发出 重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快速重传算法规定，发送方只要一连收到<strong>三个重复确认</strong>就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。<br>4.<strong>快速恢复</strong>:当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢启动算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/快速恢复.jpg"></center><h2 id="从输入网址到获得页面的过程"><a href="#从输入网址到获得页面的过程" class="headerlink" title="从输入网址到获得页面的过程"></a>从输入网址到获得页面的过程</h2><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/123.jpg"></center><h2 id="IP地址分为哪几类"><a href="#IP地址分为哪几类" class="headerlink" title="IP地址分为哪几类"></a>IP地址分为哪几类</h2><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/IP分类.png"></center><h3 id="保留地址"><a href="#保留地址" class="headerlink" title="保留地址"></a>保留地址</h3><p>A类：10.0.0.0 - 10.255.255.255<br>B类：172.16.0.0 - 172.31.255.255<br>C类：192.168.0.0 - 192.168.255.255</p><h2 id="ARP协议的工作过程"><a href="#ARP协议的工作过程" class="headerlink" title="ARP协议的工作过程"></a>ARP协议的工作过程</h2><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/ARP.png"></center><h2 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h2><p>1×× : 请求处理中，请求已被接受，正在处理<br>2×× : 请求成功，请求被成功处理 <code>200 OK</code><br>3×× : 重定向，要完成请求必须进行进一步处理<br><code>301 : 永久性转移</code> <code>302 ：暂时性转移</code> <code>304 ：已缓存</code><br>4×× : 客户端错误，请求不合法<br><code>400：Bad Request,请求有语法问题</code> <code>403：拒绝请求</code> <code>404：客户端所访问的页面不存在</code><br>5×× : 服务器端错误，服务器不能处理合法请求<br><code>500 ：服务器内部错误</code> <code>503 ： 服务不可用，稍等</code></p><h2 id="简单说一下你了解的端口及对应的服务"><a href="#简单说一下你了解的端口及对应的服务" class="headerlink" title="简单说一下你了解的端口及对应的服务"></a>简单说一下你了解的端口及对应的服务</h2><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/端口.png"></center><h2 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h2><p>TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议，它们之间的区别包括：<br>TCP是面向连接的，UDP是无连接的；<br>TCP是可靠的，UDP是不可靠的；<br>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；<br>TCP是面向字节流的，UDP是面向报文的；<br>TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；<br>TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；</p><h2 id="HTTPS和HTTP的区别"><a href="#HTTPS和HTTP的区别" class="headerlink" title="HTTPS和HTTP的区别"></a>HTTPS和HTTP的区别</h2><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。<br>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。<br>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><h2 id="Session、Cookie-与-Application"><a href="#Session、Cookie-与-Application" class="headerlink" title="Session、Cookie 与 Application"></a>Session、Cookie 与 Application</h2><p>Cookie和Session都是客户端与服务器之间保持状态的解决方案，具体来说，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，而客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器，服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>同样地，会话状态也可以保存在服务器端。客户端请求服务器，如果服务器记录该用户状态，就获取Session来保存状态，这时，如果服务器已经为此客户端创建过session，服务器就按照sessionid把这个session检索出来使用；如果客户端请求不包含sessionid，则为此客户端创建一个session并且生成一个与此session相关联的sessionid，并将这个sessionid在本次响应中返回给客户端保存。保存这个sessionid的方式可以采用<strong>cookie机制</strong>，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器；若浏览器禁用Cookie的话，可以通过<strong>URL重写机制</strong>将sessionid传回服务器。</p><h3 id="Session-与-Cookie-的对比"><a href="#Session-与-Cookie-的对比" class="headerlink" title="Session 与 Cookie 的对比"></a>Session 与 Cookie 的对比</h3><p>1.实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；<br>2.大小限制：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；<br>3.安全性：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；<br>4.服务器资源消耗：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。</p><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>Application（Java Web中的ServletContext）：与一个Web应用程序相对应，为应用程序提供了一个全局的状态，所有客户都可以使用该状态。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">TCP的三次握手与四次挥手</a><br><a href="https://blog.csdn.net/justloveyou_/article/details/78303617" target="_blank" rel="noopener">计算机网络面试问题集锦</a><br><a href="https://zhuanlan.zhihu.com/p/24001696" target="_blank" rel="noopener">计算机网络</a></p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="并发与并行区别"><a href="#并发与并行区别" class="headerlink" title="并发与并行区别"></a>并发与并行区别</h2><p>并发（concurrency）：把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行。(同一时间段)<br>并行（parallelism）：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行。(同一时刻)</p><h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h3><p>是指允许多个作业（程序）同时进入计算机系统的内存并启动交替计算的方法。也就是说，内存中多个相互独立的程序均处于开始和结束之间。<br>从宏观上看是并行的，多道程序都处于运行过程中，但尚未运行结束；<br>从微观角度上看是串行的，各道程序轮流的占用CPU交替的执行。<br>引入多道程序设计技术可以提高CPU的利用率，充分发挥计算机硬部件的并行性。</p><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。进程是一种数据结构。<br>第二，进程是一个 “执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程。<br><strong>进程最基本的特征是并发和共享特征</strong></p><h4 id="进程类型"><a href="#进程类型" class="headerlink" title="进程类型"></a>进程类型</h4><p>系统进程：操作系统用来管理资源的进程，当系统进程处于运行态时，CPU处于管态，系统之间的关系由操作系统负责。<br>用户进程：操作系统可以独立执行的的用户程序段，当用户进程处于运行态时，CPU处于目态，用户进程之间的关系由用户负责。</p><h4 id="进程的三个组成部分"><a href="#进程的三个组成部分" class="headerlink" title="进程的三个组成部分"></a>进程的三个组成部分</h4><p>1.程序<br>2.数据<br>3.进程控制块（PCB）：为了管理和控制进程，系统在创建每个进程时，都为其开辟一个专用的存储区，用以记录它在系统中的动态特性。系统根据存储区的信息对进程实施控制管理。进程任务完成后，系统收回该存储区，进程随之消亡，这一存储区就是进程控制块<br>PCB随着进程的创建而建立，撤销而消亡。系统根据PCB感知一个进程的存在，<strong>PCB是进程存在的唯一物理标识</strong>（这一点可以类比作业控制块JCB）</p><h4 id="进程的三个状态"><a href="#进程的三个状态" class="headerlink" title="进程的三个状态"></a>进程的三个状态</h4><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/进程状态.png"></center><p>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源；<br>运行状态：占用处理机资源运行，<strong>处于此状态的进程数小于等于CPU数</strong>；<br>阻塞状态： 进程等待某种条件，在条件满足之前无法执行；</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><blockquote><p>如果说操作系统中引入进程的目的是为了使多个程序并发执行，以便改善资源利用率和提高系统效率，那么，在进程之后再引入线程概念则是为了减少程序并发执行时所付出的时空开销，使得并发粒度更细、并发性更好。解决问题的基本思路是：把进程的两项功能“独立分配资源”和“被调度分配执行”分离开来，前一项任务仍然由进程完成，作为系统资源分配和保护的独立单位，无须频繁切换；后一项任务交给称作线程的实体来完成，线程作为系统调度和分配的基本单位，会被频繁的调度和切换。在这种思想的指导下产生了多线程的概念，及多线程(结构)进程。</p></blockquote><h4 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h4><p>线程，有时被称为轻量进程(Lightweight Process，LWP），是程序执行流的最小单元。是被系统独立调度和分派的基本单位。<br>一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。</p><h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p>在 Java虚拟机 中，线程从最初的创建到最终的消亡，要经历若干个状态：创建(new)、就绪(runnable)、运行(running)、阻塞(blocked)和死亡(dead)。在给定的时间点上，一个线程只能处于一种状态。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/线程状态.png"></center><h3 id="进程与程序区别"><a href="#进程与程序区别" class="headerlink" title="进程与程序区别"></a>进程与程序区别</h3><p>1.进程是一个动态的概念<br>进程是程序的一次执行过程，是动态概念<br>程序是一组有序的指令和数据集和，是静态概念<br>2.进程有自己的生命周期<br>当操作系统要完成某个任务时，它会创建一个进程。当进程完成任务之后，系统就会撤销这个进程，收回它所占用的资源。从创建到撤销的时间段就是进程的生命周期。而程序可以作为一种软件资料永久保存。<br>3.进程之间存在并发性<br>进程是一个动态的概念，是一个可以独立运行的单位。在一个系统中，同时会存在多个进程。他们轮流占用CPU和各种资源。<br>4.进程与程序之间无一一对应关系<br>不同的进程可以包含同一程序，同一程序在执行中也可以产生多个进程。<br>不同的进程可以执行同一个程序。<br><strong>区分进程的条件：所执行的程序和数据集合。</strong><br>两个进程即使执行在相同的程序上，只要他们运行在不同的数据集合上，他们也是两个进程。<br>5.进程间存在着相互制约<br>进程是系统中资源分配和运行调度的单位，在对资源的共享和竞争中，必然相互制约，影响各自向前推进的速度。<br>6.程序是记录在介质上指令的有序集合，而进程则由程序、数据和进程控制块(Process Control Block, PCB)3部分组成<br>7.进程可以创建子进程，程序不能创建子程序<br>一个用户进程在运行过程中可以创建一个或多个子进程为其服务。当一个进程创建另一个进程时，生成进程称为父进程，被生成进程称为子进程，父进程还可以创建多个子进程，从而形成树状族系关系。</p><h3 id="线程与进程联系"><a href="#线程与进程联系" class="headerlink" title="线程与进程联系"></a>线程与进程联系</h3><p>从一定意义上讲，进程就是一个应用程序在处理机上的一次执行过程，它是一个动态的概念，而线程是进程中的一部分，进程包含多个线程在运行。 程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程。 通常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源。在引入线程的操作系统中，<strong>通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位</strong>。由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统内多个程序间并发执行的程度。</p><h3 id="线程与进程区别"><a href="#线程与进程区别" class="headerlink" title="线程与进程区别"></a>线程与进程区别</h3><blockquote><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，<strong>一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮</strong>，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p></blockquote><p>一个程序至少有一个进程, 一个进程至少有一个线程。<br>线程的划分尺度小于进程，使得多线程程序的并发性高。<br>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。<br>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p><h2 id="进程间的通信的几种方式"><a href="#进程间的通信的几种方式" class="headerlink" title="进程间的通信的几种方式"></a>进程间的通信的几种方式</h2><h3 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道(pipe)"></a>管道(pipe)</h3><p>匿名管道(pipe)：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。<br>流管道(s_pipe): 去除了第一种限制,可以双向传输。<br>命名管道(name_pipe):克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</p><h3 id="信号量-semophore"><a href="#信号量-semophore" class="headerlink" title="信号量(semophore)"></a>信号量(semophore)</h3><p>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><h3 id="消息队列-message-queue"><a href="#消息队列-message-queue" class="headerlink" title="消息队列(message queue)"></a>消息队列(message queue)</h3><p>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p><h3 id="信号（signal）"><a href="#信号（signal）" class="headerlink" title="信号（signal）"></a>信号（signal）</h3><p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。主要作为进程间以及同一进程不同线程之间的同步手段。</p><h3 id="共享内存-shared-memory"><a href="#共享内存-shared-memory" class="headerlink" title="共享内存(shared memory)"></a>共享内存(shared memory)</h3><p>可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。</p><h3 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h3><p>这是一种更为一般的进程间通信机制，，与其他通信机制不同的是，它可用于不同机器间的进程通信。</p><h2 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h2><p>线程的最大特点是资源的共享性，但资源共享中的同步问题是多线程编程的难点。Linux下提供了多种方式来处理线程同步，最常用的是互斥锁、条件变量、信号量和读写锁。</p><h3 id="互斥锁（mutex）"><a href="#互斥锁（mutex）" class="headerlink" title="互斥锁（mutex）"></a>互斥锁（mutex）</h3><p>锁机制是同一时刻只允许一个线程执行一个关键部分的代码，通过锁机制实现线程间的同步。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</p><h3 id="条件变量（cond）"><a href="#条件变量（cond）" class="headerlink" title="条件变量（cond）"></a>条件变量（cond）</h3><p>条件变量是用来等待而不是用来上锁的，是利用线程间共享全局变量进行同步的一种机制。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。条件变量分为两部分: 条件和变量。条件本身是由互斥量保护的。线程在改变条件状态前先要锁住互斥量。条件变量使我们可以睡眠等待某种条件出现。</p><h3 id="信号量-Semphare"><a href="#信号量-Semphare" class="headerlink" title="信号量(Semphare)"></a>信号量(Semphare)</h3><p>它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。信号量函数的名字都以<code>sem_</code>打头。</p><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁与互斥量的功能类似，对临界区的共享资源进行保护。互斥量一次只让一个线程进入临界区，读写锁比它有更高的并行性。读写锁适合于对数据结构的读次数比写次数多得多的情况。因为, 读模式锁定时可以共享, 以写模式锁住时意味着独占, 所以读写锁又叫共享-独占锁。<br>读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者：<br>如果读写锁当前没有读者，也没有写者，那么写者可以立刻获得读写锁，否则它必须自旋在那里，直到没有任何写者或读者。如果读写锁没有写者，那么读者可以立即获得该读写锁，否则读者必须自旋在那里，直到写者释放该读写锁。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁是一个互斥设备，它只有两个值：“锁定”和“解锁”。如果锁可用，则“锁定”被设置，而代码继续进入临界区；相反，如果锁被其他人获得，则代码进入忙循环（而不是休眠，这也是自旋锁和一般锁的区别）并重复检查这个锁，直到该锁可用为止，这就是自旋的过程。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁定义"><a href="#死锁定义" class="headerlink" title="死锁定义"></a>死锁定义</h3><p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去</p><h3 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h3><p>（1）互斥：一个资源每次只能被一个进程使用。<br>（2）请求和保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>（3）不可抢占:进程已获得的资源，在末使用完之前，不能强行剥夺。<br>（4）循环等待:若干进程之间形成一种头尾相接的循环等待资源关系。</p><h3 id="产生死锁原因"><a href="#产生死锁原因" class="headerlink" title="产生死锁原因"></a>产生死锁原因</h3><p>（1）因为系统资源不足。<br>（2）进程运行推进的顺序不合适。<br>（3）资源分配不当等。</p><h3 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h3><p>解决死锁的基本方法主要有预防死锁、避免死锁、检测死锁、解除死锁 、鸵鸟策略 等</p><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p>死锁预防的基本思想是：只要确保死锁发生的四个必要条件中至少有一个不成立，就能预防死锁的发生。</p><h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p>死锁解除的常用两种方法为进程终止和资源抢占。所谓进程终止是指简单地终止一个或多个进程以打破循环等待，包括两种方式：终止所有死锁进程和一次只终止一个进程直到取消死锁循环为止；所谓资源抢占是指从一个或多个死锁进程那里抢占一个或多个资源。其中最具有代表性的避免死锁算法是银行家算法。</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。</p><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>段是按照程序的自然分界划分的长度可以动态改变的区域。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中（写c程序时会用到），并且每个程序可以有多个相同类型的段。将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。</p><h3 id="分页与分段区别"><a href="#分页与分段区别" class="headerlink" title="分页与分段区别"></a>分页与分段区别</h3><p><strong>目的不同</strong>：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；<br><strong>大小不同</strong>：页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；而段的长度却不固定，由其所完成的功能决定；<br><strong>地址空间不同</strong>： 分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间则是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。<br><strong>信息共享</strong>：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；<br><strong>内存碎片</strong>：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。</p><h3 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h3><p>分页系统能有效地提高内存的利用率，而分段系统能反映程序的逻辑结构，便于段的共享与保护，将分页与分段两种存储方式结合起来，就形成了段页式存储管理方式。<br>在段页式存储管理系统中，作业的地址空间首先被分成若干个逻辑分段，每段都有自己的段号，然后再将每段分成若干个大小相等的页。对于主存空间也分成大小相等的页，主存的分配以页为单位。<br>为实现段页式存储管理，系统应为每个进程设置一个段表，包括每段的段号，该段的页表始址和页表长度。每个段有自己的页表，记录段中的每一页的页号和存放在主存中的物理块号。段页式系统中，作业的地址结构包含三部分的内容：段号，页号，页内位移量。</p><h2 id="操作系统中进程调度策略"><a href="#操作系统中进程调度策略" class="headerlink" title="操作系统中进程调度策略"></a>操作系统中进程调度策略</h2><h3 id="FCFS-先来先服务"><a href="#FCFS-先来先服务" class="headerlink" title="FCFS(先来先服务)"></a>FCFS(先来先服务)</h3><p>队列实现，非抢占的，先请求CPU的进程先分配到CPU</p><h3 id="SJF-最短作业优先调度算法"><a href="#SJF-最短作业优先调度算法" class="headerlink" title="SJF(最短作业优先调度算法)"></a>SJF(最短作业优先调度算法)</h3><p>对预计执行时间短的进程优先分派处理机。通常后来的短进程不抢先正在执行的进程，对长进程非常不利。</p><h3 id="高响应比优先法-HRRN"><a href="#高响应比优先法-HRRN" class="headerlink" title="高响应比优先法(HRRN)"></a>高响应比优先法(HRRN)</h3><p>CFS方式只考虑每个作业的等待时间而未考虑执行时间的长短，而SJF方式只考虑执行时间而未考虑等待时间的长短。HRRN调度策略同时考虑每个作业的等待时间长短和估计需要的执行时间长短，从中选出响应比最高的作业投入执行。这种算法是介于FCFS和SJF之间的一种折中算法。</p><h3 id="高优先级调度算法"><a href="#高优先级调度算法" class="headerlink" title="高优先级调度算法"></a>高优先级调度算法</h3><p>可以是抢占的，也可以是非抢占的。优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：老化</p><h3 id="时间片轮转算法（RR，Round-Robin）"><a href="#时间片轮转算法（RR，Round-Robin）" class="headerlink" title="时间片轮转算法（RR，Round-Robin）"></a>时间片轮转算法（RR，Round-Robin）</h3><p>可抢占的，队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。</p><h3 id="多级队列调度算法"><a href="#多级队列调度算法" class="headerlink" title="多级队列调度算法"></a>多级队列调度算法</h3><p>将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。</p><h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><p>与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。</p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>虚拟内存允许执行进程不必完全在内存中。<br>每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。<br>这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上。<br>注意，请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。</p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="最佳置换算法（OPT）"><a href="#最佳置换算法（OPT）" class="headerlink" title="最佳置换算法（OPT）"></a>最佳置换算法（OPT）</h4><p>这是一种理想情况下的页面置换算法，但实际上是不可能实现的。保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。</p><h4 id="先进先出置换算法（FIFO）"><a href="#先进先出置换算法（FIFO）" class="headerlink" title="先进先出置换算法（FIFO）"></a>先进先出置换算法（FIFO）</h4><p>最简单的页面置换算法，总是选择在主存中停留时间最长（即最老）的一页置换，即先进入内存的页，先退出内存。</p><h4 id="最近最久未使用算法（LRU，Least-recently-use）"><a href="#最近最久未使用算法（LRU，Least-recently-use）" class="headerlink" title="最近最久未使用算法（LRU，Least recently use）"></a>最近最久未使用算法（LRU，Least recently use）</h4><p>当需要置换一页时，选择在最近一段时间里最久没有使用过的页面予以置换。</p><h4 id="最近最少使用置换算法（LFU，Least-frequently-use）"><a href="#最近最少使用置换算法（LFU，Least-frequently-use）" class="headerlink" title="最近最少使用置换算法（LFU，Least frequently use）"></a>最近最少使用置换算法（LFU，Least frequently use）</h4><p>基于“如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小”的思路。</p><h3 id="颠簸"><a href="#颠簸" class="headerlink" title="颠簸"></a>颠簸</h3><p>颠簸本质上是指频繁的页调度行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此，会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）。</p><h2 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者-消费者模型"></a>生产者-消费者模型</h2><p>生产者-消费者模式是一个十分经典的多线程并发协作的模式，所谓生产者-消费者问题，实际上主要是包含了两类线程，一种是生产者线程用于生产数据，另一种是消费者线程用于消费数据，为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库，生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为；而消费者只需要从共享数据区中去获取数据，就不再需要关心生产者的行为。但是，这个共享数据区域中应该具备这样的线程间并发协作的功能：<br>1.如果共享数据区已满的话，阻塞生产者继续生产数据放置入内；<br>2.如果共享数据区为空的话，阻塞消费者继续消费数据；</p><h2 id="并发编程问题"><a href="#并发编程问题" class="headerlink" title="并发编程问题"></a>并发编程问题</h2><p>多线程并发执行的时候会遇到各种各样的挑战：</p><h3 id="上下文切换问题"><a href="#上下文切换问题" class="headerlink" title="上下文切换问题"></a>上下文切换问题</h3><p>CPU通过给每个线程分配CPU时间片来实现多线程任务之间的并发执行。CPU通过时间片分配算法来循环执行任务，当CPU为当前线程分配的时间片消耗完（时间片一般是几十ms），CPU会切出去执行另外的一个线程（<strong>切换会有消耗时间</strong>），但是在CPU切换出去之前，会保存上一个任务的状态，以便下次切换回这个线程的时候能够紧接着保存的状态继续向下执行任务。我们称线程任务从保存到再次被执行的过程为一次上下文切换。</p><blockquote><p>为什么数据量小的时候并发执行的效率会慢呢：<br>1.线程创建会有开销<br>2.上下文切换也会有开销</p></blockquote><h3 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h3><h3 id="资源限制问题"><a href="#资源限制问题" class="headerlink" title="资源限制问题"></a>资源限制问题</h3><p>资源限制是指在进行并发编程的时候，程序的执行速度受限于计算机的硬件资源和软件资源，比如服务器的带宽只有2Mb/s，某个资源的下载速度是1Mb/s，开启10个线程下载，速度不会变成10Mb/s。<br> <strong>硬件资源限制：</strong><br>1.带宽的上传/下载速度<br>2.硬盘的读写速度<br>3.CPU的处理速度<br><strong>软件资源限制：</strong><br>1.数据库连接数<br>2.socket连接数（就是多少个用户连接你这台服务器）</p><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。</p><blockquote><p>乐观锁一般会使用版本号机制或CAS算法实现。</p></blockquote><h4 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h4><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p><blockquote><p>举一个简单的例子：<br>1.假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为<code>$100</code>。<br>2.操作员A此时将其读出（version=1），并从其帐户余额中扣除<code>$50</code>（<code>$100-$50</code>）。<br>3.在操作员 A 操作的过程中，操作员B 也读入此用户信息（version=1），并从其帐户余额中扣除<code>$2</code>0（<code>$100-$20</code>）。<br>4.操作员 A 完成了修改工作，将数据版本号加一（version=2），连同帐户扣除后余额（<code>balance=$50</code>），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。<br>5.操作员 B 完成了操作，也将版本号加一（version=2）试图向数据库提交数据（<code>balance=$80</code>），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足<strong>提交版本必须大于记录当前版本才能执行更新</strong>的乐观锁策略，因此，操作员 B 的提交被驳回。</p></blockquote><p>这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</p><h4 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h4><p>即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数:<br><code>需要读写的内存值 V</code> <code>进行比较的值 A</code> <code>拟写入的新值 B</code><br>当且仅当V的值等于A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作。</p><h5 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h5><p><strong>ABA 问题</strong>：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。<br><strong>循环时间长开销大</strong>:自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。<br><strong>只能保证一个共享变量的原子操作</strong>：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p><h3 id="两种锁使用场景"><a href="#两种锁使用场景" class="headerlink" title="两种锁使用场景"></a>两种锁使用场景</h3><p>两种锁各有优缺点，乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p><h2 id="参考文档-1"><a href="#参考文档-1" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://blog.csdn.net/justloveyou_/article/details/78304294" target="_blank" rel="noopener">操作系统面试问题集锦</a><br><a href="https://zhuanlan.zhihu.com/p/60248566" target="_blank" rel="noopener">进程、线程</a><br><a href="https://www.cnblogs.com/wkfvawl/p/11512407.html" target="_blank" rel="noopener">进程的状态与转换</a><br><a href="https://blog.csdn.net/bupt_tinyfisher/article/details/8939689" target="_blank" rel="noopener">分段和分页内存管理</a><br><a href="https://juejin.im/post/5b4977ae5188251b146b2fc8" target="_blank" rel="noopener">乐观锁与悲观锁</a></p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="事务四大特性-ACID"><a href="#事务四大特性-ACID" class="headerlink" title="事务四大特性(ACID)"></a>事务四大特性(ACID)</h2><blockquote><p>事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。<br>个人理解，事务就是对一个事件的操作。</p></blockquote><p><strong>原子性</strong>（Atomicity）:要么全部执行，要么全部不执行。 如果事务崩溃，状态回到事务之前（事务回滚），就像这个事务从来没有执行过一样。。<br><strong>一致性</strong>（Consistency）:在事务开始之前和事务结束以后，数据的数据的一致性约束没有被破坏。几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致。<br><strong>隔离性</strong>（Isolation）:数据库允许多个并发事务同时对数据进行读写和修改的能力。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。<br><strong>持久性</strong>（Durability）:事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p><h2 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h2><p>数据库针对事务的四种特性，为我们提供的四种隔离级别，由低到高依次为Read uncommitted(未提交读)、Read committed(提交读)、Repeatable read(可重复读)、Serializable(可串行化)，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/数据库隔离.png"></center><p><strong>脏读</strong>：(读取未提交数据)A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。<br><strong>不可重复读</strong>：(前后多次读取，数据内容不一致)事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间 。而在事务A第一次读取数据后，事务B执行更改操作，此时事务A第二次读取，发现其和之前的数据不一样了，也就是数据不重复了，系统不可以读取到重复的数据，称为不可重复读。<br><strong>幻读</strong>:(前后多次读取，数据总量不一致)事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据，称为幻读。</p><h2 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h2><p>第一范式：要求有主键(不能出现重复记录)，并且要求每一个字段原子性不可再分。<strong>1NF是所有关系型数据库的最基本要求</strong><br>第二范式：在1NF的基础之上,要求所有非主键字段完全依赖主键，不能产生部分依赖<br>第三范式：在2NF的基础之上,所有非主键字段和主键字段之间不能产生传递依赖<br>| 级别  | 概念              |<br>|——-|————————-|<br>| 1NF | 属性不可分           |<br>| 2NF | 非主键属性完全依赖于主键属性 |<br>| 3NF | 非主键属性无传递依赖      |</p><blockquote><p>为了保证数据库的ACID特性，我们必须尽量按照其要求的范式进行设计，关系型数据库中的表都是存储一个格式化的数据结构。每个元组字段的组成都是一样，即使不是每个元组都需要所有的字段，但数据库会为每个元组分配所有的字段，这样的结构可以便于标语表之间进行链接等操作，但从另一个角度来说它也是关系型数据库性能瓶颈的一个因素。</p></blockquote><h2 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h2><p>索引是对数据库表中一个或多个列的值进行排序的数据结构，以协助<strong>快速查询、更新数据库表中数据</strong>。索引的实现通常使用B树及其变种B+树。<br>为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/索引1.png"></center><p>上图显示了一种索引方式。左边是数据库中的数据表，有col1和col2两个字段，一共有15条记录；右边是以col2列为索引列的B_TREE索引，每个节点包含索引的键值和对应数据表地址的指针，这样就可以都过B_TREE在 $O(log n)$ 的时间复杂度内获取相应的数据，这样明显地加快了检索的速度。</p><h3 id="索引的底层实现原理和优化"><a href="#索引的底层实现原理和优化" class="headerlink" title="索引的底层实现原理和优化"></a>索引的底层实现原理和优化</h3><p>在数据结构中，我们最为常见的搜索结构就是二叉搜索树和AVL树(高度平衡的二叉搜索树，为了提高二叉搜索树的效率，减少树的平均搜索长度)了。然而，无论二叉搜索树还是AVL树，当数据量比较大时，都会由于树的深度过大而造成I/O读写过于频繁，进而导致查询效率低下，因此对于索引而言，多叉树结构成为不二选择。特别地，B树的各种操作能使B树保持较低的高度，从而保证高效的查找效率。</p><p>由于B树的高检索效率，B树主要应用在文件系统和数据库中，对于存储在硬盘上的大型数据库文件，可以极大程度减少访问硬盘次数，大幅度提高数据检索效率。<br>可以对B+树进行两种查找运算：一种是从最小关键字起顺序查找，另一种是从根节点开始，进行随机查找。</p><h3 id="为什么说B-树比B树更适合实际应用中操作系统的文件索引和数据库索引"><a href="#为什么说B-树比B树更适合实际应用中操作系统的文件索引和数据库索引" class="headerlink" title="为什么说B+树比B树更适合实际应用中操作系统的文件索引和数据库索引"></a>为什么说B+树比B树更适合实际应用中操作系统的文件索引和数据库索引</h3><p><font color="#dd0000">B+tree的磁盘读写代价更低</font>:B+tree的内部结点并没有指向关键字具体信息的指针，因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了；</p><p><font color="#dd0000">B+tree的查询效率更加稳定</font>：由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，所以，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；</p><p><font color="#dd0000">数据库索引采用B+树而不是B树的主要原因</font>：B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低。</p><h3 id="文件索引和数据库索引为什么使用B-树"><a href="#文件索引和数据库索引为什么使用B-树" class="headerlink" title="文件索引和数据库索引为什么使用B+树"></a>文件索引和数据库索引为什么使用B+树</h3><p>文件与数据库都是需要较大的存储，也就是说，它们都不可能全部存储在内存中，故需要存储到磁盘上。而所谓索引，则为了数据的快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，因此B+树相比B树更为合适。数据库系统巧妙利用了局部性原理与磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，而红黑树这种结构，高度明显要深的多，并且由于逻辑上很近的节点(父子)物理上可能很远，无法利用局部性。最重要的是，B+树还有一个最大的好处：方便扫库。B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持，这是数据库选用B+树的最主要原因。</p><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><p>1.<font color="#dd0000">大大加快数据的检索速度</font>,这也是创建索引的最主要的原因；<br>2.加速表和表之间的连接；<br>3.在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间；<br>4.通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；</p><h3 id="索引的缺点"><a href="#索引的缺点" class="headerlink" title="索引的缺点"></a>索引的缺点</h3><p>1.时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；<br>2.空间方面：索引需要占物理空间。</p><h3 id="创建索引时需要注意什么"><a href="#创建索引时需要注意什么" class="headerlink" title="创建索引时需要注意什么"></a>创建索引时需要注意什么</h3><p><font color="#dd0000">非空字段</font>：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</p><p><font color="#dd0000">取值离散大的字段</font>：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</p><p><font color="#dd0000">索引字段越小越好</font>：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</p><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p>普通索引和唯一性索引：索引列的值的唯一性</p><p>单个索引和复合索引：索引列所包含的列数</p><p>聚集索引与非聚集索引：聚集索引按照数据的物理存储进行划分的。对于一堆记录来说，使用聚集索引就是对这堆记录进行堆划分，即主要描述的是物理上的存储。正是因为这种划分方法，导致聚集索引必须是唯一的。聚集索引可以帮助把很大的范围，迅速减小范围。但是查找该记录，就要从这个小范围中Scan了；而非聚集索引是把一个很大的范围，转换成一个小的地图，然后你需要在这个小地图中找你要寻找的信息的位置，最后通过这个位置，再去找你所需要的记录。</p><blockquote><p>主键是一种特殊的唯一性索引，其可以是聚集索引，也可以是非聚集索引。</p></blockquote><h2 id="主键、自增主键、主键索引与唯一索引"><a href="#主键、自增主键、主键索引与唯一索引" class="headerlink" title="主键、自增主键、主键索引与唯一索引"></a>主键、自增主键、主键索引与唯一索引</h2><p>主键：指字段<strong>唯一、不为空值</strong>的列；</p><p>主键索引：指的就是主键，主键是索引的一种，是唯一索引的特殊类型。创建主键的时候，数据库默认会为主键创建一个唯一索引；</p><p>自增主键：字段类型为数字、自增、并且是主键；</p><p>唯一索引：索引列的值必须唯一，但允许有空值。<font color="#dd0000">主键是唯一索引，这样说没错；但反过来说，唯一索引也是主键就错误了，因为唯一索引允许空值，主键不允许有空值，所以不能说唯一索引也是主键。</font></p><h2 id="主键和索引的区别"><a href="#主键和索引的区别" class="headerlink" title="主键和索引的区别"></a>主键和索引的区别</h2><p>1:主键是为了标识数据库记录唯一性,不允许记录重复,且键值不能为空,主键也是一个特殊索引。<br>2:数据表中只允许有一个主键,但是可以有多个索引。<br>3.使用主键会数据库会自动创建主索引,也可以在非主键上创建索引,方便查询效率。<br>4:索引可以提高查询速度,它就相当于字典的目录,可以通过它很快查询到想要的结果,而不需要进行全表扫描。<br>5:主键索引外索引的值可以为空。<br>6:主键也可以由多个字段组成,组成复合主键,同时主键肯定也是唯一索引。<br>7:唯一索引则表示该索引值唯一,可以由一个或几个字段组成,一个表可以有多个唯一索引。</p><h2 id="关系型数据库和非关系型数据库"><a href="#关系型数据库和非关系型数据库" class="headerlink" title="关系型数据库和非关系型数据库"></a>关系型数据库和非关系型数据库</h2><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><p>关系型数据库，是指采用了关系模型来组织数据的数据库。简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>1、容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；<br>2、使用方便：通用的SQL语言使得操作关系型数据库非常方便；<br>3、易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；<br>4、支持SQL，可用于复杂的查询。<br>5、支持事务</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>1、为了维护一致性所付出的巨大代价就是其读写性能比较差；<br>2、固定的表结构；<br>3、不支持高并发读写需求；<br>4、不支持海量数据的高效率读写</p><blockquote><p>对网站来说，关系型数据库的很多特性不再需要了<br>必须强调的是，数据的持久存储，尤其是海量数据的持久存储，还是需要关系数据库这员老将。</p></blockquote><h3 id="非关系数据库"><a href="#非关系数据库" class="headerlink" title="非关系数据库"></a>非关系数据库</h3><p>使用键值对存储数据；分布式。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>1、无需经过sql层的解析，读写性能很高<br>2、基于键值对，数据没有耦合性，容易扩展<br>3、存储数据的格式：nosql的存储格式是key,value形式</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>1、不提供sql支持</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><h5 id="列式数据库"><a href="#列式数据库" class="headerlink" title="列式数据库"></a>列式数据库</h5><p>传统关系型数据库是按照行来存储数据库，称为“行式数据库”。列式数据库是按照列来存储数据，主要适合于批量数据处理和即时查询。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/13/%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/列式数据库.webp"></center><blockquote><p>常见的列式数据库有HBase、BigTable</p></blockquote><p>特性：高效的储存空间利用率、查询效率高、适合做聚合操作、适合大量的数据而不是小数据</p><h5 id="K-V数据库"><a href="#K-V数据库" class="headerlink" title="K-V数据库"></a>K-V数据库</h5><p>指的是使用键值(key-value)存储的数据库，其数据按照键值对的形式进行组织、索引和存储。<br>KV 存储非常适合不涉及过多数据关系业务关系的数据，同时能有效减少读写磁盘的次数，比 SQL 数据库存储拥有更好的读写性能，能够解决关系型数据库无法存储数据结构的问题。</p><blockquote><p>常见 K-V数据库:Redis、Cassandra、LevelDB</p></blockquote><p>特性：</p><ul><li>性能极高：Redis能支持超过10W的TPS</li><li>丰富的数据类型： Redis支持包括String，Hash，List，Set，Sorted Set，Bitmap和hyperloglog</li><li>丰富的特性：Redis还支持 publish/subscribe, 通知, key 过期等等特性</li></ul><h5 id="文档数据库"><a href="#文档数据库" class="headerlink" title="文档数据库"></a>文档数据库</h5><p>文档数据库（也称为文档型数据库）是旨在将半结构化数据存储为文档的一种数据库。文档数据库通常以 JSON 或 XML 格式存储数据。<br>由于文档数据库的no-schema特性，可以存储和读取任意数据。</p><blockquote><p>常见文档数据库:MongoDB、CouchDB</p></blockquote><h2 id="基本的增删查改SQL语句"><a href="#基本的增删查改SQL语句" class="headerlink" title="基本的增删查改SQL语句"></a>基本的增删查改SQL语句</h2><h3 id="插入数据insert"><a href="#插入数据insert" class="headerlink" title="插入数据insert"></a>插入数据insert</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">向表中制定字段添加数据：</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表 (字段名<span class="number">1</span>，字段名<span class="number">2.</span>.....) <span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2.</span>.....);</span><br><span class="line">向表中所有字段添加数据：</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表  <span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2.</span>.....)；</span><br></pre></td></tr></table></figure><h3 id="修改数据-update"><a href="#修改数据-update" class="headerlink" title="修改数据 update"></a>修改数据 update</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修改数据：</span><br><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段名<span class="number">1</span>=值<span class="number">1</span>，字段名<span class="number">2</span>=值<span class="number">2</span>；</span><br><span class="line">带条件的修改数据：</span><br><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段名<span class="number">1</span>=值<span class="number">1</span>，字段名<span class="number">2</span>=值<span class="number">2</span> <span class="keyword">where</span> 条件；</span><br></pre></td></tr></table></figure><h3 id="删除数据delete"><a href="#删除数据delete" class="headerlink" title="删除数据delete"></a>删除数据delete</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">带条件的删除语句：</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件]；</span><br></pre></td></tr></table></figure><blockquote><p>delete from 表名；和truncate table 表名；的区别:<br>从删除方式来说delete是一条一条的删除记录，不会去清空auto_increment记录数。而truncate则是直接将表删除重新建一个表，auto-increment将会被清空没有记录。<br>从事物方面来说delete删除的数据在一个事物内还能够找回，而truncate删除的数据是找不回来的。</p></blockquote><h3 id="查询数据-select"><a href="#查询数据-select" class="headerlink" title="查询数据 select"></a>查询数据 select</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查询语句的基本语法：</span><br><span class="line"><span class="keyword">select</span> [<span class="keyword">distinct</span>] * 或者 字段名<span class="number">1</span>，字段名<span class="number">2</span> <span class="keyword">from</span> 表 [<span class="keyword">where</span> 条件];</span><br></pre></td></tr></table></figure><blockquote><p>distinct这个关键字在你使用的时候需要注意一下，当你查询的字段值只有一个的时候它会去掉这一个字段中 所有相同的数据如果你要是查询的是多个字段那么它会根据你的这两个字段来进行查询除非是这两个字段中的数据同时与其他的数据相同才会去除重复的。</p></blockquote><h2 id="参考文档-2"><a href="#参考文档-2" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://blog.csdn.net/qq_22222499/article/details/79060495" target="_blank" rel="noopener">数据库常见面试题</a><br><a href="https://cloud.tencent.com/developer/article/1450773" target="_blank" rel="noopener">脏读、不可重复读、幻读和MVCC</a><br><a href="https://blog.csdn.net/justloveyou_/article/details/78308460" target="_blank" rel="noopener">数据库</a><br><a href="https://blog.csdn.net/kennyrose/article/details/7532032" target="_blank" rel="noopener">数据库索引</a><br><a href="https://juejin.im/post/5b6d62ddf265da0f491bd200" target="_blank" rel="noopener">NoSQL 还是 SQL</a><br><a href="https://blog.csdn.net/oChangWen/article/details/53423301" target="_blank" rel="noopener">关系型数据库</a><br><a href="https://juejin.im/post/5b3dd6efe51d451991548579" target="_blank" rel="noopener">数据库增删查改</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试中最基础的计网、操作系统以及数据库。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang基础</title>
    <link href="http://yoursite.com/2020/01/10/Golang%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/01/10/Golang基础/</id>
    <published>2020-01-10T10:32:26.000Z</published>
    <updated>2020-01-23T07:26:17.999Z</updated>
    
    <content type="html"><![CDATA[<p>这是Go语言从零开始学习的记录-基础部分。</p><a id="more"></a><blockquote><p>参考文档：<a href="http://www.topgoer.com/" target="_blank" rel="noopener">go</a></p></blockquote><h1 id="Go基础"><a href="#Go基础" class="headerlink" title="Go基础"></a>Go基础</h1><h2 id="命令行运行程序"><a href="#命令行运行程序" class="headerlink" title="命令行运行程序"></a>命令行运行程序</h2><p><code>go build 文件名.go</code> 此命令只会编译代码，生成二进制文件，不能运行可执行程序<br><code>go run 文件名.go 参数1 参数2...</code> 只会运行，不会生成可执行程序</p><h2 id="字符串格式化时常用动词及功能"><a href="#字符串格式化时常用动词及功能" class="headerlink" title="字符串格式化时常用动词及功能"></a>字符串格式化时常用动词及功能</h2><div class="table-container"><table><thead><tr><th>动词</th><th>功能</th></tr></thead><tbody><tr><td>%v</td><td>按值的本来值输出</td></tr><tr><td>%+v</td><td>在 %v 基础上，对结构体字段名和值进行展开</td></tr><tr><td>%#v</td><td>输出 Go 语言语法格式的值</td></tr><tr><td>%T</td><td>输出 Go 语言语法格式的类型和值</td></tr><tr><td>%%</td><td>输出 % 本体</td></tr><tr><td>%b</td><td>整型以二进制方式显示</td></tr><tr><td>%o</td><td>整型以八进制方式显示</td></tr><tr><td>%d</td><td>整型以十进制方式显示</td></tr><tr><td>%x</td><td>整型以十六进制方式显示</td></tr><tr><td>%X</td><td>整型以十六进制、字母大写方式显示</td></tr><tr><td>%U</td><td>Unicode 字符</td></tr><tr><td>%f</td><td>浮点数</td></tr><tr><td>%p</td><td>指针，十六进制方式显示</td></tr></tbody></table></div><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>在 Go 编程语言中，数据类型用于声明函数和变量，告诉编译器这个数应该以多大的内存存储</p><h2 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h2><p>布尔型的值只可以是常量 true 或者 false。一个简单的例子：<code>var b bool = true</code>。</p><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>整型<code>int</code>和浮点型<code>float32</code>、<code>float64</code>，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。</p><h2 id="其他数字类型"><a href="#其他数字类型" class="headerlink" title="其他数字类型"></a>其他数字类型</h2><p><code>byte</code> 类似uint8<br><code>rune</code> 类似int32<br><code>uint</code> 32或64位<br><code>int</code> 与uint一样大小<br><code>uintptr</code> 无符号整型，用于存放一个指针</p><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。<br>字符是单引号，往往是单个字符，转义字符除外；字符串是双引号，一个或多个字符组成，字符串都隐藏了一个结束字符<code>\0</code>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 <span class="keyword">string</span> <span class="comment">//声明</span></span><br><span class="line">str1 = <span class="string">"hello go"</span> <span class="comment">//赋值</span></span><br><span class="line">fmt.Println(<span class="string">"str1 = "</span>, str1)</span><br><span class="line"><span class="comment">//内建len() 函数可以接受不同类型参数并返回该类型的长度,</span></span><br><span class="line"><span class="comment">//传入的是字符串则返回字符串的长度，如果传入的是数组，则返回数组中包含的元素个数。</span></span><br><span class="line">fmt.Println(<span class="string">"len(str1) = "</span>, <span class="built_in">len</span>(str1))</span><br><span class="line">fmt.Printf(<span class="string">"str1[0] = %c, str1[7] = %c"</span>,str1[<span class="number">0</span>],str1[<span class="number">7</span>]) <span class="comment">//只想操作字符串中的某个字符</span></span><br></pre></td></tr></table></figure></p><h2 id="派生类型"><a href="#派生类型" class="headerlink" title="派生类型"></a>派生类型</h2><p>指针、数组、结构化类型、Channel类型、函数类型、切片类型、接口类型（interface）、Map类型</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。<br>声明的变量必须要使用，不然会报错；指定变量类型，如果没有初始化，则变量默认为零值；同一个<code>（）</code>里,声明的变量是唯一的。<br>声明变量<code>var identifier type</code>,也可以一次声明多个变量<code>var identifier1,identifier2 type</code>。</p><h2 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var b int &#x3D; 10 &#x2F;&#x2F;初始化，声明变量时，同时赋值</span><br><span class="line">b &#x3D; 20 &#x2F;&#x2F;赋值，先声明，后赋值</span><br></pre></td></tr></table></figure><h2 id="自动推导类型"><a href="#自动推导类型" class="headerlink" title="自动推导类型"></a>自动推导类型</h2><p> 注意 <code>:=</code> 左侧如果没有声明新的变量，就产生编译错误。必须初始化，通过初始化的值确定类型<code>identifier := value</code>，例如<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">"c type is %T\n"</span>,c) <span class="comment">//%T打印变量所属类型</span></span><br></pre></td></tr></table></figure></p><h2 id="多变量声明"><a href="#多变量声明" class="headerlink" title="多变量声明"></a>多变量声明</h2><p>1.<code>vname1, vname2,vname3 := v1, v2, v3</code>，例如<code>a, b := 1, 2</code>, 出现在<code>:=</code>左侧的变量不应该是已经被声明过的，否则会导致编译错误<br>2.类型相同多个变量, 非全局变量<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span></span><br><span class="line">vname1, vname2, vname3 = v1, v2, v3</span><br></pre></td></tr></table></figure></p><p>3.<code>var vname1, vname2, vname3 = v1, v2, v3</code>和 python 很像,不需要显示声明类型，自动推断<br>4.这种因式分解关键字的写法一般用于声明全局变量<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    vname1 v_type1</span><br><span class="line">    vname2 v_type2</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3 id="交换两个变量的值"><a href="#交换两个变量的值" class="headerlink" title="交换两个变量的值"></a>交换两个变量的值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">a, b = b, a</span><br><span class="line">fmt.Printf(<span class="string">"i = %d, j = %d\n"</span>, i, j)</span><br></pre></td></tr></table></figure><h3 id="匿名变量，丢弃数据不处理"><a href="#匿名变量，丢弃数据不处理" class="headerlink" title="匿名变量，丢弃数据不处理"></a>匿名变量，丢弃数据不处理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tmp , _ = i, j</span><br><span class="line">fmt.Println(<span class="string">"tmp = "</span>, tmp)</span><br></pre></td></tr></table></figure><p>匿名变量要配合函数返回值使用才有优势<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">//go语言可以有多个返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span>, <span class="string">"hello"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c, d <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> e <span class="keyword">string</span></span><br><span class="line">c, d, e = test()  <span class="comment">//return 1, 2, hello</span></span><br><span class="line">fmt.Printf(<span class="string">"c = %d, d= %d, e=%s\n"</span>, c, d, e)</span><br><span class="line"></span><br><span class="line">_, d, _ = test()   <span class="comment">//return 2</span></span><br><span class="line">fmt.Printf(<span class="string">"d= %d\n"</span>,  d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="变量的输入"><a href="#变量的输入" class="headerlink" title="变量的输入"></a>变量的输入</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> <span class="comment">//声明变量</span></span><br><span class="line">fmt.Printf(<span class="string">"请输入变量a： "</span>)</span><br><span class="line"><span class="comment">//阻塞等待变量的输入</span></span><br><span class="line"><span class="comment">//fmt.Scanf("%d", &amp;a)</span></span><br><span class="line">fmt.Scan(&amp;a) <span class="comment">//简便写法</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>并不是所有类型都能互相转换，不能转换的类型叫做不兼容类型，例如<code>bool</code>类型<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> flag <span class="keyword">bool</span></span><br><span class="line">flag = <span class="literal">true</span> <span class="comment">//0就是假，非0就是真</span></span><br><span class="line">fmt.Printf(<span class="string">"flag = %t\n"</span>,flag)</span><br><span class="line">fmt.Printf(<span class="string">"flag = %d\n"</span>,flag)</span><br><span class="line"><span class="comment">//bool类型不能转化为int</span></span><br><span class="line"><span class="comment">//fmt.Printf("flag = %t\n",int(flag))</span></span><br><span class="line"><span class="comment">//flag = 1  报错，因为flag是bool类型，1是整型</span></span><br><span class="line"><span class="comment">//flag =bool(1) 报错，两者是不兼容类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">byte</span> <span class="comment">//字符类型本质是整型</span></span><br><span class="line">ch = <span class="string">'a'</span></span><br><span class="line"><span class="keyword">var</span> t <span class="keyword">int</span></span><br><span class="line">t = <span class="keyword">int</span>(ch) <span class="comment">//类型转换，把ch的值取出来后，转换成int再赋值给t</span></span><br><span class="line">fmt.Println(<span class="string">"t = "</span>,t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="literal">true</span></span><br><span class="line">flag = %!d(<span class="keyword">bool</span>=<span class="literal">true</span>)</span><br><span class="line">t =  <span class="number">97</span></span><br></pre></td></tr></table></figure></p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>常用于结构体<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//给int64起一个别名叫bigint</span></span><br><span class="line"><span class="keyword">type</span> bigint <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">var</span> a bigint  <span class="comment">//等价于int64 a</span></span><br><span class="line">fmt.Printf(<span class="string">"a type is %T\n"</span>,a)</span><br><span class="line"><span class="comment">//可以同时起多个别名</span></span><br><span class="line"><span class="keyword">type</span>(</span><br><span class="line">long <span class="keyword">int32</span></span><br><span class="line">char <span class="keyword">byte</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> b long = <span class="number">11</span></span><br><span class="line"><span class="keyword">var</span> ch char = <span class="string">'a'</span></span><br><span class="line">fmt.Printf(<span class="string">"b = %d,ch = %c\n"</span>, b, ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a <span class="keyword">type</span> is main.bigint</span><br><span class="line">b = <span class="number">11</span>,ch = a</span><br></pre></td></tr></table></figure></p><h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><p>所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值:</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/10/Golang%E5%9F%BA%E7%A1%80/go_1.1.png"></center><p>当使用等号<code>=</code>将一个变量的值赋值给另一个变量时，如<code>j = i</code>，实际上是在内存中将<code>i</code>的值进行了拷贝：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/10/Golang%E5%9F%BA%E7%A1%80/go_1.2.png"></center><p>可以通过<code>&amp;i</code>来获取变量 i 的内存地址，例如：0xf840000040（每次的地址都可能不一样）。值类型的变量的值存储在栈中。<br>内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同。更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。</p><p><strong>一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。</strong></p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/10/Golang%E5%9F%BA%E7%A1%80/go_1.3.png"></center><p><strong>这个内存地址为称之为指针</strong>，这个指针实际上也被存在另外的某一个字中。<br>同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。<br>当使用赋值语句<code>r2 = r1</code>时，只有引用（地址）被复制。<br>如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响。</p><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>常量是一个简单值的标识符，在程序运行时，不会被修改的量。<br>常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。<br>常量定义格式<code>const identifier [type] = value</code><br>可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。</p><ol><li>显式类型定义：<code>const b string = &quot;abc&quot;</code></li><li>隐式类型定义：<code>const b = &quot;abc&quot;</code></li></ol><p>多个相同类型的变量可以简写<code>const c_name1, c_name2 = value1, value2</code></p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>常量还可以用枚举<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Unknown = <span class="number">0</span></span><br><span class="line">    Female = <span class="number">1</span></span><br><span class="line">    Male = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>数字 0、1 和 2 分别代表未知性别、女性和男性。<br>常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"unsafe"</span></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">a = <span class="string">"abc"</span></span><br><span class="line">b = <span class="built_in">len</span>(a)</span><br><span class="line">c = unsafe.Sizeof(a)</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(a, b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上实例运行结果为<code>abc 3 16</code></p><h2 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h2><p>iota，特殊常量，可以认为是一个可以被编译器修改的常量。<br>iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。<br>iota 可以被用作枚举值：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">a = <span class="literal">iota</span></span><br><span class="line">b = <span class="literal">iota</span></span><br><span class="line">c = <span class="literal">iota</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">a = <span class="literal">iota</span></span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3 id="iota实例1"><a href="#iota实例1" class="headerlink" title="iota实例1"></a>iota实例1</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">a = <span class="literal">iota</span>  <span class="comment">//0</span></span><br><span class="line">b         <span class="comment">//1</span></span><br><span class="line">c  <span class="comment">//2</span></span><br><span class="line">d = <span class="string">"ha"</span>  <span class="comment">//独立值，iota += 1</span></span><br><span class="line">e         <span class="comment">//"ha",iota += 1</span></span><br><span class="line">f = <span class="number">100</span>   <span class="comment">//100,iota += 1</span></span><br><span class="line">g         <span class="comment">//100,iota += 1</span></span><br><span class="line">h = <span class="literal">iota</span>  <span class="comment">//7,恢复计数</span></span><br><span class="line">i         <span class="comment">//8</span></span><br><span class="line">)</span><br><span class="line">fmt.Println(a, b, c, d, e, f, g, h, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为<code>0 1 2 ha ha 100 100 7 8</code></p><h3 id="iota实例2"><a href="#iota实例2" class="headerlink" title="iota实例2"></a>iota实例2</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    i=<span class="number">1</span>&lt;&lt;<span class="literal">iota</span></span><br><span class="line">    j=<span class="number">3</span>&lt;&lt;<span class="literal">iota</span></span><br><span class="line">    k</span><br><span class="line">    l</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"i="</span>,i)</span><br><span class="line">    fmt.Println(<span class="string">"j="</span>,j)</span><br><span class="line">    fmt.Println(<span class="string">"k="</span>,k)</span><br><span class="line">    fmt.Println(<span class="string">"l="</span>,l)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i= <span class="number">1</span></span><br><span class="line">j= <span class="number">6</span></span><br><span class="line">k= <span class="number">12</span></span><br><span class="line">l= <span class="number">24</span></span><br></pre></td></tr></table></figure></p><p>iota 表示从 0 开始自动加 1，所以 <code>i=1&lt;&lt;0</code>, <code>j=3&lt;&lt;1</code>（&lt;&lt; 表示左移的意思），即：<code>i=1</code>,<code>j=6</code>，这没问题，关键在 k 和 l，从输出结果看<code>k=3&lt;&lt;2</code>，<code>l=3&lt;&lt;3</code>。<br><code>i=1</code>：左移 0 位,不变仍为 1;<br><code>j=3</code>：左移 1 位,变为二进制 <code>110</code>, 即 6;<br><code>k=3</code>：左移 2 位,变为二进制 <code>1100</code>, 即 12;<br><code>l=3</code>：左移 3 位,变为二进制 <code>11000</code>,即 24。</p><h1 id="Go语言运算符"><a href="#Go语言运算符" class="headerlink" title="Go语言运算符"></a>Go语言运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><code>+</code>  (相加）， <code>-</code>  (相减)，<code>*</code> （相乘），<code>/</code> （相除）<br><code>%</code> （求余）， <code>++</code>（自增），<code>--</code>（自减）</p><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">==</td><td style="text-align:left">检查两个值是否相等，如果相等返回 True 否则返回 False。</td></tr><tr><td style="text-align:center">!=</td><td style="text-align:left">检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:left">检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:left">检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:left">检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:left">检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td></tr></tbody></table></div><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table>    <tr>        <td>运算符</td>        <td>描述</td>    </tr>    <tr>        <td>&amp;&amp;</td>        <td>逻辑 AND 运算符。 如果两边的操作数都是 True，则条件 True，否则为 False。</td>    </tr>    <tr>        <td>||</td>        <td>逻辑 OR 运算符。 如果两边的操作数有一个 True，则条件 True，否则为 False。</td>    </tr>    <tr>        <td>!</td>        <td>逻辑 NOT 运算符。 如果条件为 True，则逻辑 NOT 条件 False，否则为 True。</td>    </tr></table><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符对整数在内存中的二进制位进行操作，共有与或非，左移和右移五种。<br>Go 语言支持的位运算符如下表所示。假定 A 为60(<code>0011 1100</code>)，B 为13（<code>0000 1101</code>）：</p><table>    <tr>        <td>运算符</td>        <td>描述</td>        <td>实例</td>    </tr>    <tr>        <td>&amp;</td>        <td>双目运算符，进行两数的二进制相与</td>        <td>(A &amp; B) 结果为 12, 二进制为 0000 1100</td>    </tr>    <tr>        <td>|</td>        <td>双目运算符，进行两数的二进制相或</td>        <td>(A | B) 结果为 61, 二进制为 0011 1101</td>    </tr>    <tr>        <td>^</td>        <td>双目运算符，进行两数的二进制异或</td>        <td>A ^ B) 结果为 49, 二进制为 0011 0001</td>    </tr>    <tr>        <td>&lt;&lt;</td>        <td>双目运算符，左移n位</td>        <td>A &lt;&lt; 2 结果为 240 ，二进制为 1111 0000</td>    </tr>    <tr>        <td>&gt;&gt;</td>        <td>双目运算符，右移n位</td>        <td>A &gt;&gt; 2 结果为 15 ，二进制为 0000 1111</td>    </tr></table><blockquote><p>左移n位就是乘以2的n次方。 其功能把”&lt;&lt;”左边的运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。<br>右移n位就是除以2的n次方。 其功能是把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数。</p></blockquote><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table>    <tr>        <td>运算符</td>        <td>描述</td>    </tr>    <tr>        <td>=</td>        <td>简单的赋值运算符，将一个表达式的值赋给一个左值</td>    </tr>    <tr>        <td>+=</td>        <td>相加后再赋值</td>    </tr>    <tr>        <td>-=</td>        <td>相减后再赋值</td>    </tr>    <tr>        <td>*=</td>        <td>相乘后再赋值</td>    </tr>    <tr>        <td>/=</td>        <td>相除后再赋值</td>    </tr>    <tr>        <td>%=</td>        <td>求余后再赋值</td>    </tr>    <tr>        <td>&lt;&lt;=</td>        <td>左移后赋值</td>    </tr>    <tr>        <td>&gt;&gt;=</td>        <td>右移后赋值</td>    </tr>    <tr>        <td>&amp;=</td>        <td>按位与后赋值</td>    </tr>    <tr>        <td>^=</td>        <td>按位异或后赋值</td>    </tr>    <tr>        <td>|=</td>        <td>按位或后赋值</td>    </tr></table><h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><div class="table-container"><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;</td><td>返回变量存储地址</td><td>&a; 将给出变量的实际地址。</td></tr><tr><td>*</td><td>指针变量</td><td>*a; 是一个指针变量</td></tr></tbody></table></div><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低：</p><table>    <tr>        <td>优先级</td>        <td>运算符</td>    </tr>    <tr>        <td>5</td>        <td>\* / % &lt;&lt; &gt;&gt; &amp; &amp;^</td>    </tr>    <tr>        <td>4</td>        <td>+ - | ^</td>    </tr>    <tr>        <td>3</td>        <td>== != &lt; &lt;= &gt; &gt;=</td>    </tr>    <tr>        <td>2</td>        <td>&amp;&amp;</td>    </tr>    <tr>        <td>1</td>        <td>||</td>    </tr></table><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="条件判断语句"><a href="#条件判断语句" class="headerlink" title="条件判断语句"></a>条件判断语句</h2><p><strong>Go 没有三目运算符，所以不支持 ?: 形式的条件判断。</strong><br>Go语言支持最基本的三种程序运行结构：顺序结构（程序按顺序执行，不发生跳转）、选择结构（依据是否满足条件，有选择的执行）、循环结构（依据条件是否满足，循环多次执行某一代码）</p><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>满足条件执行，否则不执行<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">if</span> s == <span class="string">"hello"</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//if支持一个初始化语句，初始化语句和判断条件以分号分隔</span></span><br><span class="line"><span class="keyword">if</span> a := <span class="number">10</span>; a == <span class="number">10</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"a == 10"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="if…else语句"><a href="#if…else语句" class="headerlink" title="if…else语句"></a>if…else语句</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a:= <span class="number">10</span>; a == <span class="number">10</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"a == 10"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> a &gt; <span class="number">10</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"a &gt; 10"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> a &lt; <span class="number">10</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"a &lt;==&gt; 10"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"不可能"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><h4 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// var num int</span></span><br><span class="line"><span class="comment">// fmt.Println("请输入：")</span></span><br><span class="line"><span class="comment">// fmt.Scan(&amp;num)</span></span><br><span class="line"><span class="comment">// switch num &#123;  //switch后面是变量本身</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//switch支持一个初始化语句，初始化语句和变量本身，以分号隔离</span></span><br><span class="line"><span class="keyword">switch</span> num := <span class="number">1</span>; num&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">fmt.Println(<span class="number">1</span>)</span><br><span class="line"><span class="comment">//break  //Go依然保留了break，但可以不写，默认包含</span></span><br><span class="line"><span class="keyword">fallthrough</span> <span class="comment">//不跳出switch语句，后面的无条件执行</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>:</span><br><span class="line">fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"其他"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当输入<code>1</code>时，执行结果为<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure></p><h4 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">score := <span class="number">85</span></span><br><span class="line"><span class="keyword">switch</span> &#123;  <span class="comment">//可以没有条件</span></span><br><span class="line"><span class="keyword">case</span> score &gt; <span class="number">90</span>:</span><br><span class="line">fmt.Println(<span class="string">"优秀"</span>)</span><br><span class="line"><span class="keyword">case</span> score &gt; <span class="number">80</span>:</span><br><span class="line">fmt.Println(<span class="string">"良好"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"一般"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h3><p>select 是Go中的一个控制结构，类似于用于通信的switch语句。每个case必须是一个通信操作，要么是发送要么是接收。 select 随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。一个默认的子句应该总是可运行的。<br>select用于处理异步IO操作。select会监听case语句中channel的读写操作，当case中channel读写操作为非阻塞状态（即能读写）时，将会触发相应的动作。 select中的case语句必须是一个channel操作。</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">每个<span class="keyword">case</span>都必须是一个通信</span><br><span class="line">所有channel表达式都会被求值</span><br><span class="line">所有被发送的表达式都会被求值</span><br><span class="line">如果任意某个通信可以进行，它就执行；其他被忽略。</span><br><span class="line">如果有多个<span class="keyword">case</span>都可以运行，<span class="keyword">select</span>会随机公平地选出一个执行。其他不会执行。</span><br><span class="line">否则：</span><br><span class="line">如果有<span class="keyword">default</span>子句，则执行该语句。</span><br><span class="line">如果没有<span class="keyword">default</span>字句，<span class="keyword">select</span>将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。</span><br></pre></td></tr></table></figure><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//Channel是Go中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯</span></span><br><span class="line">   <span class="keyword">var</span> c1, c2, c3 <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">//select可以监听channel的数据流动</span></span><br><span class="line">   <span class="keyword">var</span> i1, i2 <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> i1 = &lt;-c1:  <span class="comment">//从Channel c1中接收数据，并将数据赋值给i1</span></span><br><span class="line">         fmt.Printf(<span class="string">"received "</span>, i1, <span class="string">" from c1\n"</span>)</span><br><span class="line">      <span class="keyword">case</span> c2 &lt;- i2:  <span class="comment">// 发送值i2到Channel c2中</span></span><br><span class="line">         fmt.Printf(<span class="string">"sent "</span>, i2, <span class="string">" to c2\n"</span>)</span><br><span class="line">      <span class="keyword">case</span> i3, ok := (&lt;-c3):  <span class="comment">// same as: i3, ok := &lt;-c3</span></span><br><span class="line">         <span class="keyword">if</span> ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"received "</span>, i3, <span class="string">" from c3\n"</span>)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"c3 is closed\n"</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Printf(<span class="string">"no communication\n"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no communication</span><br></pre></td></tr></table></figure></p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>基本语法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 初始化条件 ; 判断条件 ; 条件变化&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>只有一种<code>for</code>循环，没有<code>while</code>,<code>do...while</code><br>GO 语言支持以下几种循环控制语句：</p><div class="table-container"><table><thead><tr><th>控制语句</th><th>描述</th></tr></thead><tbody><tr><td>break</td><td>经常用于中断当前 for 循环或跳出 switch 语句</td></tr><tr><td>continue</td><td>跳过当前循环的剩余语句，然后继续进行下一轮循环</td></tr><tr><td>go</td><td>将控制转移到被标记的语句。</td></tr></tbody></table></div><h3 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h3><p><strong>break跳出循环，continue跳过本次循环</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">i++</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line"><span class="comment">//break能用在loop,switch以及select中</span></span><br><span class="line"><span class="comment">//break   //跳出循环，如果嵌套多个循环，跳出最近的那个内循环。即打印到4就退出</span></span><br><span class="line"><span class="comment">//continue只能用在loop</span></span><br><span class="line"><span class="keyword">continue</span>  <span class="comment">//跳过本次循环，下一次继续。即跳过打印5直接往下打印</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="goto的使用"><a href="#goto的使用" class="headerlink" title="goto的使用"></a>goto的使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="number">111</span>)</span><br><span class="line"><span class="comment">//goto无条件跳转，可以用在任何地方但是不能跨函数使用</span></span><br><span class="line"><span class="keyword">goto</span> End <span class="comment">//End是用户起的名字，叫标签</span></span><br><span class="line">fmt.Println(<span class="number">222</span>)</span><br><span class="line">End:</span><br><span class="line">fmt.Println(<span class="number">333</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">111</span></span><br><span class="line"><span class="number">333</span></span><br></pre></td></tr></table></figure></p><h3 id="range的使用"><a href="#range的使用" class="headerlink" title="range的使用"></a>range的使用</h3><p>打印输出字符串的每个元素<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">"abc"</span></span><br><span class="line"><span class="comment">//迭代打印每个元素，默认返回2个值:一个是元素位置，一个是元素本身</span></span><br><span class="line"><span class="keyword">for</span> i, data := <span class="keyword">range</span> str &#123;</span><br><span class="line">fmt.Printf(<span class="string">"str[%d]=%c "</span>, i, data)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> str &#123;   <span class="comment">//第2个返回值默认丢弃，返回元素的位置（下标）</span></span><br><span class="line"><span class="comment">//等价于 for i,_ :=range str&#123;</span></span><br><span class="line"><span class="comment">//等价于 for i := 0; i &lt;len(str); i++&#123;</span></span><br><span class="line">fmt.Printf(<span class="string">"str[%d]=%c "</span>, i, str[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str[<span class="number">0</span>]=a str[<span class="number">1</span>]=b str[<span class="number">2</span>]=c</span><br><span class="line">str[<span class="number">0</span>]=a str[<span class="number">1</span>]=b str[<span class="number">2</span>]=c</span><br></pre></td></tr></table></figure></p><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123; <span class="comment">//for后不写任何东西，循环永远为真，死循环</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果循环中条件语句永远不为 false 则会进行无限循环，我们可以通过 for 循环语句中只设置一个条件表达式来执行无限循环：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="literal">true</span>  &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"这是无限循环。\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>计算1到100的合<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span> ;i &lt;= <span class="number">100</span> ; i++ &#123;</span><br><span class="line">sum =sum + i</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数定义及调用"><a href="#函数定义及调用" class="headerlink" title="函数定义及调用"></a>函数定义及调用</h2><p>Go语言的函数定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">([parameter list])</span> [<span class="title">return_type</span>]</span>&#123;</span><br><span class="line">  <span class="comment">//func：函数由 func 开始声明</span></span><br><span class="line">  <span class="comment">//function_name，首字母小写为private，大写为public</span></span><br><span class="line">  <span class="comment">//return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</span></span><br><span class="line">  函数体</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用函数，向函数传递参数，并返回值。<br>调用函数传递的叫实参。定义函数时，函数名后()定义的参数叫形参。参数传递只能由实参传递给形参。</p><h3 id="有参有返回值"><a href="#有参有返回值" class="headerlink" title="有参有返回值"></a>有参有返回值</h3><p>调用函数返回最大值：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(num1, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span>(num1&gt;num2)&#123;</span><br><span class="line">result=num1</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">result=num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">200</span></span><br><span class="line"><span class="keyword">var</span> ret <span class="keyword">int</span></span><br><span class="line">        ret = max(a, b)</span><br><span class="line">fmt.Printf(<span class="string">"a，b的最大值是：%d\n"</span>,ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="无参有返回值"><a href="#无参有返回值" class="headerlink" title="无参有返回值"></a>无参有返回值</h3><p>只能有一个返回值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc01</span><span class="params">()</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123; <span class="comment">//给返回值命名</span></span><br><span class="line">result = <span class="number">123</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := myfunc01()</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="函数返回多个值"><a href="#函数返回多个值" class="headerlink" title="函数返回多个值"></a>函数返回多个值</h3><p>Go函数可以返回多个值，例如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a, b := swap(<span class="string">"hello"</span>, <span class="string">"world"</span>)</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="不定参数列表"><a href="#不定参数列表" class="headerlink" title="不定参数列表"></a>不定参数列表</h2><p>不定参数只能放在形参中的最后一个参数</p><h3 id="实例1-1"><a href="#实例1-1" class="headerlink" title="实例1"></a>实例1</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...type这样的类型叫不定参数类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc01</span> <span class="params">(a <span class="keyword">int</span> ,args ...<span class="keyword">int</span>)</span></span> &#123; <span class="comment">//传递的实参可以是0或多个</span></span><br><span class="line">fmt.Println(<span class="string">"len(args) = "</span>,<span class="built_in">len</span>(args))</span><br><span class="line"><span class="keyword">for</span> i, data := <span class="keyword">range</span> args &#123;</span><br><span class="line">fmt.Printf(<span class="string">"args[%d] = %d\n"</span>, i, data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//调用函数时一定要给固定参数传参，不定参数根据需求传参</span></span><br><span class="line">myFunc01(<span class="number">1</span>)</span><br><span class="line">myFunc01(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">myFunc01(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(args) =  <span class="number">0</span></span><br><span class="line"><span class="built_in">len</span>(args) =  <span class="number">1</span></span><br><span class="line">args[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line"><span class="built_in">len</span>(args) =  <span class="number">2</span></span><br><span class="line">args[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">args[<span class="number">1</span>] = <span class="number">3</span></span><br></pre></td></tr></table></figure></p><h3 id="实例2-1"><a href="#实例2-1" class="headerlink" title="实例2"></a>实例2</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc01</span><span class="params">(tmp ...<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> _, data := <span class="keyword">range</span> tmp &#123;</span><br><span class="line">fmt.Print(data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc02</span><span class="params">(tmp ...<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, data := <span class="keyword">range</span> tmp &#123;</span><br><span class="line">fmt.Print(data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(args ...<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//全部元素传给myfunc</span></span><br><span class="line">myfunc01(args...)</span><br><span class="line">fmt.Println()</span><br><span class="line"><span class="comment">//只想把后2个参数传递给另一个使用</span></span><br><span class="line">myfunc02(args[<span class="number">2</span>:]...)<span class="comment">//从args[2]开始（包括本身），把后面所有元素传递过去</span></span><br><span class="line">fmt.Println()</span><br><span class="line">myfunc02(args[:<span class="number">2</span>]...)   <span class="comment">//从args[0]到args[2](不包括args[2])</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1234</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure></p><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>函数如果使用参数，该变量可称为函数的形参。形参就像定义在函数体内的局部变量，形式参数会作为函数的局部变量来使用。<br>调用函数，可以通过两种方式来传递参数：</p><div class="table-container"><table><thead><tr><th>传值类型</th><th>描述</th></tr></thead><tbody><tr><td>值传递</td><td>值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</td></tr><tr><td>引用传递</td><td>引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</td></tr></tbody></table></div><h2 id="函数调用流程"><a href="#函数调用流程" class="headerlink" title="函数调用流程"></a>函数调用流程</h2><p>函数调用流程：先调用后返回，先进后出</p><h3 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc01</span><span class="params">(a <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">myfunc02(a - <span class="number">1</span>)</span><br><span class="line">fmt.Println(<span class="string">"a = "</span>,a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc02</span><span class="params">(b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">myfunc03(b <span class="number">-1</span>)</span><br><span class="line">fmt.Println(<span class="string">"b = "</span>,b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc03</span><span class="params">(c <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"c = "</span>,c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">myfunc01(<span class="number">3</span>)</span><br><span class="line">fmt.Println(<span class="string">"main"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c =  <span class="number">1</span></span><br><span class="line">b =  <span class="number">2</span></span><br><span class="line">a =  <span class="number">3</span></span><br><span class="line">main</span><br></pre></td></tr></table></figure></p><h3 id="递归调用"><a href="#递归调用" class="headerlink" title="递归调用"></a>递归调用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">i ++</span><br><span class="line">fmt.Printf(<span class="string">"第%d次 "</span>,i)</span><br><span class="line">fmt.Println(<span class="string">"a = "</span>, a)</span><br><span class="line"><span class="keyword">if</span> a == <span class="number">1</span>&#123;</span><br><span class="line">i ++</span><br><span class="line">fmt.Printf(<span class="string">"第%d次 "</span>,i)</span><br><span class="line">fmt.Println(<span class="string">"a = "</span>, a)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">test(a <span class="number">-1</span>)</span><br><span class="line">i ++</span><br><span class="line">fmt.Printf(<span class="string">"第%d次 "</span>,i)</span><br><span class="line">fmt.Println(<span class="string">"a = "</span>,a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">test(<span class="number">3</span>)</span><br><span class="line">fmt.Println(<span class="string">"main"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第<span class="number">1</span>次 a =  <span class="number">3</span></span><br><span class="line">第<span class="number">2</span>次 a =  <span class="number">2</span></span><br><span class="line">第<span class="number">3</span>次 a =  <span class="number">1</span></span><br><span class="line">第<span class="number">4</span>次 a =  <span class="number">1</span></span><br><span class="line">第<span class="number">5</span>次 a =  <span class="number">2</span></span><br><span class="line">第<span class="number">6</span>次 a =  <span class="number">3</span></span><br><span class="line">main</span><br></pre></td></tr></table></figure></p><h3 id="实例1-递归实现累加"><a href="#实例1-递归实现累加" class="headerlink" title="实例1 递归实现累加"></a>实例1 递归实现累加</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i== <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i + test(i - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sum := test(<span class="number">100</span>)</span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>函数也是一种数据类型，通过type给一个函数起名。</p><h3 id="实例1-2"><a href="#实例1-2" class="headerlink" title="实例1"></a>实例1</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span>(a &lt; b)&#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//FuncType是一个函数类型，没有&#123;&#125;</span></span><br><span class="line"><span class="keyword">type</span> FuncType <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> fTest FuncType <span class="comment">//声明一个函数类型的变量test</span></span><br><span class="line">fTest = add     <span class="comment">//是变量就可以赋值</span></span><br><span class="line">result = fTest(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">//等价于add(10, 20)</span></span><br><span class="line">fmt.Println(result)</span><br><span class="line">fTest = min</span><br><span class="line">result = fTest(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">//等价于min(10, 20)</span></span><br><span class="line">fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行就结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure></p><h3 id="实例2-回调函数"><a href="#实例2-回调函数" class="headerlink" title="实例2 回调函数"></a>实例2 回调函数</h3><p>回调函数，函数有一个参数是函数类型，这个函数就是回调函数<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">//实现函数，加法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现减法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//FuncType是一个函数类型，没有&#123;&#125;</span></span><br><span class="line"><span class="keyword">type</span> FuncType <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">//多态，多种形态，调用同一个接口，可以实现不同的表现</span></span><br><span class="line"><span class="comment">//先有想法，后续进行实现</span></span><br><span class="line"><span class="comment">//计算器，可以进行多种运算,加减乘除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Calc</span><span class="params">(a, b <span class="keyword">int</span>, fTest FuncType)</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Calc"</span>)</span><br><span class="line">result = fTest(a, b)  <span class="comment">//函数一开始并没有实现，可以拓展</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := Calc(<span class="number">1</span>, <span class="number">1</span>,add)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">b := Calc(<span class="number">2</span>, <span class="number">1</span>,min)</span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Calc</span><br><span class="line"><span class="number">2</span></span><br><span class="line">Calc</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">10</span></span><br><span class="line"><span class="comment">//匿名函数，没有函数名字，函数定义，还没有调用</span></span><br><span class="line">f1 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line">f1() <span class="comment">//调用函数</span></span><br><span class="line"><span class="comment">//定义匿名函数，同时调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;()   <span class="comment">//后面的()代表调用此匿名函数</span></span><br><span class="line"><span class="comment">//带参数的匿名函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;(<span class="number">10</span>)</span><br><span class="line"><span class="comment">//有参有返回值的匿名函数</span></span><br><span class="line">x, y := <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="params">(max, min <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt; j &#123;</span><br><span class="line">max = i</span><br><span class="line">min = j</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">max = j</span><br><span class="line">min = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="comment">//有返回值一定要有return</span></span><br><span class="line">&#125;(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">fmt.Println(x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="延迟调用defer"><a href="#延迟调用defer" class="headerlink" title="延迟调用defer"></a>延迟调用defer</h2><p>defer只能放在函数或方法的内部，延迟调用，main函数结束前调用，多个defer先进后出。无论中途发生什么错误，defer语句都能执行到。</p><h3 id="例1-1"><a href="#例1-1" class="headerlink" title="例1"></a>例1</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"111"</span>)</span><br><span class="line">fmt.Println(<span class="string">"222"</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"333"</span>)</span><br><span class="line">fmt.Println(<span class="string">"444"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">222</span><br><span class="line">444</span><br><span class="line">333</span><br><span class="line">111</span><br></pre></td></tr></table></figure></p><h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">restlt := <span class="number">100</span>/a</span><br><span class="line">fmt.Println(<span class="string">"result = "</span>,restlt)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"111"</span>)</span><br><span class="line">fmt.Println(<span class="string">"222"</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"333"</span>)</span><br><span class="line">test(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"444"</span>)</span><br><span class="line">fmt.Println(<span class="string">"555"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>程序先打印<code>222</code>,执行到错误时程序崩溃返回，然后打印出<code>333</code>和<code>111</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">222</span><br><span class="line">333</span><br><span class="line">111</span><br><span class="line">panic: runtime error: integer divide by zero</span><br></pre></td></tr></table></figure></p><h3 id="defer和匿名函数结合使用"><a href="#defer和匿名函数结合使用" class="headerlink" title="defer和匿名函数结合使用"></a>defer和匿名函数结合使用</h3><h4 id="例1-2"><a href="#例1-2" class="headerlink" title="例1"></a>例1</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">10</span></span><br><span class="line">b := <span class="number">20</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"1:a = %d, b = %d\n"</span>, a, b)</span><br><span class="line">&#125;(a, b) <span class="comment">//把参数已经传了过去，只是没有调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"2:a = %d, b = %d\n"</span>, a, b)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"3:a = %d, b = %d\n"</span>, a, b)</span><br><span class="line">&#125;()</span><br><span class="line">a = <span class="number">111</span></span><br><span class="line">b = <span class="number">222</span></span><br><span class="line">fmt.Printf(<span class="string">"4：a = %d, b = %d\n"</span>, a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>:a = <span class="number">10</span>, b = <span class="number">20</span></span><br><span class="line"><span class="number">4</span>：a = <span class="number">111</span>, b = <span class="number">222</span></span><br><span class="line"><span class="number">3</span>:a = <span class="number">111</span>, b = <span class="number">222</span></span><br><span class="line"><span class="number">1</span>:a = <span class="number">10</span>, b = <span class="number">20</span></span><br></pre></td></tr></table></figure></p><h4 id="例2-1"><a href="#例2-1" class="headerlink" title="例2"></a>例2</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="params">(ret <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ret++</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(f())  <span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量 ret 的值为 2，因为 <code>ret++</code> 是在执行 <code>return 1</code> 语句后发生的。</p><h2 id="获取命令行参数"><a href="#获取命令行参数" class="headerlink" title="获取命令行参数"></a>获取命令行参数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//接收用户传递的参数，都是以字符串的形式传递</span></span><br><span class="line">list := os.Args</span><br><span class="line">n := <span class="built_in">len</span>(list)</span><br><span class="line">fmt.Println(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以看到程序本身也要占用一个参数</span></span><br><span class="line">D:\Go_code&gt;<span class="keyword">go</span> build hello.<span class="keyword">go</span> <span class="comment">//生成可执行程序</span></span><br><span class="line">D:\Go_code&gt;hello.exe</span><br><span class="line"><span class="number">1</span></span><br><span class="line">D:\Go_code&gt;hello.exe <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p><h1 id="Go工程管理"><a href="#Go工程管理" class="headerlink" title="Go工程管理"></a>Go工程管理</h1><p>在实际的开发工作中，直接调用编译器进行编译和链接的场景是少而又少，因为在工程中不会简单到只有一个源代码文件，且源文件之间会有相互的依赖关系。如果这样一个文件一个文件逐步编译，那不亚于一场灾难。<br>Go命令行工具的革命性之处在于彻底消除了工程文件的概念，完全用目录结构和包名来推导工程结构和构建顺序。针对只有一个源文件的情况讨论工程管理看起来会比较多余，因为这可以直接用<code>go run</code>和<code>go build</code>搞定。</p><h2 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h2><p>Go代码必须放在工作区内。工作区就是一个对应于特定工程的目录，它包含3个子目录：src目录(必须的)、pkg目录和bin目录。</p><ul><li>src目录：用与以代码包的形式组织并保存Go源码文件。(比如：<code>.go</code> <code>.c</code> <code>.h</code> <code>.s</code>等)</li><li>pkg目录：用于存放经由<code>go install</code>命令构建安装后的代码包(包含Go库源码文件)的<code>.a</code>归档文件</li><li>bin目录：与pkg目录类似，在通过<code>go install</code>命令完成安装后，保存由Go命令源码文件生成的可执行文件</li></ul><blockquote><p>目录src用于包含所有的源代码，是Go命令行工具的一个强制的规则，而pkg和bin则无需手动创建，如果必要Go命令行工具在构建过程中会自动创建这些目录。</p></blockquote><p>需要特别注意的是，只有当环境变量GOPATH中只包含一个工作区的目录路径时，<code>go install</code>命令才会把命令源码安装到当前工作区的bin目录下。若环境变量GOPATH中包含多个工作区的目录路径，像这样执行<code>go install</code>命令就会失效，此时必须设置环境变量GOBIN。</p><h2 id="设置GOPATH有什么意义"><a href="#设置GOPATH有什么意义" class="headerlink" title="设置GOPATH有什么意义"></a>设置GOPATH有什么意义</h2><p>环境变量GOPATH的值可以是一个目录的路径，也可以包含多个目录的路径，每个目录都代表Go语言的一个工作区。这些工作区用于放置Go语言的源码文件(source file)，以及安装(install)后的归档文件(archive file)和可执行文件(executable file)。<br>实际开发中，工作目录往往有多个，这些工作目录的目录路径都需要添加至GOPATH。</p><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>所有Go语言的程序都会组织成若干组文件，每组文件都被称为一个包，以包作为管理单位。这样每个包的代码都可以作为很小的复用单位，被其他项目引用。<br>go语言的包的命名，遵循简洁、小写、和go文件所在目录同名的原则，这样就便于我们引用，书写以及快速定位查找。</p><h3 id="远程包导入"><a href="#远程包导入" class="headerlink" title="远程包导入"></a>远程包导入</h3><p>互联网的时代，现在大家使用类似于Github共享代码的越来越多，如果有的Go包共享在Github上，我们一样有办法使用他们，这就是远程导入包了，或者是网络导入。<br><code>import &quot;github.com/spf13/cobra&quot;</code><br>这种导入，前提必须是该包托管在一个分布式的版本控制系统上，比如Github、Bitbucket等，并且是Public的权限，可以让我们直接访问它们。<br>编译在导入它们的时候，会先在<code>GOPATH</code>下搜索这个包，如果没有找到，就会使用<code>go get</code>工具从版本控制系统（GitHub）获取，并且会把获取到的源代码存储在<code>GOPATH</code>目录下对应URL的目录里，以供编译使用。</p><h3 id="命名导入"><a href="#命名导入" class="headerlink" title="命名导入"></a>命名导入</h3><p>我们知道，在使用import关键字导入包之后，我们就可以在代码中通过包名使用该包下相应的函数、接口等。如果我们导入的包名正好有重复的怎么办呢？针对这种情况，Go语言可以让我们对导入的包重新命名，这就是命名导入。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">myfmt <span class="string">"mylib/fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println()</span><br><span class="line">myfmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="忽略包"><a href="#忽略包" class="headerlink" title="忽略包"></a>忽略包</h4><p>Go语言规定，导入的包必须要使用，否则会包编译错误，这是一个非常好的规则，因为这样可以避免我们引用很多无用的代码而导致的代码臃肿和程序的庞大，因为很多时候，我们都不知道哪些包是否使用，这在C和Java上会经常遇到，有时候我们不得不借助工具来查找我们没有使用的文件、类型、方法和变量等，把它们清理掉。</p><p>但是有时候，我们需要导入一个包，但是又不使用它，按照规则，这是不行的，为此Go语言给我们提供了一个空白标志符<code>_</code>,只需要我们使用<code>_</code>重命名我们导入的包就可以了。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">"mylib/fmt"</span> <span class="comment">//这种做法是为了调用包里的init函数</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3 id="包的init函数"><a href="#包的init函数" class="headerlink" title="包的init函数"></a>包的init函数</h3><p>每个包都可以有任意多个init函数，这些init函数都会在main函数之前执行。init函数通常用来做初始化变量、设置包或者其他需要在程序执行前的引导工作。比如上面我们讲的需要使用<code>_</code>空标志符来导入一个包的目的，就是想执行这个包里的init函数。</p><p>我们以数据库的驱动为例，Go语言为了统一关于数据库的访问，使用<code>databases/sql</code>抽象了一层数据库的操作，可以满足我们操作MYSQL、Postgre等数据库，这样不管我们使用这些数据库的哪个驱动，编码操作都是一样的，想换驱动的时候，就可以直接换掉，而不用修改具体的代码。<br>这些数据库驱动的实现，就是具体的，可以由任何人实现的，它的原理就是定义了init函数，在程序运行之前，把实现好的驱动注册到sql包里，这样我们就使用使用它操作数据库了。</p><blockquote><p>导入包会先执行包里的init函数</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mysql</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"database/sql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">sql.Register(<span class="string">"mysql"</span>, &amp;MySQLDriver&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们只是想执行这个mysql包的init方法，并不想使用这个包，所以我们在导入这个包的时候，需要使用<code>_</code>重命名包名，避免编译错误。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"database/sql"</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line"></span><br><span class="line">db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"user:password@/dbname"</span>)</span><br></pre></td></tr></table></figure></p><p>看非常简洁，剩下针对的数据库的操作，都是使用的<code>database/sql</code>标准接口，如果我们想换一个mysql的驱动的话，只需要换个导入就可以了，灵活方便，这也是面向接口编程的便利。</p><h3 id="包的调用"><a href="#包的调用" class="headerlink" title="包的调用"></a>包的调用</h3><h4 id="不同目录的包的调用"><a href="#不同目录的包的调用" class="headerlink" title="不同目录的包的调用"></a>不同目录的包的调用</h4><p>1.调用不同包里面的函数，格式：<code>包名.函数名()</code><br>2.调用别的包的函数，这个包函数名字如果首字母是小写则无法调用，只能调用首字母大写的(public)。</p><h4 id="实例1-3"><a href="#实例1-3" class="headerlink" title="实例1"></a>实例1</h4><p>调用别的目录下的包完成函数的加。<br>建立以下文件：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/10/Golang%E5%9F%BA%E7%A1%80/文件结构.png"></center><p>main.go代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"test"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">a := test.Add(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>test.go代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要配置project的GOPATH。例如project在<code>D:\Go_code</code>,则配置：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/10/Golang%E5%9F%BA%E7%A1%80/GOPATH.png"></center><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>指针声明格式如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> var_name *<span class="keyword">var</span>-<span class="keyword">type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ip *<span class="keyword">int</span>        <span class="comment">/* 指向整型*/</span></span><br><span class="line"><span class="keyword">var</span> fp *<span class="keyword">float32</span>    <span class="comment">/* 指向浮点型 */</span></span><br></pre></td></tr></table></figure></p><p>例1：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">a := <span class="number">10</span></span><br><span class="line">  <span class="comment">//*b := &amp;a   //这是错误的，自动推导不需要加*，b := &amp;a即可</span></span><br><span class="line"><span class="keyword">var</span> ip *<span class="keyword">int</span> = &amp;a</span><br><span class="line">fmt.Printf(<span class="string">"address of a is %v\n"</span>,&amp;a)</span><br><span class="line">fmt.Printf(<span class="string">"address of ip is %v\n"</span>,&amp;ip)</span><br><span class="line">fmt.Printf(<span class="string">"ip is %d\n"</span>,*ip)</span><br><span class="line">*ip = <span class="number">20</span></span><br><span class="line">fmt.Printf(<span class="string">"ip is %d\n"</span>,*ip)</span><br><span class="line">fmt.Printf(<span class="string">"type of ip is %T\n"</span>,ip) <span class="comment">//ip是一个int型指针</span></span><br><span class="line">fmt.Printf(<span class="string">"type of *ip is %d\n"</span>,*ip) <span class="comment">//*ip指向a，a的类型是int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">address of a is <span class="number">0xc0000120a8</span></span><br><span class="line">address of ip is <span class="number">0xc000006028</span></span><br><span class="line">ip is <span class="number">10</span></span><br><span class="line">ip is <span class="number">20</span></span><br><span class="line"><span class="keyword">type</span> of ip is *<span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> of *ip is <span class="keyword">int</span></span><br></pre></td></tr></table></figure></p><h2 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h2><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">new</span>(Type) *Type</span><br></pre></td></tr></table></figure><p>其中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>Type表示类型，<span class="built_in">new</span>函数只接受一个参数，这个参数是一个类型</span><br><span class="line"><span class="number">2.</span>*Type表示类型指针，<span class="built_in">new</span>函数返回一个指向该类型内存地址的指针。</span><br></pre></td></tr></table></figure></p><p>new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span>   <span class="comment">//go不初始化默认是nil，没有NULL类型</span></span><br><span class="line">fmt.Println(<span class="string">"p = "</span>,p)  <span class="comment">//p =  &lt;nil&gt;</span></span><br><span class="line"><span class="comment">//*p = 666  //err,因为p没有合法指向</span></span><br><span class="line"><span class="keyword">var</span> v <span class="keyword">int</span></span><br><span class="line">p = &amp;v</span><br><span class="line">*p = <span class="number">20</span></span><br><span class="line">fmt.Println(*p) <span class="comment">//20</span></span><br><span class="line">q := <span class="built_in">new</span>(<span class="keyword">int</span>)  <span class="comment">//动态分配空间，go语言不需要释放，有自动的垃圾回收</span></span><br><span class="line">*q = <span class="number">123</span></span><br><span class="line">fmt.Println(*q) <span class="comment">//123</span></span><br><span class="line"></span><br><span class="line">a := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">b := <span class="built_in">new</span>(<span class="keyword">bool</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, a) <span class="comment">// *int</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, b) <span class="comment">// *bool</span></span><br><span class="line">fmt.Println(*a)       <span class="comment">// 0</span></span><br><span class="line">fmt.Println(*b)       <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。<br>make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">    b = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    b[<span class="string">"测试"</span>] = <span class="number">100</span></span><br><span class="line">    fmt.Println(b) <span class="comment">//输出：map[测试:100]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="new和make区别"><a href="#new和make区别" class="headerlink" title="new和make区别"></a>new和make区别</h3><p>1.二者都是用来做内存分配的。<br>2.make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；<br>3.而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</p><h2 id="普通变量做函数参数"><a href="#普通变量做函数参数" class="headerlink" title="普通变量做函数参数"></a>普通变量做函数参数</h2><p>交换两个变量的值：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a, b *<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">*a , *b = *b, *a  <span class="comment">//用*a,*b来访问main中变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">a := <span class="number">10</span></span><br><span class="line">b := <span class="number">20</span></span><br><span class="line">swap(&amp;a, &amp;b)   <span class="comment">//取a，b变量的地址给函数</span></span><br><span class="line">fmt.Println(a,b) <span class="comment">//打印结果：20 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="数组指针做函数"><a href="#数组指针做函数" class="headerlink" title="数组指针做函数"></a>数组指针做函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(a *[5] <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">5</span>]<span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">modify(&amp;a)</span><br><span class="line">fmt.Println(a) <span class="comment">//输出：[2 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE] variable_type</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> balance [<span class="number">10</span>] <span class="keyword">float32</span> <span class="comment">//数组 balance 长度为 10,类型为 float32</span></span><br><span class="line"><span class="comment">//数组定义元素个数必须是常量</span></span><br><span class="line"><span class="comment">//n := 10</span></span><br><span class="line"><span class="comment">//var a[n] int  //这样是错误的声明</span></span><br></pre></td></tr></table></figure><h2 id="初始化数组-声明定义同时赋值，叫初始化"><a href="#初始化数组-声明定义同时赋值，叫初始化" class="headerlink" title="初始化数组(声明定义同时赋值，叫初始化)"></a>初始化数组(声明定义同时赋值，叫初始化)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全部初始化</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">5</span>]<span class="keyword">int</span> = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">a := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">//初始化数组中 &#123;&#125; 中的元素个数不能大于 [] 中的数字。</span></span><br><span class="line"><span class="comment">//如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小：</span></span><br><span class="line"><span class="keyword">var</span> a = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//部分初始化，没有初始化的变量，自动赋值为0</span></span><br><span class="line">c:= [<span class="number">5</span>] <span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(d)  <span class="comment">//打印结果：[1 2 3 0 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定某个元素初始化</span></span><br><span class="line">d := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>:<span class="number">10</span>, <span class="number">4</span>:<span class="number">20</span>&#125;</span><br><span class="line">fmt.Println(d) <span class="comment">//打印结果：[0 0 10 0 20]</span></span><br></pre></td></tr></table></figure><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>二维数组是最简单的多维数组，二维数组本质上是由一维数组组成的。<br>二维数组可认为是一个表格，x 为行，y 为列，下图演示了一个二维数组 a 为三行四列：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/10/Golang%E5%9F%BA%E7%A1%80/1.jpg"></center><p>二维数组中的元素可通过 <code>a[ i ][ j ]</code> 来访问。</p><h3 id="初始化二维数组"><a href="#初始化二维数组" class="headerlink" title="初始化二维数组"></a>初始化二维数组</h3><p>多维数组可通过大括号来初始值。以下实例为一个 3 行 4 列的二维数组：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">3</span>][<span class="number">4</span>]<span class="keyword">int</span>&#123;</span><br><span class="line"> &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; ,   <span class="comment">/*  第一行索引为 0 */</span></span><br><span class="line"> &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125; ,   <span class="comment">/*  第二行索引为 1 */</span></span><br><span class="line"> &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;,   <span class="comment">/* 第三行索引为 2 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意：以上代码中倒数第二行的 } 必须要有逗号，因为最后一行的 } 不能单独一行，也可以写成这样：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">3</span>][<span class="number">4</span>]<span class="keyword">int</span>&#123;</span><br><span class="line"> &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; ,   <span class="comment">/*  第一行索引为 0 */</span></span><br><span class="line"> &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125; ,   <span class="comment">/*  第二行索引为 1 */</span></span><br><span class="line"> &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;&#125;   <span class="comment">/* 第三行索引为 2 */</span></span><br></pre></td></tr></table></figure></p><h3 id="访问二维数组"><a href="#访问二维数组" class="headerlink" title="访问二维数组"></a>访问二维数组</h3><p>二维数组通过指定坐标来访问。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val := a[<span class="number">2</span>][<span class="number">3</span>]</span><br><span class="line">或</span><br><span class="line"><span class="keyword">var</span> value <span class="keyword">int</span> = a[<span class="number">2</span>][<span class="number">3</span>]  <span class="comment">//访问了二维数组 val 第三行的第四个元素。</span></span><br></pre></td></tr></table></figure></p><p>二维数组可以使用循环嵌套来输出元素：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> a[<span class="number">3</span>][<span class="number">4</span>] <span class="keyword">int</span></span><br><span class="line">k := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i&lt;<span class="number">3</span>;i++&#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>;j&lt;<span class="number">4</span>;j++&#123;</span><br><span class="line">k++</span><br><span class="line">a[i][j]=k</span><br><span class="line">fmt.Printf(<span class="string">"a[%d][%d]=%d "</span>,i,j,k)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"a = "</span>,a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span> a[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">2</span> a[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">3</span> a[<span class="number">0</span>][<span class="number">3</span>]=<span class="number">4</span></span><br><span class="line">a[<span class="number">1.</span>][<span class="number">0</span>]=<span class="number">5</span> a[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">6</span> a[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">7</span> a[<span class="number">1</span>][<span class="number">3</span>]=<span class="number">8</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">9</span> a[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">10</span> a[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">11</span> a[<span class="number">2</span>][<span class="number">3</span>]=<span class="number">12</span></span><br><span class="line">a =  [[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>] [<span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>] [<span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span>]]</span><br></pre></td></tr></table></figure></p><h2 id="数组比较和赋值"><a href="#数组比较和赋值" class="headerlink" title="数组比较和赋值"></a>数组比较和赋值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//比较的两个数组类型要一样，只支持 == 或 ！=，比较是不是每个元素都一样</span></span><br><span class="line">a := [<span class="number">5</span>] <span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">b := [<span class="number">5</span>] <span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">c := [<span class="number">5</span>] <span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">"a == b"</span>,a==b)  <span class="comment">//输出：a == b true</span></span><br><span class="line">fmt.Println(<span class="string">"a == c"</span>,a==c)  <span class="comment">//输出：a == c false</span></span><br><span class="line"><span class="comment">//同类型的数组可以赋值，只能较小长度的数组向大于等于的赋值</span></span><br><span class="line"><span class="keyword">var</span> d [<span class="number">5</span>] <span class="keyword">int</span></span><br><span class="line">d = c</span><br><span class="line">fmt.Println(d)   <span class="comment">//输出：[1 2 3 0 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><h3 id="例1-3"><a href="#例1-3" class="headerlink" title="例1"></a>例1</h3><p>求数组所有元素之和：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 求元素和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumArr</span><span class="params">(a [10]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> sum <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">sum += a[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 若想做一个真正的随机数，要种子</span></span><br><span class="line"><span class="comment">// seed()种子默认是1</span></span><br><span class="line"><span class="comment">//rand.Seed(1)</span></span><br><span class="line">rand.Seed(time.Now().Unix())</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(b); i++ &#123;</span><br><span class="line"><span class="comment">// 产生一个0到1000随机数</span></span><br><span class="line">b[i] = rand.Intn(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">sum := sumArr(b)</span><br><span class="line">fmt.Printf(<span class="string">"sum=%d\n"</span>, sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="例2-2"><a href="#例2-2" class="headerlink" title="例2"></a>例2</h3><p>找出数组中和为给定值的两个元素的下标，例如数组[1,3,5,8,7]，找出两个元素之和等于8的下标分别是（0，4）和（1，2）<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求元素和，是给定的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myTest</span><span class="params">(a [5]<span class="keyword">int</span>, target <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">other := target - a[i]</span><br><span class="line"><span class="comment">// 继续遍历</span></span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(a); j++ &#123;</span><br><span class="line"><span class="keyword">if</span> a[j] == other &#123;</span><br><span class="line">fmt.Printf(<span class="string">"(%d,%d)\n"</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">b := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>&#125;</span><br><span class="line">myTest(b, <span class="number">8</span>) <span class="comment">// 找出两个元素之和等于8的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运算结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><h1 id="切片-slice"><a href="#切片-slice" class="headerlink" title="切片(slice)"></a>切片(slice)</h1><p>slice 并不是数组或数组指针。它通过内部指针和相关属性引用数组片段，以实现变长方案。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 切片：切片是数组的一个引用，因此切片是引用类型。但自身是结构体，值拷贝传递。</span><br><span class="line"><span class="number">2.</span> 切片的长度可以改变，因此，切片是一个可变的数组。</span><br><span class="line"><span class="number">3.</span> 切片遍历方式和数组一样，可以用<span class="built_in">len</span>()求长度。表示可用元素数量，读写操作不能超过该限制。</span><br><span class="line"><span class="number">4.</span> <span class="built_in">cap</span>可以求出slice最大扩张容量，不能超出数组限制。<span class="number">0</span> &lt;= <span class="built_in">len</span>(slice) &lt;= <span class="built_in">len</span>(array)，其中array是slice引用的数组。</span><br><span class="line"><span class="number">5.</span> 切片的定义：<span class="keyword">var</span> 变量名 []类型，比如 <span class="keyword">var</span> str []<span class="keyword">string</span>  <span class="keyword">var</span> arr []<span class="keyword">int</span>。</span><br><span class="line"><span class="number">6.</span> 如果 slice == <span class="literal">nil</span>，那么 <span class="built_in">len</span>、<span class="built_in">cap</span> 结果都等于 <span class="number">0</span>。</span><br></pre></td></tr></table></figure></p><p>下面我们来通过一张图来更好的理解切片：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2020/01/10/Golang%E5%9F%BA%E7%A1%80/3.png"></center><h2 id="切片的创建和初始化"><a href="#切片的创建和初始化" class="headerlink" title="切片的创建和初始化"></a>切片的创建和初始化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//通过append给切片末尾追加一个成员</span></span><br><span class="line">s := []<span class="keyword">int</span>&#123;&#125;  <span class="comment">//这是一个切片</span></span><br><span class="line">fmt.Printf(<span class="string">"len = %d, cap = %d\n"</span>,<span class="built_in">len</span>(s),<span class="built_in">cap</span>(s))  <span class="comment">//因为没有元素，所以输出:len = 0, cap = 0</span></span><br><span class="line">s = <span class="built_in">append</span>(s,<span class="number">11</span>)</span><br><span class="line">fmt.Printf(<span class="string">"len = %d, cap = %d\n"</span>,<span class="built_in">len</span>(s),<span class="built_in">cap</span>(s))  <span class="comment">//输出：len = 1, cap = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建和初始化切片：</span></span><br><span class="line"><span class="comment">//1.从数组创建切片</span></span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;  <span class="comment">//数组</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>,a) <span class="comment">//输出：[]int</span></span><br><span class="line">s1 := a[:<span class="number">3</span>:<span class="number">5</span>]               <span class="comment">//切片</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>,s1) <span class="comment">//输出：[]int。所以可以看到切片和数组具有同样的类型</span></span><br><span class="line">fmt.Println(<span class="string">"s1 = "</span>, s1)   <span class="comment">//输出：s1 =  [1 2 3]</span></span><br><span class="line">fmt.Println(<span class="string">"len(s1) = "</span>, <span class="built_in">len</span>(s1))  <span class="comment">//len = 3 - 0,输出：len(s1) =  3</span></span><br><span class="line">fmt.Println(<span class="string">"cap(s1) = "</span>, <span class="built_in">cap</span>(s1))  <span class="comment">//cap = 5 - 0,输出：cap(s1) =  5</span></span><br><span class="line"><span class="comment">//2.自动推导类型，同时初始化</span></span><br><span class="line">s2 := []<span class="keyword">int</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(s2)</span><br><span class="line"><span class="comment">//3.通过make()函数，格式 make(切片类型，长度，容量)</span></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Printf(<span class="string">"len = %d, cap = %d\n"</span>,<span class="built_in">len</span>(s3),<span class="built_in">cap</span>(s3)) <span class="comment">//输出：len = 5, cap = 10</span></span><br><span class="line">s4 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, )  <span class="comment">//没有指定容量，则容量和长度一样</span></span><br><span class="line">fmt.Printf(<span class="string">"len = %d, cap = %d\n"</span>,<span class="built_in">len</span>(s4),<span class="built_in">cap</span>(s4)) <span class="comment">//输出：len = 5, cap = 5</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="切片和底层数组的关系"><a href="#切片和底层数组的关系" class="headerlink" title="切片和底层数组的关系"></a>切片和底层数组的关系</h2><p>数组是值传递，切片是引用传递。</p><h3 id="超出原-slice-cap-限制"><a href="#超出原-slice-cap-限制" class="headerlink" title="超出原 slice.cap 限制"></a>超出原 slice.cap 限制</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//超出原 slice.cap 限制，就会重新分配底层数组，即便原数组并未填满。</span></span><br><span class="line">data := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>: <span class="number">0</span>&#125;</span><br><span class="line">s := data[:<span class="number">2</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(&amp;s[<span class="number">0</span>], &amp;data[<span class="number">0</span>])</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">100</span>, <span class="number">200</span>) <span class="comment">// 一次 append 两个值，超出 s.cap 限制。</span></span><br><span class="line"></span><br><span class="line">fmt.Println(s)         <span class="comment">// 重新分配底层数组，与原数组无关。</span></span><br><span class="line">fmt.Println(data)</span><br><span class="line">fmt.Println(&amp;s[<span class="number">0</span>], &amp;data[<span class="number">0</span>]) <span class="comment">// 比对底层数组起始指针。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"><span class="number">0xc00001a0c0</span> <span class="number">0xc00001a0c0</span>  <span class="comment">//slice指向原底层数组</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">100</span> <span class="number">200</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"><span class="number">0xc00000c330</span> <span class="number">0xc00001a0c0</span>  <span class="comment">//可以发现底层数组发生了改变</span></span><br></pre></td></tr></table></figure></p><p>从输出结果可以看出，append 后的 s 重新分配了底层数组，并复制数据。如果只追加一个值，则不会超过 s.cap 限制，也就不会重新分配。 <strong>通常以2倍容量重新分配底层数组。</strong> 在大批量添加数据时，建议一次性分配足够大的空间，以减少内存分配和数据复制开销。</p><h3 id="slice中cap重新分配规律"><a href="#slice中cap重新分配规律" class="headerlink" title="slice中cap重新分配规律"></a>slice中cap重新分配规律</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">c := <span class="built_in">cap</span>(s)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">s = <span class="built_in">append</span>(s, i)  <span class="comment">//当容量不够时两倍扩容</span></span><br><span class="line"><span class="keyword">if</span> n := <span class="built_in">cap</span>(s); n &gt; c &#123;</span><br><span class="line">fmt.Printf(<span class="string">"cap: %d -&gt; %d\n"</span>, c, n)</span><br><span class="line">c = n</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cap</span>: <span class="number">1</span> -&gt; <span class="number">2</span>   <span class="comment">//可以看到cap以2为指数增长</span></span><br><span class="line"><span class="built_in">cap</span>: <span class="number">2</span> -&gt; <span class="number">4</span></span><br><span class="line"><span class="built_in">cap</span>: <span class="number">4</span> -&gt; <span class="number">8</span></span><br><span class="line"><span class="built_in">cap</span>: <span class="number">8</span> -&gt; <span class="number">16</span></span><br><span class="line"><span class="built_in">cap</span>: <span class="number">16</span> -&gt; <span class="number">32</span></span><br><span class="line"><span class="built_in">cap</span>: <span class="number">32</span> -&gt; <span class="number">64</span></span><br></pre></td></tr></table></figure></p><h2 id="切片拷贝"><a href="#切片拷贝" class="headerlink" title="切片拷贝"></a>切片拷贝</h2><p>copy ：函数 copy 在两个 slice 间复制数据，复制长度以 len 小的为准。两个 slice 可指向同一底层数组，允许元素区间重叠。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">"array data : "</span>, data)</span><br><span class="line">s1 := data[<span class="number">8</span>:]</span><br><span class="line">s2 := data[:<span class="number">5</span>]</span><br><span class="line">fmt.Printf(<span class="string">"slice s1 : %v\n"</span>, s1)</span><br><span class="line">fmt.Printf(<span class="string">"slice s2 : %v\n"</span>, s2)</span><br><span class="line"><span class="built_in">copy</span>(s2, s1)</span><br><span class="line">fmt.Printf(<span class="string">"copied slice s1 : %v\n"</span>, s1)</span><br><span class="line">fmt.Printf(<span class="string">"copied slice s2 : %v\n"</span>, s2)</span><br><span class="line">fmt.Println(<span class="string">"last array data : "</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array data :  [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">slice s1 : [<span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">slice s2 : [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">copied slice s1 : [<span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">copied slice s2 : [<span class="number">8</span> <span class="number">9</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">last array data :  [<span class="number">8</span> <span class="number">9</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br></pre></td></tr></table></figure></p><p>应及时将所需数据 copy 到较小的 slice，以便释放超大号底层数组内存。</p><h2 id="字符串和切片"><a href="#字符串和切片" class="headerlink" title="字符串和切片"></a>字符串和切片</h2><p>string底层就是一个byte的数组，因此，也可以进行切片操作。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">"hello world"</span></span><br><span class="line">s1 := str[:<span class="number">5</span>]</span><br><span class="line">fmt.Println(s1)  <span class="comment">//输出：hello</span></span><br><span class="line">s2 := str[<span class="number">6</span>:]</span><br><span class="line">fmt.Println(s2)  <span class="comment">//输出：world</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>string本身是不可变的，因此要改变string中字符。需要如下操作:</p><blockquote><p>Go语言的字符有以下两种：<br>一种是 uint8 类型，或者叫 byte 型，代表了 ASCII 码的一个字符。<br>另一种是 rune 类型，代表一个 UTF-8 字符，当需要处理中文、日文或者其他复合字符时，则需要用到 rune 类型。rune 类型等价于 int32 类型。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//英文字符串：</span></span><br><span class="line">str := <span class="string">"hello world"</span></span><br><span class="line">s := []<span class="keyword">byte</span>(str)</span><br><span class="line">s[<span class="number">6</span>] = <span class="string">'g'</span></span><br><span class="line">s[<span class="number">7</span>] = <span class="string">'o'</span></span><br><span class="line">s = s[:<span class="number">8</span>]</span><br><span class="line">s = <span class="built_in">append</span>(s,<span class="string">'!'</span>)</span><br><span class="line">str = <span class="keyword">string</span>(s)</span><br><span class="line">fmt.Println(str)  <span class="comment">//输出:hello go!</span></span><br><span class="line"><span class="comment">//含有中文字符串：</span></span><br><span class="line">str1 := <span class="string">"你好，世界！hello world"</span></span><br><span class="line">s1 := []<span class="keyword">rune</span>(str1)</span><br><span class="line">s1[<span class="number">3</span>] = <span class="string">'明'</span></span><br><span class="line">s1[<span class="number">4</span>] = <span class="string">'天'</span></span><br><span class="line">s1[<span class="number">12</span>] = <span class="string">'g'</span></span><br><span class="line">s1[<span class="number">13</span>] = <span class="string">'o'</span></span><br><span class="line">s1 = s1[:<span class="number">14</span>]</span><br><span class="line">str1 = <span class="keyword">string</span>(s1)</span><br><span class="line">fmt.Println(str1) <span class="comment">//输出：你好，明天！hello go</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用切片实现猜数字游戏"><a href="#利用切片实现猜数字游戏" class="headerlink" title="利用切片实现猜数字游戏"></a>利用切片实现猜数字游戏</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateNum</span><span class="params">(p *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().Unix())</span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">num = rand.Intn(<span class="number">10000</span>)</span><br><span class="line"><span class="keyword">if</span> num &gt; <span class="number">1000</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">*p = num</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetNum</span><span class="params">(s []<span class="keyword">int</span>, num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">s[<span class="number">0</span>] = num/<span class="number">1000</span></span><br><span class="line">s[<span class="number">1</span>] = num%<span class="number">1000</span>/<span class="number">100</span></span><br><span class="line">s[<span class="number">2</span>] = num%<span class="number">100</span>/<span class="number">10</span></span><br><span class="line">s[<span class="number">3</span>] = num%<span class="number">10</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OnGame</span><span class="params">(randSlice []<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">int</span></span><br><span class="line">keySlice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"请输入一个4位数："</span>)</span><br><span class="line">fmt.Scan(&amp;num)</span><br><span class="line"><span class="keyword">if</span> <span class="number">999</span> &lt; num &amp;&amp; num &lt;<span class="number">10000</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"输入的数不符合要求"</span>)</span><br><span class="line">&#125;</span><br><span class="line">GetNum(keySlice, num)</span><br><span class="line">n := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;<span class="number">4</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> keySlice[i] &gt;randSlice[i] &#123;</span><br><span class="line">fmt.Printf(<span class="string">"第%d位大了"</span>,i+<span class="number">1</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> keySlice[i] &lt; randSlice[i] &#123;</span><br><span class="line">fmt.Printf(<span class="string">"第%d位小了"</span>,i+<span class="number">1</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"第%d位猜对了"</span>, i+<span class="number">1</span>)</span><br><span class="line">n ++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">4</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"全部猜对。"</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> randNum <span class="keyword">int</span></span><br><span class="line"><span class="comment">//产生一个4位随机数</span></span><br><span class="line">CreateNum(&amp;randNum)</span><br><span class="line"><span class="comment">//取出每一位树</span></span><br><span class="line">randSlice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">//保存数的每一位</span></span><br><span class="line">GetNum(randSlice,randNum)</span><br><span class="line"><span class="comment">//输入一个4位数并读取每一位</span></span><br><span class="line">OnGame(randSlice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>map是一种<strong>无序的</strong>基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用。map中的数据都是成对出现的。<br>因为无序，所以我们无法确定它的返回顺序，所以每次打印的结果有可能顺序也不同。<br>在一个map里所有的键都是<strong>唯一</strong>的，而且必须支持<code>==</code>和<code>!=</code>操作符类型，<strong>切片、函数以及包含切片的结构类型这些类型由于具有引用语义，所以不能作为键</strong>。<br>map的定义语法如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[KeyType]ValueType</span><br><span class="line"></span><br><span class="line">KeyType:表示键的类型。</span><br><span class="line">ValueType:表示键对应的值的类型。</span><br></pre></td></tr></table></figure></p><p>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType, [<span class="built_in">cap</span>])</span><br></pre></td></tr></table></figure></p><p>其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。</p><h2 id="map的基本使用"><a href="#map的基本使用" class="headerlink" title="map的基本使用"></a>map的基本使用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">8</span>)</span><br><span class="line">scoreMap[<span class="string">"张三"</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">"李四"</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(scoreMap)  <span class="comment">//输出：map[张三:90 李四:100]</span></span><br><span class="line">fmt.Println(scoreMap[<span class="string">"张三"</span>]) <span class="comment">//输出：90</span></span><br><span class="line">fmt.Printf(<span class="string">"type of map is %T\n"</span>,scoreMap) <span class="comment">//输出：type of map is map[string]int</span></span><br><span class="line"><span class="comment">//map也支持在声明的时候填充元素</span></span><br><span class="line">userInfo := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> &#123;</span><br><span class="line"><span class="string">"username"</span>:<span class="string">"root"</span>,</span><br><span class="line"><span class="string">"password"</span>:<span class="string">"admin"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(userInfo) <span class="comment">//输出:map[password:admin username:root]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断某个键是否存在"><a href="#判断某个键是否存在" class="headerlink" title="判断某个键是否存在"></a>判断某个键是否存在</h2><p>Go语言中有个判断map中键是否存在的特殊写法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := <span class="keyword">map</span>[key]</span><br></pre></td></tr></table></figure></p><p>举个例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">int</span>)</span><br><span class="line">scoreMap[<span class="string">"张三"</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">"李四"</span>] = <span class="number">100</span></span><br><span class="line"><span class="comment">//如果key存在ok为true，v为对应的值，不存在ok为false，v为值类型的零值</span></span><br><span class="line">v,ok := scoreMap[<span class="string">"张三"</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(v)  <span class="comment">//输出：90</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"无"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="map的遍历"><a href="#map的遍历" class="headerlink" title="map的遍历"></a>map的遍历</h2><p>Go语言中使用for range遍历map。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    scoreMap[<span class="string">"张三"</span>] = <span class="number">90</span></span><br><span class="line">    scoreMap[<span class="string">"小明"</span>] = <span class="number">100</span></span><br><span class="line">    scoreMap[<span class="string">"王五"</span>] = <span class="number">60</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> scoreMap &#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当我们只想遍历key的时候，可以按下面的写法：</span></span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> scoreMap &#123; <span class="comment">//利用匿名变量</span></span><br><span class="line">        fmt.Println(k)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="map的删除"><a href="#map的删除" class="headerlink" title="map的删除"></a>map的删除</h2><p>使用delete()内建函数从map中删除一组键值对，delete()函数的格式如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span>, key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">map</span>:表示要删除的键值对的<span class="keyword">map</span>的id</span><br><span class="line">key:表示要删除的键值对的键</span><br></pre></td></tr></table></figure></p><p>示例代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    scoreMap[<span class="string">"张三"</span>] = <span class="number">90</span></span><br><span class="line">    scoreMap[<span class="string">"小明"</span>] = <span class="number">100</span></span><br><span class="line">    scoreMap[<span class="string">"王五"</span>] = <span class="number">60</span></span><br><span class="line">    <span class="built_in">delete</span>(scoreMap, <span class="string">"小明"</span>)<span class="comment">//将小明:100从map中删除</span></span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> scoreMap&#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="按照指定顺序遍历map"><a href="#按照指定顺序遍历map" class="headerlink" title="按照指定顺序遍历map"></a>按照指定顺序遍历map</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"sort"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano()) <span class="comment">//初始化随机数种子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scoreMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">key := fmt.Sprintf(<span class="string">"stu%02d"</span>, i) <span class="comment">//生成stu开头的字符串</span></span><br><span class="line">value := rand.Intn(<span class="number">100</span>)          <span class="comment">//生成0~99的随机整数</span></span><br><span class="line">scoreMap[key] = value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取出map中的所有key存入切片keys</span></span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">200</span>)</span><br><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> scoreMap &#123;</span><br><span class="line">keys = <span class="built_in">append</span>(keys, key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对切片进行排序</span></span><br><span class="line">sort.Strings(keys)</span><br><span class="line"><span class="comment">//按照排序后的key遍历map</span></span><br><span class="line"><span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">fmt.Println(key, scoreMap[key])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元素为map类型的切片"><a href="#元素为map类型的切片" class="headerlink" title="元素为map类型的切片"></a>元素为map类型的切片</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> mapSlice = <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> mapSlice &#123;</span><br><span class="line">fmt.Printf(<span class="string">"index:%d value:%v\n"</span>, index, value)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"after init"</span>)</span><br><span class="line"><span class="comment">// 对切片中的map元素进行初始化</span></span><br><span class="line">mapSlice[<span class="number">0</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">mapSlice[<span class="number">0</span>][<span class="string">"name"</span>] = <span class="string">"王五"</span></span><br><span class="line">mapSlice[<span class="number">0</span>][<span class="string">"password"</span>] = <span class="string">"123456"</span></span><br><span class="line">mapSlice[<span class="number">0</span>][<span class="string">"address"</span>] = <span class="string">"红旗大街"</span></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> mapSlice &#123;</span><br><span class="line">fmt.Printf(<span class="string">"index:%d value:%v\n"</span>, index, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">index:<span class="number">0</span> value:<span class="keyword">map</span>[]</span><br><span class="line">index:<span class="number">1</span> value:<span class="keyword">map</span>[]</span><br><span class="line">index:<span class="number">2</span> value:<span class="keyword">map</span>[]</span><br><span class="line">after init</span><br><span class="line">index:<span class="number">0</span> value:<span class="keyword">map</span>[address:红旗大街 name:王五 password:<span class="number">123456</span>]</span><br><span class="line">index:<span class="number">1</span> value:<span class="keyword">map</span>[]</span><br><span class="line">index:<span class="number">2</span> value:<span class="keyword">map</span>[]</span><br></pre></td></tr></table></figure></p><h2 id="值为切片类型的map"><a href="#值为切片类型的map" class="headerlink" title="值为切片类型的map"></a>值为切片类型的map</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> sliceMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(sliceMap)</span><br><span class="line">fmt.Println(<span class="string">"after init"</span>)</span><br><span class="line">key := <span class="string">"中国"</span></span><br><span class="line">value, ok := sliceMap[key]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">value = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">value = <span class="built_in">append</span>(value, <span class="string">"北京"</span>, <span class="string">"上海"</span>)</span><br><span class="line">sliceMap[key] = value</span><br><span class="line">fmt.Println(sliceMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[]</span><br><span class="line">after init</span><br><span class="line"><span class="keyword">map</span>[中国:[北京 上海]]</span><br></pre></td></tr></table></figure></p><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p><h2 id="类型别名和自定义类型"><a href="#类型别名和自定义类型" class="headerlink" title="类型别名和自定义类型"></a>类型别名和自定义类型</h2><h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><p>Go语言中可以使用type关键字来定义自定义类型，自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将MyInt定义为int类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br></pre></td></tr></table></figure></p><p>通过Type关键字的定义，MyInt就是一种新的类型，它具有int的特性。</p><h3 id="类型别名-1"><a href="#类型别名-1" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeAlias = Type</span><br></pre></td></tr></table></figure></p><p>我们之前见过的rune和byte就是类型别名，他们的定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br></pre></td></tr></table></figure></p><h3 id="类型定义和类型别名的区别"><a href="#类型定义和类型别名的区别" class="headerlink" title="类型定义和类型别名的区别"></a>类型定义和类型别名的区别</h3><p>类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">//类型定义</span></span><br><span class="line"><span class="keyword">type</span> NewInt <span class="keyword">int</span></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">type</span> MyInt = <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a NewInt</span><br><span class="line"><span class="keyword">var</span> b MyInt</span><br><span class="line">fmt.Printf(<span class="string">"type of a is %T\n"</span>,a)  <span class="comment">//type of a is main.NewInt</span></span><br><span class="line">fmt.Printf(<span class="string">"type of b is %T\n"</span>,b)  <span class="comment">//type of b is int</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果显示a的类型是main.NewInt，表示main包下定义的NewInt类型。b的类型是int。MyInt类型只会在代码中存在，编译完成时并不会有MyInt类型。</p><h2 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h2><p>Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以<strong>封装多个基本数据类型</strong>，这种数据类型叫结构体，英文名称struct。 也就是我们可以通过struct来定义自己的类型了。<br>Go语言中通过struct来实现面向对象。</p><h3 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h3><p>使用type和struct关键字来定义结构体，具体代码格式如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//类型名：标识自定义结构体的名称，在同一个包内不能重复。</span></span><br><span class="line">    <span class="comment">//字段名：表示结构体字段名。结构体中的字段名必须唯一。</span></span><br><span class="line">    <span class="comment">//字段类型：表示结构体字段的具体类型</span></span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>举个例子，我们定义一个Person结构体，代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    city <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样类型的字段也可以写在一行:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    name, city <span class="keyword">string</span></span><br><span class="line">    age        <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样我们就拥有了一个person的自定义类型，它有name、city、age三个字段，分别表示姓名、城市和年龄。这样我们使用这个person结构体就能够很方便的在程序中表示和存储人信息了。<br>语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型。</p><h3 id="结构体实例化"><a href="#结构体实例化" class="headerlink" title="结构体实例化"></a>结构体实例化</h3><p>只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。<br>结构体本身也是一种类型，我们可以像声明内置类型一样使用var关键字声明结构体类型。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 结构体实例 结构体类型</span><br></pre></td></tr></table></figure></p><h4 id="基本实例化"><a href="#基本实例化" class="headerlink" title="基本实例化"></a>基本实例化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">city <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p1 person</span><br><span class="line"><span class="comment">//我们通过.来访问结构体的字段（成员变量）,例如p1.name和p1.age等。</span></span><br><span class="line">p1.name = <span class="string">"pprof.cn"</span></span><br><span class="line">p1.city = <span class="string">"北京"</span></span><br><span class="line">p1.age = <span class="number">18</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>,p1)  <span class="comment">//main.person</span></span><br><span class="line">fmt.Printf(<span class="string">"p1=%v\n"</span>, p1)  <span class="comment">//p1=&#123;pprof.cn 北京 18&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">"p1=%#v\n"</span>, p1) <span class="comment">//p1=main.person&#123;name:"pprof.cn", city:"北京", age:18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="键值对初始化"><a href="#键值对初始化" class="headerlink" title="键值对初始化"></a>键值对初始化</h4><p>使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p5 := person&#123;</span><br><span class="line">name: <span class="string">"pprof.cn"</span>,</span><br><span class="line">city: <span class="string">"北京"</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, p5) <span class="comment">//main.person</span></span><br><span class="line">fmt.Printf(<span class="string">"p5=%#v\n"</span>, p5) <span class="comment">//p5=main.person&#123;name:"pprof.cn", city:"北京", age:18&#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h2><p>在定义一些临时数据结构等场景下还可以使用匿名结构体。<br>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。<br>匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> user <span class="keyword">struct</span>&#123;Name <span class="keyword">string</span>;Age <span class="keyword">int</span>&#125;</span><br><span class="line">user.Name = <span class="string">"hello"</span></span><br><span class="line">user.Age = <span class="number">18</span></span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, user)</span><br><span class="line"><span class="comment">//输出：struct &#123; Name string; Age int &#125;&#123;Name:"hello", Age:18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="指针类型结构体"><a href="#指针类型结构体" class="headerlink" title="指针类型结构体"></a>指针类型结构体</h2><h3 id="new关键字对结构体进行实例化"><a href="#new关键字对结构体进行实例化" class="headerlink" title="new关键字对结构体进行实例化"></a>new关键字对结构体进行实例化</h3><p>使用new关键字对结构体进行实例化，得到的是结构体的地址。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">city <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)  <span class="comment">//p2是一个结构体指针</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, p2)     <span class="comment">//*main.person</span></span><br><span class="line">fmt.Printf(<span class="string">"p2=%#v\n"</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:"", city:"", age:0&#125;</span></span><br><span class="line"><span class="comment">//在Go语言中支持对结构体指针直接使用.来访问结构体的成员</span></span><br><span class="line">p2.name = <span class="string">"测试"</span></span><br><span class="line">p2.age = <span class="number">18</span></span><br><span class="line">p2.city = <span class="string">"北京"</span></span><br><span class="line">fmt.Printf(<span class="string">"p2=%#v\n"</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:"测试", city:"北京", age:18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a>取结构体的地址实例化</h3><p>使用<code>&amp;</code>对结构体进行取地址操作相当于对该结构体类型进行了一次new实例化操作。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p3 := &amp;person&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, p3)     <span class="comment">//*main.person</span></span><br><span class="line">fmt.Printf(<span class="string">"p3=%#v\n"</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:"", city:"", age:0&#125;</span></span><br><span class="line">p3.name = <span class="string">"博客"</span></span><br><span class="line">p3.age = <span class="number">30</span></span><br><span class="line">p3.city = <span class="string">"成都"</span></span><br><span class="line">fmt.Printf(<span class="string">"p3=%#v\n"</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:"博客", city:"成都", age:30&#125;</span></span><br></pre></td></tr></table></figure></p><p><code>p3.name = &quot;博客&quot;</code>其实在底层是<code>(*p3).name = &quot;博客&quot;</code>，这是Go语言帮我们实现的语法糖。</p><h3 id="使用键值对初始化"><a href="#使用键值对初始化" class="headerlink" title="使用键值对初始化"></a>使用键值对初始化</h3><p>也可以对结构体指针进行键值对初始化:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p6 := &amp;person&#123;</span><br><span class="line">    name: <span class="string">"pprof.cn"</span>,</span><br><span class="line">    city: <span class="string">"北京"</span>,</span><br><span class="line">    age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"p6=%#v\n"</span>, p6) <span class="comment">//p6=&amp;main.person&#123;name:"pprof.cn", city:"北京", age:18&#125;</span></span><br></pre></td></tr></table></figure></p><p>当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p7 := &amp;person&#123;</span><br><span class="line">    city: <span class="string">"北京"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"p7=%#v\n"</span>, p7) <span class="comment">//p7=&amp;main.person&#123;name:"", city:"北京", age:0&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="使用值的列表初始化"><a href="#使用值的列表初始化" class="headerlink" title="使用值的列表初始化"></a>使用值的列表初始化</h3><p>初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p8 := &amp;person&#123;</span><br><span class="line">    <span class="string">"pprof.cn"</span>,</span><br><span class="line">    <span class="string">"北京"</span>,</span><br><span class="line">    <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"p8=%#v\n"</span>, p8) <span class="comment">//p8=&amp;main.person&#123;name:"pprof.cn", city:"北京", age:18&#125;</span></span><br></pre></td></tr></table></figure></p><p>使用这种格式初始化时，需要注意：<br>1.必须初始化结构体的所有字段。<br>2.初始值的填充顺序必须与字段在结构体中的声明顺序一致。<br>3.该方式不能和键值初始化方式混用。</p><h2 id="结构体内存布局"><a href="#结构体内存布局" class="headerlink" title="结构体内存布局"></a>结构体内存布局</h2><p>这里先放段代码不做解释，在go的中级篇中具体阐释。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="keyword">int8</span></span><br><span class="line">b <span class="keyword">uint32</span></span><br><span class="line">c <span class="keyword">byte</span></span><br><span class="line">d <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line">n := test&#123;</span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="string">'a'</span>, <span class="number">1.2</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"n.a %p\n"</span>, &amp;n.a)</span><br><span class="line">fmt.Printf(<span class="string">"n.b %p\n"</span>, &amp;n.b)</span><br><span class="line">fmt.Printf(<span class="string">"n.c %p\n"</span>, &amp;n.c)</span><br><span class="line">fmt.Printf(<span class="string">"n.d %p\n"</span>, &amp;n.d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n.a <span class="number">0xc00000a0d0</span></span><br><span class="line">n.b <span class="number">0xc00000a0d4</span></span><br><span class="line">n.c <span class="number">0xc00000a0d8</span></span><br><span class="line">n.d <span class="number">0xc00000a0dc</span></span><br></pre></td></tr></table></figure></p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个person的构造函数。 因为struct是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">city <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name, city <span class="keyword">string</span>,age <span class="keyword">int8</span>)</span> *<span class="title">person</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span>  &amp;person&#123;</span><br><span class="line">name:name,</span><br><span class="line">city:city,</span><br><span class="line">age:age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//调用构造函数</span></span><br><span class="line">p9 := newPerson(<span class="string">"hello"</span>,<span class="string">"world"</span>,<span class="number">90</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>,p9)  <span class="comment">//&amp;main.person&#123;name:"hello", city:"world", age:90&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a>方法和接收者</h2><p>Go语言中的方法（Method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者（Receiver）。接收者的概念就类似于其他语言中的this或者 self。</p><blockquote><p>方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</p></blockquote><p>方法的定义格式如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span> 方法名<span class="params">(参数列表)</span> <span class="params">(返回参数)</span></span> &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名的第一个小写字母，而不是self、this之类的命名。例如，Person类型的接收者变量应该命名为 p，Connector类型的接收者变量应该命名为c等。</span><br><span class="line"><span class="number">2.</span>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</span><br><span class="line"><span class="number">3.</span>方法名、参数列表、返回参数：具体格式与函数定义相同。</span><br></pre></td></tr></table></figure></p><p>举个例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//NewPerson构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">name:name,</span><br><span class="line">age:age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Dream Person做梦的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Dream</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s的梦想是学好go语言\n"</span>,p.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := NewPerson(<span class="string">"hello"</span>,<span class="number">25</span>)</span><br><span class="line">p1.Dream()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="指针类型的接收者"><a href="#指针类型的接收者" class="headerlink" title="指针类型的接收者"></a>指针类型的接收者</h3><p>指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的this或者self。<br>为Person添加一个SetAge方法，来修改实例变量的年龄:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetAge 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用指针接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">SetAge</span><span class="params">(newAge <span class="keyword">int8</span>)</span></span> &#123;</span><br><span class="line">p.age = newAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用该方法:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := NewPerson(<span class="string">"hello"</span>, <span class="number">25</span>)</span><br><span class="line">fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">p1.SetAge(<span class="number">30</span>)</span><br><span class="line">fmt.Println(p1.age) <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="值类型的接收者"><a href="#值类型的接收者" class="headerlink" title="值类型的接收者"></a>值类型的接收者</h3><p>当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetAge2 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用值接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">SetAge2</span><span class="params">(newAge <span class="keyword">int8</span>)</span></span> &#123;</span><br><span class="line">p.age = newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := NewPerson(<span class="string">"hello"</span>, <span class="number">25</span>)</span><br><span class="line">p1.Dream()</span><br><span class="line">fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">p1.SetAge2(<span class="number">30</span>) <span class="comment">// (*p1).SetAge2(30)</span></span><br><span class="line">fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="什么时候应该使用指针类型接收者"><a href="#什么时候应该使用指针类型接收者" class="headerlink" title="什么时候应该使用指针类型接收者"></a>什么时候应该使用指针类型接收者</h3><p>1.需要修改接收者中的值<br>2.接收者是拷贝代价比较大的大对象<br>3.保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</p><h3 id="任意类型添加方法"><a href="#任意类型添加方法" class="headerlink" title="任意类型添加方法"></a>任意类型添加方法</h3><p>在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的int类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MyInt 将int定义为自定义MyInt类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SayHello 为MyInt添加一个SayHello的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyInt)</span> <span class="title">SayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello, 我是一个int。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> m1 MyInt</span><br><span class="line">m1.SayHello() <span class="comment">//Hello, 我是一个int。</span></span><br><span class="line">m1 = <span class="number">100</span></span><br><span class="line">fmt.Printf(<span class="string">"%#v  %T\n"</span>, m1, m1) <span class="comment">//100  main.MyInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意事项： 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。</p><h2 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h2><p>一个结构体中可以嵌套包含另一个结构体或结构体指针。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">Province <span class="keyword">string</span></span><br><span class="line">City <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">Address Address</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">user1 := User&#123;</span><br><span class="line">Name:    <span class="string">"hello"</span>,</span><br><span class="line">Gender:  <span class="string">"男"</span>,</span><br><span class="line">Address: Address&#123;</span><br><span class="line">Province:<span class="string">"四川"</span>,</span><br><span class="line">City:<span class="string">"成都"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"user1 = %#v\n"</span>, user1)</span><br><span class="line"><span class="comment">//输出：user1 = main.User&#123;Name:"hello", Gender:"男", Address:main.Address&#123;Province:"四川", City:"成都"&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="嵌套匿名结构体"><a href="#嵌套匿名结构体" class="headerlink" title="嵌套匿名结构体"></a>嵌套匿名结构体</h3><p>当访问结构体成员时会先在结构体中查找该字段，找不到再去匿名结构体中查找。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">Province <span class="keyword">string</span></span><br><span class="line">City <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">Address  <span class="comment">//匿名结构体，实现代码的复用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> user2 User</span><br><span class="line">user2.Name = <span class="string">"hello"</span></span><br><span class="line">user2.Gender = <span class="string">"男"</span></span><br><span class="line">user2.Address.Province = <span class="string">"四川"</span> <span class="comment">//通过匿名结构体.字段名访问</span></span><br><span class="line">user2.City = <span class="string">"成都"</span>             <span class="comment">//直接访问匿名结构体的字段名</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>,user2) <span class="comment">//main.User</span></span><br><span class="line">fmt.Printf(<span class="string">"user2 = %#v\n"</span>, user2)</span><br><span class="line"><span class="comment">//user2 = main.User&#123;Name:"hello", Gender:"男", Address:main.Address&#123;Province:"四川", City:"成都"&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="嵌套结构体的字段名冲突"><a href="#嵌套结构体的字段名冲突" class="headerlink" title="嵌套结构体的字段名冲突"></a>嵌套结构体的字段名冲突</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">Province <span class="keyword">string</span></span><br><span class="line">City <span class="keyword">string</span></span><br><span class="line">CreateTime <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Email <span class="keyword">struct</span> &#123;</span><br><span class="line">Account <span class="keyword">string</span></span><br><span class="line">CreateTime <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">Address  <span class="comment">//匿名结构体</span></span><br><span class="line">Email</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> user3 User</span><br><span class="line">user3.Name = <span class="string">"pprof"</span></span><br><span class="line">user3.Gender = <span class="string">"男"</span></span><br><span class="line"><span class="comment">// user3.CreateTime = "2019" //会报错：ambiguous selector user3.CreateTime</span></span><br><span class="line">user3.Address.CreateTime = <span class="string">"2000"</span></span><br><span class="line">user3.Email.CreateTime = <span class="string">"2019"</span></span><br><span class="line">fmt.Printf(<span class="string">"user3 = %#v\n"</span>, user3)</span><br><span class="line"><span class="comment">//user3 = main.User&#123;Name:"pprof", Gender:"男", Address:main.Address&#123;Province:"", City:"", CreateTime:"2000"&#125;, Email:main.Email&#123;Account:"", CreateTime:"2019"&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体的“继承”"><a href="#结构体的“继承”" class="headerlink" title="结构体的“继承”"></a>结构体的“继承”</h2><p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s会动\n"</span>,a.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">Feet <span class="keyword">int8</span></span><br><span class="line">*Animal  <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span> <span class="title">wang</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s会汪汪汪\n"</span>,d.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d1 := &amp;Dog&#123;</span><br><span class="line">Feet:   <span class="number">4</span>,</span><br><span class="line">Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">name:<span class="string">"乐乐"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">d1.wang()  <span class="comment">//乐乐会汪汪汪</span></span><br><span class="line">d1.move()  <span class="comment">//乐乐会动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="结构体字段的可见性"><a href="#结构体字段的可见性" class="headerlink" title="结构体字段的可见性"></a>结构体字段的可见性</h2><p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//设置种子，只需一次</span></span><br><span class="line"><span class="comment">//rand.Seed(666) //如果种子参数一样，每次运行程序产生的随机数都一样</span></span><br><span class="line">rand.Seed(time.Now().UnixNano()) <span class="comment">//以当前系统时间为种子参数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i&lt;<span class="number">5</span>; i++&#123;</span><br><span class="line"><span class="comment">//产生随机数</span></span><br><span class="line">fmt.Println(<span class="string">"rand = "</span>,rand.Int()) <span class="comment">//会随机一个很大的数</span></span><br><span class="line">fmt.Println(<span class="string">"rand = "</span>,rand.Intn(<span class="number">100</span>)) <span class="comment">//限制在100内的数，不包括100但包括0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().Unix())</span><br><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>] <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i ++ &#123;</span><br><span class="line">a[i] = rand.Intn(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"排序前："</span>,a)</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(a); i &gt; <span class="number">0</span>; i -- &#123;</span><br><span class="line"><span class="keyword">for</span> j:= <span class="number">0</span>; j &lt; i &amp;&amp; j +<span class="number">1</span> &lt; i; j ++&#123;</span><br><span class="line"><span class="keyword">if</span> a[j] &gt; a[j+<span class="number">1</span>] &#123;</span><br><span class="line">a[j] ,a[j+<span class="number">1</span>] = a[j+<span class="number">1</span>], a[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"排序后："</span>,a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">排序前： [<span class="number">56</span> <span class="number">67</span> <span class="number">48</span> <span class="number">60</span> <span class="number">8</span> <span class="number">15</span> <span class="number">21</span> <span class="number">60</span> <span class="number">82</span> <span class="number">39</span>]</span><br><span class="line">排序后： [<span class="number">8</span> <span class="number">15</span> <span class="number">21</span> <span class="number">39</span> <span class="number">48</span> <span class="number">56</span> <span class="number">60</span> <span class="number">60</span> <span class="number">67</span> <span class="number">82</span>]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是Go语言从零开始学习的记录-基础部分。&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
</feed>
